.data

.string_1785:
	.asciz "----------------------\n"
	.align 8
.string_96:
	.asciz "a  %s\n"
	.align 8
.string_99:
	.asciz "a  th=%d, value=%d\n"
	.align 8
.string_1741:
	.asciz "alpha  %s\n"
	.align 8
.string_1744:
	.asciz "alpha  th=%d, value=%d\n"
	.align 8
.string_166:
	.asciz "args_a  %s\n"
	.align 8
.string_169:
	.asciz "args_a  th=%d, value=%d\n"
	.align 8
.string_171:
	.asciz "args_b  %s\n"
	.align 8
.string_174:
	.asciz "args_b  th=%d, value=%d\n"
	.align 8
.string_176:
	.asciz "args_c  %s\n"
	.align 8
.string_179:
	.asciz "args_c  th=%d, value=%d\n"
	.align 8
.string_181:
	.asciz "args_d  %s\n"
	.align 8
.string_184:
	.asciz "args_d  th=%d, value=%d\n"
	.align 8
.string_186:
	.asciz "args_e  %s\n"
	.align 8
.string_189:
	.asciz "args_e  th=%d, value=%d\n"
	.align 8
.string_191:
	.asciz "args_f  %s\n"
	.align 8
.string_194:
	.asciz "args_f  th=%d, value=%d\n"
	.align 8
.string_196:
	.asciz "args_g  %s\n"
	.align 8
.string_199:
	.asciz "args_g  th=%d, value=%d\n"
	.align 8
.string_201:
	.asciz "args_h  %s\n"
	.align 8
.string_204:
	.asciz "args_h  th=%d, value=%d\n"
	.align 8
.string_206:
	.asciz "args_i  %s\n"
	.align 8
.string_209:
	.asciz "args_i  th=%d, value=%d\n"
	.align 8
.string_211:
	.asciz "args_j  %s\n"
	.align 8
.string_214:
	.asciz "args_j  th=%d, value=%d\n"
	.align 8
.string_216:
	.asciz "args_k  %s\n"
	.align 8
.string_219:
	.asciz "args_k  th=%d, value=%d\n"
	.align 8
.string_101:
	.asciz "b  %s\n"
	.align 8
.string_104:
	.asciz "b  th=%d, value=%d\n"
	.align 8
.string_1746:
	.asciz "beta  %s\n"
	.align 8
.string_1749:
	.asciz "beta  th=%d, value=%d\n"
	.align 8
.string_106:
	.asciz "c  %s\n"
	.align 8
.string_109:
	.asciz "c  th=%d, value=%d\n"
	.align 8
.string_111:
	.asciz "d  %s\n"
	.align 8
.string_114:
	.asciz "d  th=%d, value=%d\n"
	.align 8
.string_1:
	.asciz "e1  %s\n"
	.align 8
.string_4:
	.asciz "e1  th=%d,  value=%d\n"
	.align 8
.string_6:
	.asciz "e2  %s\n"
	.align 8
.string_9:
	.asciz "e2  th=%d,  value=%d\n"
	.align 8
.string_11:
	.asciz "e3  %s\n"
	.align 8
.string_14:
	.asciz "e3  th=%d,  value=%d\n"
	.align 8
.string_16:
	.asciz "e4  %s\n"
	.align 8
.string_19:
	.asciz "e4  th=%d,  value=%d\n"
	.align 8
.string_21:
	.asciz "e5  %s\n"
	.align 8
.string_24:
	.asciz "e5  th=%d,  value=%d\n"
	.align 8
.string_26:
	.asciz "e6  %s\n"
	.align 8
.string_29:
	.asciz "e6  th=%d,  value=%d\n"
	.align 8
.string_31:
	.asciz "e7  %s\n"
	.align 8
.string_34:
	.asciz "e7  th=%d,  value=%d\n"
	.align 8
.string_36:
	.asciz "e8  %s\n"
	.align 8
.string_39:
	.asciz "e8  th=%d,  value=%d\n"
	.align 8
.string_41:
	.asciz "e9  %s\n"
	.align 8
.string_44:
	.asciz "e9  th=%d,  value=%d\n"
	.align 8
.string_1783:
	.asciz "failed"
	.align 8
.string_721:
	.asciz "global_1  %s\n"
	.align 8
.string_724:
	.asciz "global_1  th=%d, value=%d\n"
	.align 8
.string_726:
	.asciz "global_2  %s\n"
	.align 8
.string_729:
	.asciz "global_2  th=%d, value=%d\n"
	.align 8
.string_731:
	.asciz "global_3  %s\n"
	.align 8
.string_734:
	.asciz "global_3  th=%d, value=%d\n"
	.align 8
.string_736:
	.asciz "global_4  %s\n"
	.align 8
.string_739:
	.asciz "global_4  th=%d, value=%d\n"
	.align 8
.string_741:
	.asciz "global_5[0]  %s\n"
	.align 8
.string_744:
	.asciz "global_5[0]  th=%d, value=%d\n"
	.align 8
.string_841:
	.asciz "global_5[10]  %s\n"
	.align 8
.string_844:
	.asciz "global_5[10]  th=%d, value=%d\n"
	.align 8
.string_851:
	.asciz "global_5[11]  %s\n"
	.align 8
.string_854:
	.asciz "global_5[11]  th=%d, value=%d\n"
	.align 8
.string_861:
	.asciz "global_5[12]  %s\n"
	.align 8
.string_864:
	.asciz "global_5[12]  th=%d, value=%d\n"
	.align 8
.string_871:
	.asciz "global_5[13]  %s\n"
	.align 8
.string_874:
	.asciz "global_5[13]  th=%d, value=%d\n"
	.align 8
.string_881:
	.asciz "global_5[14]  %s\n"
	.align 8
.string_884:
	.asciz "global_5[14]  th=%d, value=%d\n"
	.align 8
.string_891:
	.asciz "global_5[15]  %s\n"
	.align 8
.string_894:
	.asciz "global_5[15]  th=%d, value=%d\n"
	.align 8
.string_901:
	.asciz "global_5[16]  %s\n"
	.align 8
.string_904:
	.asciz "global_5[16]  th=%d, value=%d\n"
	.align 8
.string_911:
	.asciz "global_5[17]  %s\n"
	.align 8
.string_914:
	.asciz "global_5[17]  th=%d, value=%d\n"
	.align 8
.string_921:
	.asciz "global_5[18]  %s\n"
	.align 8
.string_924:
	.asciz "global_5[18]  th=%d, value=%d\n"
	.align 8
.string_931:
	.asciz "global_5[19]  %s\n"
	.align 8
.string_934:
	.asciz "global_5[19]  th=%d, value=%d\n"
	.align 8
.string_751:
	.asciz "global_5[1]  %s\n"
	.align 8
.string_754:
	.asciz "global_5[1]  th=%d, value=%d\n"
	.align 8
.string_941:
	.asciz "global_5[20]  %s\n"
	.align 8
.string_944:
	.asciz "global_5[20]  th=%d, value=%d\n"
	.align 8
.string_951:
	.asciz "global_5[21]  %s\n"
	.align 8
.string_954:
	.asciz "global_5[21]  th=%d, value=%d\n"
	.align 8
.string_961:
	.asciz "global_5[22]  %s\n"
	.align 8
.string_964:
	.asciz "global_5[22]  th=%d, value=%d\n"
	.align 8
.string_971:
	.asciz "global_5[23]  %s\n"
	.align 8
.string_974:
	.asciz "global_5[23]  th=%d, value=%d\n"
	.align 8
.string_981:
	.asciz "global_5[24]  %s\n"
	.align 8
.string_984:
	.asciz "global_5[24]  th=%d, value=%d\n"
	.align 8
.string_991:
	.asciz "global_5[25]  %s\n"
	.align 8
.string_994:
	.asciz "global_5[25]  th=%d, value=%d\n"
	.align 8
.string_1001:
	.asciz "global_5[26]  %s\n"
	.align 8
.string_1004:
	.asciz "global_5[26]  th=%d, value=%d\n"
	.align 8
.string_1011:
	.asciz "global_5[27]  %s\n"
	.align 8
.string_1014:
	.asciz "global_5[27]  th=%d, value=%d\n"
	.align 8
.string_1021:
	.asciz "global_5[28]  %s\n"
	.align 8
.string_1024:
	.asciz "global_5[28]  th=%d, value=%d\n"
	.align 8
.string_1031:
	.asciz "global_5[29]  %s\n"
	.align 8
.string_1034:
	.asciz "global_5[29]  th=%d, value=%d\n"
	.align 8
.string_761:
	.asciz "global_5[2]  %s\n"
	.align 8
.string_764:
	.asciz "global_5[2]  th=%d, value=%d\n"
	.align 8
.string_1041:
	.asciz "global_5[30]  %s\n"
	.align 8
.string_1044:
	.asciz "global_5[30]  th=%d, value=%d\n"
	.align 8
.string_1051:
	.asciz "global_5[31]  %s\n"
	.align 8
.string_1054:
	.asciz "global_5[31]  th=%d, value=%d\n"
	.align 8
.string_1061:
	.asciz "global_5[32]  %s\n"
	.align 8
.string_1064:
	.asciz "global_5[32]  th=%d, value=%d\n"
	.align 8
.string_1071:
	.asciz "global_5[33]  %s\n"
	.align 8
.string_1074:
	.asciz "global_5[33]  th=%d, value=%d\n"
	.align 8
.string_1081:
	.asciz "global_5[34]  %s\n"
	.align 8
.string_1084:
	.asciz "global_5[34]  th=%d, value=%d\n"
	.align 8
.string_1091:
	.asciz "global_5[35]  %s\n"
	.align 8
.string_1094:
	.asciz "global_5[35]  th=%d, value=%d\n"
	.align 8
.string_1101:
	.asciz "global_5[36]  %s\n"
	.align 8
.string_1104:
	.asciz "global_5[36]  th=%d, value=%d\n"
	.align 8
.string_1111:
	.asciz "global_5[37]  %s\n"
	.align 8
.string_1114:
	.asciz "global_5[37]  th=%d, value=%d\n"
	.align 8
.string_1121:
	.asciz "global_5[38]  %s\n"
	.align 8
.string_1124:
	.asciz "global_5[38]  th=%d, value=%d\n"
	.align 8
.string_1131:
	.asciz "global_5[39]  %s\n"
	.align 8
.string_1134:
	.asciz "global_5[39]  th=%d, value=%d\n"
	.align 8
.string_771:
	.asciz "global_5[3]  %s\n"
	.align 8
.string_774:
	.asciz "global_5[3]  th=%d, value=%d\n"
	.align 8
.string_1141:
	.asciz "global_5[40]  %s\n"
	.align 8
.string_1144:
	.asciz "global_5[40]  th=%d, value=%d\n"
	.align 8
.string_1151:
	.asciz "global_5[41]  %s\n"
	.align 8
.string_1154:
	.asciz "global_5[41]  th=%d, value=%d\n"
	.align 8
.string_1161:
	.asciz "global_5[42]  %s\n"
	.align 8
.string_1164:
	.asciz "global_5[42]  th=%d, value=%d\n"
	.align 8
.string_1171:
	.asciz "global_5[43]  %s\n"
	.align 8
.string_1174:
	.asciz "global_5[43]  th=%d, value=%d\n"
	.align 8
.string_1181:
	.asciz "global_5[44]  %s\n"
	.align 8
.string_1184:
	.asciz "global_5[44]  th=%d, value=%d\n"
	.align 8
.string_1191:
	.asciz "global_5[45]  %s\n"
	.align 8
.string_1194:
	.asciz "global_5[45]  th=%d, value=%d\n"
	.align 8
.string_1201:
	.asciz "global_5[46]  %s\n"
	.align 8
.string_1204:
	.asciz "global_5[46]  th=%d, value=%d\n"
	.align 8
.string_1211:
	.asciz "global_5[47]  %s\n"
	.align 8
.string_1214:
	.asciz "global_5[47]  th=%d, value=%d\n"
	.align 8
.string_1221:
	.asciz "global_5[48]  %s\n"
	.align 8
.string_1224:
	.asciz "global_5[48]  th=%d, value=%d\n"
	.align 8
.string_1231:
	.asciz "global_5[49]  %s\n"
	.align 8
.string_1234:
	.asciz "global_5[49]  th=%d, value=%d\n"
	.align 8
.string_781:
	.asciz "global_5[4]  %s\n"
	.align 8
.string_784:
	.asciz "global_5[4]  th=%d, value=%d\n"
	.align 8
.string_1241:
	.asciz "global_5[50]  %s\n"
	.align 8
.string_1244:
	.asciz "global_5[50]  th=%d, value=%d\n"
	.align 8
.string_1251:
	.asciz "global_5[51]  %s\n"
	.align 8
.string_1254:
	.asciz "global_5[51]  th=%d, value=%d\n"
	.align 8
.string_1261:
	.asciz "global_5[52]  %s\n"
	.align 8
.string_1264:
	.asciz "global_5[52]  th=%d, value=%d\n"
	.align 8
.string_1271:
	.asciz "global_5[53]  %s\n"
	.align 8
.string_1274:
	.asciz "global_5[53]  th=%d, value=%d\n"
	.align 8
.string_1281:
	.asciz "global_5[54]  %s\n"
	.align 8
.string_1284:
	.asciz "global_5[54]  th=%d, value=%d\n"
	.align 8
.string_1291:
	.asciz "global_5[55]  %s\n"
	.align 8
.string_1294:
	.asciz "global_5[55]  th=%d, value=%d\n"
	.align 8
.string_1301:
	.asciz "global_5[56]  %s\n"
	.align 8
.string_1304:
	.asciz "global_5[56]  th=%d, value=%d\n"
	.align 8
.string_1311:
	.asciz "global_5[57]  %s\n"
	.align 8
.string_1314:
	.asciz "global_5[57]  th=%d, value=%d\n"
	.align 8
.string_1321:
	.asciz "global_5[58]  %s\n"
	.align 8
.string_1324:
	.asciz "global_5[58]  th=%d, value=%d\n"
	.align 8
.string_1331:
	.asciz "global_5[59]  %s\n"
	.align 8
.string_1334:
	.asciz "global_5[59]  th=%d, value=%d\n"
	.align 8
.string_791:
	.asciz "global_5[5]  %s\n"
	.align 8
.string_794:
	.asciz "global_5[5]  th=%d, value=%d\n"
	.align 8
.string_1341:
	.asciz "global_5[60]  %s\n"
	.align 8
.string_1344:
	.asciz "global_5[60]  th=%d, value=%d\n"
	.align 8
.string_1351:
	.asciz "global_5[61]  %s\n"
	.align 8
.string_1354:
	.asciz "global_5[61]  th=%d, value=%d\n"
	.align 8
.string_1361:
	.asciz "global_5[62]  %s\n"
	.align 8
.string_1364:
	.asciz "global_5[62]  th=%d, value=%d\n"
	.align 8
.string_1371:
	.asciz "global_5[63]  %s\n"
	.align 8
.string_1374:
	.asciz "global_5[63]  th=%d, value=%d\n"
	.align 8
.string_1381:
	.asciz "global_5[64]  %s\n"
	.align 8
.string_1384:
	.asciz "global_5[64]  th=%d, value=%d\n"
	.align 8
.string_1391:
	.asciz "global_5[65]  %s\n"
	.align 8
.string_1394:
	.asciz "global_5[65]  th=%d, value=%d\n"
	.align 8
.string_1401:
	.asciz "global_5[66]  %s\n"
	.align 8
.string_1404:
	.asciz "global_5[66]  th=%d, value=%d\n"
	.align 8
.string_1411:
	.asciz "global_5[67]  %s\n"
	.align 8
.string_1414:
	.asciz "global_5[67]  th=%d, value=%d\n"
	.align 8
.string_1421:
	.asciz "global_5[68]  %s\n"
	.align 8
.string_1424:
	.asciz "global_5[68]  th=%d, value=%d\n"
	.align 8
.string_1431:
	.asciz "global_5[69]  %s\n"
	.align 8
.string_1434:
	.asciz "global_5[69]  th=%d, value=%d\n"
	.align 8
.string_801:
	.asciz "global_5[6]  %s\n"
	.align 8
.string_804:
	.asciz "global_5[6]  th=%d, value=%d\n"
	.align 8
.string_1441:
	.asciz "global_5[70]  %s\n"
	.align 8
.string_1444:
	.asciz "global_5[70]  th=%d, value=%d\n"
	.align 8
.string_1451:
	.asciz "global_5[71]  %s\n"
	.align 8
.string_1454:
	.asciz "global_5[71]  th=%d, value=%d\n"
	.align 8
.string_1461:
	.asciz "global_5[72]  %s\n"
	.align 8
.string_1464:
	.asciz "global_5[72]  th=%d, value=%d\n"
	.align 8
.string_1471:
	.asciz "global_5[73]  %s\n"
	.align 8
.string_1474:
	.asciz "global_5[73]  th=%d, value=%d\n"
	.align 8
.string_1481:
	.asciz "global_5[74]  %s\n"
	.align 8
.string_1484:
	.asciz "global_5[74]  th=%d, value=%d\n"
	.align 8
.string_1491:
	.asciz "global_5[75]  %s\n"
	.align 8
.string_1494:
	.asciz "global_5[75]  th=%d, value=%d\n"
	.align 8
.string_1501:
	.asciz "global_5[76]  %s\n"
	.align 8
.string_1504:
	.asciz "global_5[76]  th=%d, value=%d\n"
	.align 8
.string_1511:
	.asciz "global_5[77]  %s\n"
	.align 8
.string_1514:
	.asciz "global_5[77]  th=%d, value=%d\n"
	.align 8
.string_1521:
	.asciz "global_5[78]  %s\n"
	.align 8
.string_1524:
	.asciz "global_5[78]  th=%d, value=%d\n"
	.align 8
.string_1531:
	.asciz "global_5[79]  %s\n"
	.align 8
.string_1534:
	.asciz "global_5[79]  th=%d, value=%d\n"
	.align 8
.string_811:
	.asciz "global_5[7]  %s\n"
	.align 8
.string_814:
	.asciz "global_5[7]  th=%d, value=%d\n"
	.align 8
.string_1541:
	.asciz "global_5[80]  %s\n"
	.align 8
.string_1544:
	.asciz "global_5[80]  th=%d, value=%d\n"
	.align 8
.string_1551:
	.asciz "global_5[81]  %s\n"
	.align 8
.string_1554:
	.asciz "global_5[81]  th=%d, value=%d\n"
	.align 8
.string_1561:
	.asciz "global_5[82]  %s\n"
	.align 8
.string_1564:
	.asciz "global_5[82]  th=%d, value=%d\n"
	.align 8
.string_1571:
	.asciz "global_5[83]  %s\n"
	.align 8
.string_1574:
	.asciz "global_5[83]  th=%d, value=%d\n"
	.align 8
.string_1581:
	.asciz "global_5[84]  %s\n"
	.align 8
.string_1584:
	.asciz "global_5[84]  th=%d, value=%d\n"
	.align 8
.string_1591:
	.asciz "global_5[85]  %s\n"
	.align 8
.string_1594:
	.asciz "global_5[85]  th=%d, value=%d\n"
	.align 8
.string_1601:
	.asciz "global_5[86]  %s\n"
	.align 8
.string_1604:
	.asciz "global_5[86]  th=%d, value=%d\n"
	.align 8
.string_1611:
	.asciz "global_5[87]  %s\n"
	.align 8
.string_1614:
	.asciz "global_5[87]  th=%d, value=%d\n"
	.align 8
.string_1621:
	.asciz "global_5[88]  %s\n"
	.align 8
.string_1624:
	.asciz "global_5[88]  th=%d, value=%d\n"
	.align 8
.string_1631:
	.asciz "global_5[89]  %s\n"
	.align 8
.string_1634:
	.asciz "global_5[89]  th=%d, value=%d\n"
	.align 8
.string_821:
	.asciz "global_5[8]  %s\n"
	.align 8
.string_824:
	.asciz "global_5[8]  th=%d, value=%d\n"
	.align 8
.string_1641:
	.asciz "global_5[90]  %s\n"
	.align 8
.string_1644:
	.asciz "global_5[90]  th=%d, value=%d\n"
	.align 8
.string_1651:
	.asciz "global_5[91]  %s\n"
	.align 8
.string_1654:
	.asciz "global_5[91]  th=%d, value=%d\n"
	.align 8
.string_1661:
	.asciz "global_5[92]  %s\n"
	.align 8
.string_1664:
	.asciz "global_5[92]  th=%d, value=%d\n"
	.align 8
.string_1671:
	.asciz "global_5[93]  %s\n"
	.align 8
.string_1674:
	.asciz "global_5[93]  th=%d, value=%d\n"
	.align 8
.string_1681:
	.asciz "global_5[94]  %s\n"
	.align 8
.string_1684:
	.asciz "global_5[94]  th=%d, value=%d\n"
	.align 8
.string_1691:
	.asciz "global_5[95]  %s\n"
	.align 8
.string_1694:
	.asciz "global_5[95]  th=%d, value=%d\n"
	.align 8
.string_1701:
	.asciz "global_5[96]  %s\n"
	.align 8
.string_1704:
	.asciz "global_5[96]  th=%d, value=%d\n"
	.align 8
.string_1711:
	.asciz "global_5[97]  %s\n"
	.align 8
.string_1714:
	.asciz "global_5[97]  th=%d, value=%d\n"
	.align 8
.string_1721:
	.asciz "global_5[98]  %s\n"
	.align 8
.string_1724:
	.asciz "global_5[98]  th=%d, value=%d\n"
	.align 8
.string_1731:
	.asciz "global_5[99]  %s\n"
	.align 8
.string_1734:
	.asciz "global_5[99]  th=%d, value=%d\n"
	.align 8
.string_831:
	.asciz "global_5[9]  %s\n"
	.align 8
.string_834:
	.asciz "global_5[9]  th=%d, value=%d\n"
	.align 8
.string_746:
	.asciz "global_6[0]  %s\n"
	.align 8
.string_749:
	.asciz "global_6[0]  th=%d, value=%d\n"
	.align 8
.string_846:
	.asciz "global_6[10]  %s\n"
	.align 8
.string_849:
	.asciz "global_6[10]  th=%d, value=%d\n"
	.align 8
.string_856:
	.asciz "global_6[11]  %s\n"
	.align 8
.string_859:
	.asciz "global_6[11]  th=%d, value=%d\n"
	.align 8
.string_866:
	.asciz "global_6[12]  %s\n"
	.align 8
.string_869:
	.asciz "global_6[12]  th=%d, value=%d\n"
	.align 8
.string_876:
	.asciz "global_6[13]  %s\n"
	.align 8
.string_879:
	.asciz "global_6[13]  th=%d, value=%d\n"
	.align 8
.string_886:
	.asciz "global_6[14]  %s\n"
	.align 8
.string_889:
	.asciz "global_6[14]  th=%d, value=%d\n"
	.align 8
.string_896:
	.asciz "global_6[15]  %s\n"
	.align 8
.string_899:
	.asciz "global_6[15]  th=%d, value=%d\n"
	.align 8
.string_906:
	.asciz "global_6[16]  %s\n"
	.align 8
.string_909:
	.asciz "global_6[16]  th=%d, value=%d\n"
	.align 8
.string_916:
	.asciz "global_6[17]  %s\n"
	.align 8
.string_919:
	.asciz "global_6[17]  th=%d, value=%d\n"
	.align 8
.string_926:
	.asciz "global_6[18]  %s\n"
	.align 8
.string_929:
	.asciz "global_6[18]  th=%d, value=%d\n"
	.align 8
.string_936:
	.asciz "global_6[19]  %s\n"
	.align 8
.string_939:
	.asciz "global_6[19]  th=%d, value=%d\n"
	.align 8
.string_756:
	.asciz "global_6[1]  %s\n"
	.align 8
.string_759:
	.asciz "global_6[1]  th=%d, value=%d\n"
	.align 8
.string_946:
	.asciz "global_6[20]  %s\n"
	.align 8
.string_949:
	.asciz "global_6[20]  th=%d, value=%d\n"
	.align 8
.string_956:
	.asciz "global_6[21]  %s\n"
	.align 8
.string_959:
	.asciz "global_6[21]  th=%d, value=%d\n"
	.align 8
.string_966:
	.asciz "global_6[22]  %s\n"
	.align 8
.string_969:
	.asciz "global_6[22]  th=%d, value=%d\n"
	.align 8
.string_976:
	.asciz "global_6[23]  %s\n"
	.align 8
.string_979:
	.asciz "global_6[23]  th=%d, value=%d\n"
	.align 8
.string_986:
	.asciz "global_6[24]  %s\n"
	.align 8
.string_989:
	.asciz "global_6[24]  th=%d, value=%d\n"
	.align 8
.string_996:
	.asciz "global_6[25]  %s\n"
	.align 8
.string_999:
	.asciz "global_6[25]  th=%d, value=%d\n"
	.align 8
.string_1006:
	.asciz "global_6[26]  %s\n"
	.align 8
.string_1009:
	.asciz "global_6[26]  th=%d, value=%d\n"
	.align 8
.string_1016:
	.asciz "global_6[27]  %s\n"
	.align 8
.string_1019:
	.asciz "global_6[27]  th=%d, value=%d\n"
	.align 8
.string_1026:
	.asciz "global_6[28]  %s\n"
	.align 8
.string_1029:
	.asciz "global_6[28]  th=%d, value=%d\n"
	.align 8
.string_1036:
	.asciz "global_6[29]  %s\n"
	.align 8
.string_1039:
	.asciz "global_6[29]  th=%d, value=%d\n"
	.align 8
.string_766:
	.asciz "global_6[2]  %s\n"
	.align 8
.string_769:
	.asciz "global_6[2]  th=%d, value=%d\n"
	.align 8
.string_1046:
	.asciz "global_6[30]  %s\n"
	.align 8
.string_1049:
	.asciz "global_6[30]  th=%d, value=%d\n"
	.align 8
.string_1056:
	.asciz "global_6[31]  %s\n"
	.align 8
.string_1059:
	.asciz "global_6[31]  th=%d, value=%d\n"
	.align 8
.string_1066:
	.asciz "global_6[32]  %s\n"
	.align 8
.string_1069:
	.asciz "global_6[32]  th=%d, value=%d\n"
	.align 8
.string_1076:
	.asciz "global_6[33]  %s\n"
	.align 8
.string_1079:
	.asciz "global_6[33]  th=%d, value=%d\n"
	.align 8
.string_1086:
	.asciz "global_6[34]  %s\n"
	.align 8
.string_1089:
	.asciz "global_6[34]  th=%d, value=%d\n"
	.align 8
.string_1096:
	.asciz "global_6[35]  %s\n"
	.align 8
.string_1099:
	.asciz "global_6[35]  th=%d, value=%d\n"
	.align 8
.string_1106:
	.asciz "global_6[36]  %s\n"
	.align 8
.string_1109:
	.asciz "global_6[36]  th=%d, value=%d\n"
	.align 8
.string_1116:
	.asciz "global_6[37]  %s\n"
	.align 8
.string_1119:
	.asciz "global_6[37]  th=%d, value=%d\n"
	.align 8
.string_1126:
	.asciz "global_6[38]  %s\n"
	.align 8
.string_1129:
	.asciz "global_6[38]  th=%d, value=%d\n"
	.align 8
.string_1136:
	.asciz "global_6[39]  %s\n"
	.align 8
.string_1139:
	.asciz "global_6[39]  th=%d, value=%d\n"
	.align 8
.string_776:
	.asciz "global_6[3]  %s\n"
	.align 8
.string_779:
	.asciz "global_6[3]  th=%d, value=%d\n"
	.align 8
.string_1146:
	.asciz "global_6[40]  %s\n"
	.align 8
.string_1149:
	.asciz "global_6[40]  th=%d, value=%d\n"
	.align 8
.string_1156:
	.asciz "global_6[41]  %s\n"
	.align 8
.string_1159:
	.asciz "global_6[41]  th=%d, value=%d\n"
	.align 8
.string_1166:
	.asciz "global_6[42]  %s\n"
	.align 8
.string_1169:
	.asciz "global_6[42]  th=%d, value=%d\n"
	.align 8
.string_1176:
	.asciz "global_6[43]  %s\n"
	.align 8
.string_1179:
	.asciz "global_6[43]  th=%d, value=%d\n"
	.align 8
.string_1186:
	.asciz "global_6[44]  %s\n"
	.align 8
.string_1189:
	.asciz "global_6[44]  th=%d, value=%d\n"
	.align 8
.string_1196:
	.asciz "global_6[45]  %s\n"
	.align 8
.string_1199:
	.asciz "global_6[45]  th=%d, value=%d\n"
	.align 8
.string_1206:
	.asciz "global_6[46]  %s\n"
	.align 8
.string_1209:
	.asciz "global_6[46]  th=%d, value=%d\n"
	.align 8
.string_1216:
	.asciz "global_6[47]  %s\n"
	.align 8
.string_1219:
	.asciz "global_6[47]  th=%d, value=%d\n"
	.align 8
.string_1226:
	.asciz "global_6[48]  %s\n"
	.align 8
.string_1229:
	.asciz "global_6[48]  th=%d, value=%d\n"
	.align 8
.string_1236:
	.asciz "global_6[49]  %s\n"
	.align 8
.string_1239:
	.asciz "global_6[49]  th=%d, value=%d\n"
	.align 8
.string_786:
	.asciz "global_6[4]  %s\n"
	.align 8
.string_789:
	.asciz "global_6[4]  th=%d, value=%d\n"
	.align 8
.string_1246:
	.asciz "global_6[50]  %s\n"
	.align 8
.string_1249:
	.asciz "global_6[50]  th=%d, value=%d\n"
	.align 8
.string_1256:
	.asciz "global_6[51]  %s\n"
	.align 8
.string_1259:
	.asciz "global_6[51]  th=%d, value=%d\n"
	.align 8
.string_1266:
	.asciz "global_6[52]  %s\n"
	.align 8
.string_1269:
	.asciz "global_6[52]  th=%d, value=%d\n"
	.align 8
.string_1276:
	.asciz "global_6[53]  %s\n"
	.align 8
.string_1279:
	.asciz "global_6[53]  th=%d, value=%d\n"
	.align 8
.string_1286:
	.asciz "global_6[54]  %s\n"
	.align 8
.string_1289:
	.asciz "global_6[54]  th=%d, value=%d\n"
	.align 8
.string_1296:
	.asciz "global_6[55]  %s\n"
	.align 8
.string_1299:
	.asciz "global_6[55]  th=%d, value=%d\n"
	.align 8
.string_1306:
	.asciz "global_6[56]  %s\n"
	.align 8
.string_1309:
	.asciz "global_6[56]  th=%d, value=%d\n"
	.align 8
.string_1316:
	.asciz "global_6[57]  %s\n"
	.align 8
.string_1319:
	.asciz "global_6[57]  th=%d, value=%d\n"
	.align 8
.string_1326:
	.asciz "global_6[58]  %s\n"
	.align 8
.string_1329:
	.asciz "global_6[58]  th=%d, value=%d\n"
	.align 8
.string_1336:
	.asciz "global_6[59]  %s\n"
	.align 8
.string_1339:
	.asciz "global_6[59]  th=%d, value=%d\n"
	.align 8
.string_796:
	.asciz "global_6[5]  %s\n"
	.align 8
.string_799:
	.asciz "global_6[5]  th=%d, value=%d\n"
	.align 8
.string_1346:
	.asciz "global_6[60]  %s\n"
	.align 8
.string_1349:
	.asciz "global_6[60]  th=%d, value=%d\n"
	.align 8
.string_1356:
	.asciz "global_6[61]  %s\n"
	.align 8
.string_1359:
	.asciz "global_6[61]  th=%d, value=%d\n"
	.align 8
.string_1366:
	.asciz "global_6[62]  %s\n"
	.align 8
.string_1369:
	.asciz "global_6[62]  th=%d, value=%d\n"
	.align 8
.string_1376:
	.asciz "global_6[63]  %s\n"
	.align 8
.string_1379:
	.asciz "global_6[63]  th=%d, value=%d\n"
	.align 8
.string_1386:
	.asciz "global_6[64]  %s\n"
	.align 8
.string_1389:
	.asciz "global_6[64]  th=%d, value=%d\n"
	.align 8
.string_1396:
	.asciz "global_6[65]  %s\n"
	.align 8
.string_1399:
	.asciz "global_6[65]  th=%d, value=%d\n"
	.align 8
.string_1406:
	.asciz "global_6[66]  %s\n"
	.align 8
.string_1409:
	.asciz "global_6[66]  th=%d, value=%d\n"
	.align 8
.string_1416:
	.asciz "global_6[67]  %s\n"
	.align 8
.string_1419:
	.asciz "global_6[67]  th=%d, value=%d\n"
	.align 8
.string_1426:
	.asciz "global_6[68]  %s\n"
	.align 8
.string_1429:
	.asciz "global_6[68]  th=%d, value=%d\n"
	.align 8
.string_1436:
	.asciz "global_6[69]  %s\n"
	.align 8
.string_1439:
	.asciz "global_6[69]  th=%d, value=%d\n"
	.align 8
.string_806:
	.asciz "global_6[6]  %s\n"
	.align 8
.string_809:
	.asciz "global_6[6]  th=%d, value=%d\n"
	.align 8
.string_1446:
	.asciz "global_6[70]  %s\n"
	.align 8
.string_1449:
	.asciz "global_6[70]  th=%d, value=%d\n"
	.align 8
.string_1456:
	.asciz "global_6[71]  %s\n"
	.align 8
.string_1459:
	.asciz "global_6[71]  th=%d, value=%d\n"
	.align 8
.string_1466:
	.asciz "global_6[72]  %s\n"
	.align 8
.string_1469:
	.asciz "global_6[72]  th=%d, value=%d\n"
	.align 8
.string_1476:
	.asciz "global_6[73]  %s\n"
	.align 8
.string_1479:
	.asciz "global_6[73]  th=%d, value=%d\n"
	.align 8
.string_1486:
	.asciz "global_6[74]  %s\n"
	.align 8
.string_1489:
	.asciz "global_6[74]  th=%d, value=%d\n"
	.align 8
.string_1496:
	.asciz "global_6[75]  %s\n"
	.align 8
.string_1499:
	.asciz "global_6[75]  th=%d, value=%d\n"
	.align 8
.string_1506:
	.asciz "global_6[76]  %s\n"
	.align 8
.string_1509:
	.asciz "global_6[76]  th=%d, value=%d\n"
	.align 8
.string_1516:
	.asciz "global_6[77]  %s\n"
	.align 8
.string_1519:
	.asciz "global_6[77]  th=%d, value=%d\n"
	.align 8
.string_1526:
	.asciz "global_6[78]  %s\n"
	.align 8
.string_1529:
	.asciz "global_6[78]  th=%d, value=%d\n"
	.align 8
.string_1536:
	.asciz "global_6[79]  %s\n"
	.align 8
.string_1539:
	.asciz "global_6[79]  th=%d, value=%d\n"
	.align 8
.string_816:
	.asciz "global_6[7]  %s\n"
	.align 8
.string_819:
	.asciz "global_6[7]  th=%d, value=%d\n"
	.align 8
.string_1546:
	.asciz "global_6[80]  %s\n"
	.align 8
.string_1549:
	.asciz "global_6[80]  th=%d, value=%d\n"
	.align 8
.string_1556:
	.asciz "global_6[81]  %s\n"
	.align 8
.string_1559:
	.asciz "global_6[81]  th=%d, value=%d\n"
	.align 8
.string_1566:
	.asciz "global_6[82]  %s\n"
	.align 8
.string_1569:
	.asciz "global_6[82]  th=%d, value=%d\n"
	.align 8
.string_1576:
	.asciz "global_6[83]  %s\n"
	.align 8
.string_1579:
	.asciz "global_6[83]  th=%d, value=%d\n"
	.align 8
.string_1586:
	.asciz "global_6[84]  %s\n"
	.align 8
.string_1589:
	.asciz "global_6[84]  th=%d, value=%d\n"
	.align 8
.string_1596:
	.asciz "global_6[85]  %s\n"
	.align 8
.string_1599:
	.asciz "global_6[85]  th=%d, value=%d\n"
	.align 8
.string_1606:
	.asciz "global_6[86]  %s\n"
	.align 8
.string_1609:
	.asciz "global_6[86]  th=%d, value=%d\n"
	.align 8
.string_1616:
	.asciz "global_6[87]  %s\n"
	.align 8
.string_1619:
	.asciz "global_6[87]  th=%d, value=%d\n"
	.align 8
.string_1626:
	.asciz "global_6[88]  %s\n"
	.align 8
.string_1629:
	.asciz "global_6[88]  th=%d, value=%d\n"
	.align 8
.string_1636:
	.asciz "global_6[89]  %s\n"
	.align 8
.string_1639:
	.asciz "global_6[89]  th=%d, value=%d\n"
	.align 8
.string_826:
	.asciz "global_6[8]  %s\n"
	.align 8
.string_829:
	.asciz "global_6[8]  th=%d, value=%d\n"
	.align 8
.string_1646:
	.asciz "global_6[90]  %s\n"
	.align 8
.string_1649:
	.asciz "global_6[90]  th=%d, value=%d\n"
	.align 8
.string_1656:
	.asciz "global_6[91]  %s\n"
	.align 8
.string_1659:
	.asciz "global_6[91]  th=%d, value=%d\n"
	.align 8
.string_1666:
	.asciz "global_6[92]  %s\n"
	.align 8
.string_1669:
	.asciz "global_6[92]  th=%d, value=%d\n"
	.align 8
.string_1676:
	.asciz "global_6[93]  %s\n"
	.align 8
.string_1679:
	.asciz "global_6[93]  th=%d, value=%d\n"
	.align 8
.string_1686:
	.asciz "global_6[94]  %s\n"
	.align 8
.string_1689:
	.asciz "global_6[94]  th=%d, value=%d\n"
	.align 8
.string_1696:
	.asciz "global_6[95]  %s\n"
	.align 8
.string_1699:
	.asciz "global_6[95]  th=%d, value=%d\n"
	.align 8
.string_1706:
	.asciz "global_6[96]  %s\n"
	.align 8
.string_1709:
	.asciz "global_6[96]  th=%d, value=%d\n"
	.align 8
.string_1716:
	.asciz "global_6[97]  %s\n"
	.align 8
.string_1719:
	.asciz "global_6[97]  th=%d, value=%d\n"
	.align 8
.string_1726:
	.asciz "global_6[98]  %s\n"
	.align 8
.string_1729:
	.asciz "global_6[98]  th=%d, value=%d\n"
	.align 8
.string_1736:
	.asciz "global_6[99]  %s\n"
	.align 8
.string_1739:
	.asciz "global_6[99]  th=%d, value=%d\n"
	.align 8
.string_836:
	.asciz "global_6[9]  %s\n"
	.align 8
.string_839:
	.asciz "global_6[9]  th=%d, value=%d\n"
	.align 8
.string_86:
	.asciz "j  %s\n"
	.align 8
.string_89:
	.asciz "j  th=%d,  value=%d\n"
	.align 8
.string_91:
	.asciz "k  %s\n"
	.align 8
.string_94:
	.asciz "k  th=%d,  value=%d\n"
	.align 8
.string_76:
	.asciz "l1  %s\n"
	.align 8
.string_79:
	.asciz "l1  th=%d,  value=%d\n"
	.align 8
.string_81:
	.asciz "l2  %s\n"
	.align 8
.string_84:
	.asciz "l2  th=%d,  value=%d\n"
	.align 8
.string_1782:
	.asciz "pass"
	.align 8
.string_46:
	.asciz "tab[0]  %s\n"
	.align 8
.string_49:
	.asciz "tab[0]  th=%d,  value=%d\n"
	.align 8
.string_51:
	.asciz "tab[1]  %s\n"
	.align 8
.string_54:
	.asciz "tab[1]  th=%d,  value=%d\n"
	.align 8
.string_56:
	.asciz "tab[2]  %s\n"
	.align 8
.string_59:
	.asciz "tab[2]  th=%d,  value=%d\n"
	.align 8
.string_61:
	.asciz "tab[3]  %s\n"
	.align 8
.string_64:
	.asciz "tab[3]  th=%d,  value=%d\n"
	.align 8
.string_66:
	.asciz "tab[4]  %s\n"
	.align 8
.string_69:
	.asciz "tab[4]  th=%d,  value=%d\n"
	.align 8
.string_71:
	.asciz "tab[5]  %s\n"
	.align 8
.string_74:
	.asciz "tab[5]  th=%d,  value=%d\n"
	.align 8
.string_221:
	.asciz "tab_1[0]  %s\n"
	.align 8
.string_224:
	.asciz "tab_1[0]  th=%d, value=%d\n"
	.align 8
.string_271:
	.asciz "tab_1[10]  %s\n"
	.align 8
.string_274:
	.asciz "tab_1[10]  th=%d, value=%d\n"
	.align 8
.string_276:
	.asciz "tab_1[11]  %s\n"
	.align 8
.string_279:
	.asciz "tab_1[11]  th=%d, value=%d\n"
	.align 8
.string_281:
	.asciz "tab_1[12]  %s\n"
	.align 8
.string_284:
	.asciz "tab_1[12]  th=%d, value=%d\n"
	.align 8
.string_286:
	.asciz "tab_1[13]  %s\n"
	.align 8
.string_289:
	.asciz "tab_1[13]  th=%d, value=%d\n"
	.align 8
.string_291:
	.asciz "tab_1[14]  %s\n"
	.align 8
.string_294:
	.asciz "tab_1[14]  th=%d, value=%d\n"
	.align 8
.string_296:
	.asciz "tab_1[15]  %s\n"
	.align 8
.string_299:
	.asciz "tab_1[15]  th=%d, value=%d\n"
	.align 8
.string_301:
	.asciz "tab_1[16]  %s\n"
	.align 8
.string_304:
	.asciz "tab_1[16]  th=%d, value=%d\n"
	.align 8
.string_306:
	.asciz "tab_1[17]  %s\n"
	.align 8
.string_309:
	.asciz "tab_1[17]  th=%d, value=%d\n"
	.align 8
.string_311:
	.asciz "tab_1[18]  %s\n"
	.align 8
.string_314:
	.asciz "tab_1[18]  th=%d, value=%d\n"
	.align 8
.string_316:
	.asciz "tab_1[19]  %s\n"
	.align 8
.string_319:
	.asciz "tab_1[19]  th=%d, value=%d\n"
	.align 8
.string_226:
	.asciz "tab_1[1]  %s\n"
	.align 8
.string_229:
	.asciz "tab_1[1]  th=%d, value=%d\n"
	.align 8
.string_321:
	.asciz "tab_1[20]  %s\n"
	.align 8
.string_324:
	.asciz "tab_1[20]  th=%d, value=%d\n"
	.align 8
.string_326:
	.asciz "tab_1[21]  %s\n"
	.align 8
.string_329:
	.asciz "tab_1[21]  th=%d, value=%d\n"
	.align 8
.string_331:
	.asciz "tab_1[22]  %s\n"
	.align 8
.string_334:
	.asciz "tab_1[22]  th=%d, value=%d\n"
	.align 8
.string_336:
	.asciz "tab_1[23]  %s\n"
	.align 8
.string_339:
	.asciz "tab_1[23]  th=%d, value=%d\n"
	.align 8
.string_341:
	.asciz "tab_1[24]  %s\n"
	.align 8
.string_344:
	.asciz "tab_1[24]  th=%d, value=%d\n"
	.align 8
.string_346:
	.asciz "tab_1[25]  %s\n"
	.align 8
.string_349:
	.asciz "tab_1[25]  th=%d, value=%d\n"
	.align 8
.string_351:
	.asciz "tab_1[26]  %s\n"
	.align 8
.string_354:
	.asciz "tab_1[26]  th=%d, value=%d\n"
	.align 8
.string_356:
	.asciz "tab_1[27]  %s\n"
	.align 8
.string_359:
	.asciz "tab_1[27]  th=%d, value=%d\n"
	.align 8
.string_361:
	.asciz "tab_1[28]  %s\n"
	.align 8
.string_364:
	.asciz "tab_1[28]  th=%d, value=%d\n"
	.align 8
.string_366:
	.asciz "tab_1[29]  %s\n"
	.align 8
.string_369:
	.asciz "tab_1[29]  th=%d, value=%d\n"
	.align 8
.string_231:
	.asciz "tab_1[2]  %s\n"
	.align 8
.string_234:
	.asciz "tab_1[2]  th=%d, value=%d\n"
	.align 8
.string_371:
	.asciz "tab_1[30]  %s\n"
	.align 8
.string_374:
	.asciz "tab_1[30]  th=%d, value=%d\n"
	.align 8
.string_376:
	.asciz "tab_1[31]  %s\n"
	.align 8
.string_379:
	.asciz "tab_1[31]  th=%d, value=%d\n"
	.align 8
.string_381:
	.asciz "tab_1[32]  %s\n"
	.align 8
.string_384:
	.asciz "tab_1[32]  th=%d, value=%d\n"
	.align 8
.string_386:
	.asciz "tab_1[33]  %s\n"
	.align 8
.string_389:
	.asciz "tab_1[33]  th=%d, value=%d\n"
	.align 8
.string_391:
	.asciz "tab_1[34]  %s\n"
	.align 8
.string_394:
	.asciz "tab_1[34]  th=%d, value=%d\n"
	.align 8
.string_396:
	.asciz "tab_1[35]  %s\n"
	.align 8
.string_399:
	.asciz "tab_1[35]  th=%d, value=%d\n"
	.align 8
.string_401:
	.asciz "tab_1[36]  %s\n"
	.align 8
.string_404:
	.asciz "tab_1[36]  th=%d, value=%d\n"
	.align 8
.string_406:
	.asciz "tab_1[37]  %s\n"
	.align 8
.string_409:
	.asciz "tab_1[37]  th=%d, value=%d\n"
	.align 8
.string_411:
	.asciz "tab_1[38]  %s\n"
	.align 8
.string_414:
	.asciz "tab_1[38]  th=%d, value=%d\n"
	.align 8
.string_416:
	.asciz "tab_1[39]  %s\n"
	.align 8
.string_419:
	.asciz "tab_1[39]  th=%d, value=%d\n"
	.align 8
.string_236:
	.asciz "tab_1[3]  %s\n"
	.align 8
.string_239:
	.asciz "tab_1[3]  th=%d, value=%d\n"
	.align 8
.string_421:
	.asciz "tab_1[40]  %s\n"
	.align 8
.string_424:
	.asciz "tab_1[40]  th=%d, value=%d\n"
	.align 8
.string_426:
	.asciz "tab_1[41]  %s\n"
	.align 8
.string_429:
	.asciz "tab_1[41]  th=%d, value=%d\n"
	.align 8
.string_431:
	.asciz "tab_1[42]  %s\n"
	.align 8
.string_434:
	.asciz "tab_1[42]  th=%d, value=%d\n"
	.align 8
.string_436:
	.asciz "tab_1[43]  %s\n"
	.align 8
.string_439:
	.asciz "tab_1[43]  th=%d, value=%d\n"
	.align 8
.string_441:
	.asciz "tab_1[44]  %s\n"
	.align 8
.string_444:
	.asciz "tab_1[44]  th=%d, value=%d\n"
	.align 8
.string_446:
	.asciz "tab_1[45]  %s\n"
	.align 8
.string_449:
	.asciz "tab_1[45]  th=%d, value=%d\n"
	.align 8
.string_451:
	.asciz "tab_1[46]  %s\n"
	.align 8
.string_454:
	.asciz "tab_1[46]  th=%d, value=%d\n"
	.align 8
.string_456:
	.asciz "tab_1[47]  %s\n"
	.align 8
.string_459:
	.asciz "tab_1[47]  th=%d, value=%d\n"
	.align 8
.string_461:
	.asciz "tab_1[48]  %s\n"
	.align 8
.string_464:
	.asciz "tab_1[48]  th=%d, value=%d\n"
	.align 8
.string_466:
	.asciz "tab_1[49]  %s\n"
	.align 8
.string_469:
	.asciz "tab_1[49]  th=%d, value=%d\n"
	.align 8
.string_241:
	.asciz "tab_1[4]  %s\n"
	.align 8
.string_244:
	.asciz "tab_1[4]  th=%d, value=%d\n"
	.align 8
.string_471:
	.asciz "tab_1[50]  %s\n"
	.align 8
.string_474:
	.asciz "tab_1[50]  th=%d, value=%d\n"
	.align 8
.string_476:
	.asciz "tab_1[51]  %s\n"
	.align 8
.string_479:
	.asciz "tab_1[51]  th=%d, value=%d\n"
	.align 8
.string_481:
	.asciz "tab_1[52]  %s\n"
	.align 8
.string_484:
	.asciz "tab_1[52]  th=%d, value=%d\n"
	.align 8
.string_486:
	.asciz "tab_1[53]  %s\n"
	.align 8
.string_489:
	.asciz "tab_1[53]  th=%d, value=%d\n"
	.align 8
.string_491:
	.asciz "tab_1[54]  %s\n"
	.align 8
.string_494:
	.asciz "tab_1[54]  th=%d, value=%d\n"
	.align 8
.string_496:
	.asciz "tab_1[55]  %s\n"
	.align 8
.string_499:
	.asciz "tab_1[55]  th=%d, value=%d\n"
	.align 8
.string_501:
	.asciz "tab_1[56]  %s\n"
	.align 8
.string_504:
	.asciz "tab_1[56]  th=%d, value=%d\n"
	.align 8
.string_506:
	.asciz "tab_1[57]  %s\n"
	.align 8
.string_509:
	.asciz "tab_1[57]  th=%d, value=%d\n"
	.align 8
.string_511:
	.asciz "tab_1[58]  %s\n"
	.align 8
.string_514:
	.asciz "tab_1[58]  th=%d, value=%d\n"
	.align 8
.string_516:
	.asciz "tab_1[59]  %s\n"
	.align 8
.string_519:
	.asciz "tab_1[59]  th=%d, value=%d\n"
	.align 8
.string_246:
	.asciz "tab_1[5]  %s\n"
	.align 8
.string_249:
	.asciz "tab_1[5]  th=%d, value=%d\n"
	.align 8
.string_521:
	.asciz "tab_1[60]  %s\n"
	.align 8
.string_524:
	.asciz "tab_1[60]  th=%d, value=%d\n"
	.align 8
.string_526:
	.asciz "tab_1[61]  %s\n"
	.align 8
.string_529:
	.asciz "tab_1[61]  th=%d, value=%d\n"
	.align 8
.string_531:
	.asciz "tab_1[62]  %s\n"
	.align 8
.string_534:
	.asciz "tab_1[62]  th=%d, value=%d\n"
	.align 8
.string_536:
	.asciz "tab_1[63]  %s\n"
	.align 8
.string_539:
	.asciz "tab_1[63]  th=%d, value=%d\n"
	.align 8
.string_541:
	.asciz "tab_1[64]  %s\n"
	.align 8
.string_544:
	.asciz "tab_1[64]  th=%d, value=%d\n"
	.align 8
.string_546:
	.asciz "tab_1[65]  %s\n"
	.align 8
.string_549:
	.asciz "tab_1[65]  th=%d, value=%d\n"
	.align 8
.string_551:
	.asciz "tab_1[66]  %s\n"
	.align 8
.string_554:
	.asciz "tab_1[66]  th=%d, value=%d\n"
	.align 8
.string_556:
	.asciz "tab_1[67]  %s\n"
	.align 8
.string_559:
	.asciz "tab_1[67]  th=%d, value=%d\n"
	.align 8
.string_561:
	.asciz "tab_1[68]  %s\n"
	.align 8
.string_564:
	.asciz "tab_1[68]  th=%d, value=%d\n"
	.align 8
.string_566:
	.asciz "tab_1[69]  %s\n"
	.align 8
.string_569:
	.asciz "tab_1[69]  th=%d, value=%d\n"
	.align 8
.string_251:
	.asciz "tab_1[6]  %s\n"
	.align 8
.string_254:
	.asciz "tab_1[6]  th=%d, value=%d\n"
	.align 8
.string_571:
	.asciz "tab_1[70]  %s\n"
	.align 8
.string_574:
	.asciz "tab_1[70]  th=%d, value=%d\n"
	.align 8
.string_576:
	.asciz "tab_1[71]  %s\n"
	.align 8
.string_579:
	.asciz "tab_1[71]  th=%d, value=%d\n"
	.align 8
.string_581:
	.asciz "tab_1[72]  %s\n"
	.align 8
.string_584:
	.asciz "tab_1[72]  th=%d, value=%d\n"
	.align 8
.string_586:
	.asciz "tab_1[73]  %s\n"
	.align 8
.string_589:
	.asciz "tab_1[73]  th=%d, value=%d\n"
	.align 8
.string_591:
	.asciz "tab_1[74]  %s\n"
	.align 8
.string_594:
	.asciz "tab_1[74]  th=%d, value=%d\n"
	.align 8
.string_596:
	.asciz "tab_1[75]  %s\n"
	.align 8
.string_599:
	.asciz "tab_1[75]  th=%d, value=%d\n"
	.align 8
.string_601:
	.asciz "tab_1[76]  %s\n"
	.align 8
.string_604:
	.asciz "tab_1[76]  th=%d, value=%d\n"
	.align 8
.string_606:
	.asciz "tab_1[77]  %s\n"
	.align 8
.string_609:
	.asciz "tab_1[77]  th=%d, value=%d\n"
	.align 8
.string_611:
	.asciz "tab_1[78]  %s\n"
	.align 8
.string_614:
	.asciz "tab_1[78]  th=%d, value=%d\n"
	.align 8
.string_616:
	.asciz "tab_1[79]  %s\n"
	.align 8
.string_619:
	.asciz "tab_1[79]  th=%d, value=%d\n"
	.align 8
.string_256:
	.asciz "tab_1[7]  %s\n"
	.align 8
.string_259:
	.asciz "tab_1[7]  th=%d, value=%d\n"
	.align 8
.string_621:
	.asciz "tab_1[80]  %s\n"
	.align 8
.string_624:
	.asciz "tab_1[80]  th=%d, value=%d\n"
	.align 8
.string_626:
	.asciz "tab_1[81]  %s\n"
	.align 8
.string_629:
	.asciz "tab_1[81]  th=%d, value=%d\n"
	.align 8
.string_631:
	.asciz "tab_1[82]  %s\n"
	.align 8
.string_634:
	.asciz "tab_1[82]  th=%d, value=%d\n"
	.align 8
.string_636:
	.asciz "tab_1[83]  %s\n"
	.align 8
.string_639:
	.asciz "tab_1[83]  th=%d, value=%d\n"
	.align 8
.string_641:
	.asciz "tab_1[84]  %s\n"
	.align 8
.string_644:
	.asciz "tab_1[84]  th=%d, value=%d\n"
	.align 8
.string_646:
	.asciz "tab_1[85]  %s\n"
	.align 8
.string_649:
	.asciz "tab_1[85]  th=%d, value=%d\n"
	.align 8
.string_651:
	.asciz "tab_1[86]  %s\n"
	.align 8
.string_654:
	.asciz "tab_1[86]  th=%d, value=%d\n"
	.align 8
.string_656:
	.asciz "tab_1[87]  %s\n"
	.align 8
.string_659:
	.asciz "tab_1[87]  th=%d, value=%d\n"
	.align 8
.string_661:
	.asciz "tab_1[88]  %s\n"
	.align 8
.string_664:
	.asciz "tab_1[88]  th=%d, value=%d\n"
	.align 8
.string_666:
	.asciz "tab_1[89]  %s\n"
	.align 8
.string_669:
	.asciz "tab_1[89]  th=%d, value=%d\n"
	.align 8
.string_261:
	.asciz "tab_1[8]  %s\n"
	.align 8
.string_264:
	.asciz "tab_1[8]  th=%d, value=%d\n"
	.align 8
.string_671:
	.asciz "tab_1[90]  %s\n"
	.align 8
.string_674:
	.asciz "tab_1[90]  th=%d, value=%d\n"
	.align 8
.string_676:
	.asciz "tab_1[91]  %s\n"
	.align 8
.string_679:
	.asciz "tab_1[91]  th=%d, value=%d\n"
	.align 8
.string_681:
	.asciz "tab_1[92]  %s\n"
	.align 8
.string_684:
	.asciz "tab_1[92]  th=%d, value=%d\n"
	.align 8
.string_686:
	.asciz "tab_1[93]  %s\n"
	.align 8
.string_689:
	.asciz "tab_1[93]  th=%d, value=%d\n"
	.align 8
.string_691:
	.asciz "tab_1[94]  %s\n"
	.align 8
.string_694:
	.asciz "tab_1[94]  th=%d, value=%d\n"
	.align 8
.string_696:
	.asciz "tab_1[95]  %s\n"
	.align 8
.string_699:
	.asciz "tab_1[95]  th=%d, value=%d\n"
	.align 8
.string_701:
	.asciz "tab_1[96]  %s\n"
	.align 8
.string_704:
	.asciz "tab_1[96]  th=%d, value=%d\n"
	.align 8
.string_706:
	.asciz "tab_1[97]  %s\n"
	.align 8
.string_709:
	.asciz "tab_1[97]  th=%d, value=%d\n"
	.align 8
.string_711:
	.asciz "tab_1[98]  %s\n"
	.align 8
.string_714:
	.asciz "tab_1[98]  th=%d, value=%d\n"
	.align 8
.string_716:
	.asciz "tab_1[99]  %s\n"
	.align 8
.string_719:
	.asciz "tab_1[99]  th=%d, value=%d\n"
	.align 8
.string_266:
	.asciz "tab_1[9]  %s\n"
	.align 8
.string_269:
	.asciz "tab_1[9]  th=%d, value=%d\n"
	.align 8
.string_1761:
	.asciz "test_args  %s\n"
	.align 8
.string_1764:
	.asciz "test_args th=%d, value=%d\n"
	.align 8
.string_1766:
	.asciz "test_args_2  %s\n"
	.align 8
.string_1769:
	.asciz "test_args_2 th=%d, value=%d\n"
	.align 8
.string_1756:
	.asciz "test_code  %s\n"
	.align 8
.string_1759:
	.asciz "test_code th=%d, value=%d\n"
	.align 8
.string_1751:
	.asciz "test_expr  %s\n"
	.align 8
.string_1754:
	.asciz "test_expr th=%d, value=%d\n"
	.align 8
.string_1771:
	.asciz "test_tabs[0]  %s\n"
	.align 8
.string_1774:
	.asciz "test_tabs[0] th=%d, value=%d\n"
	.align 8
.string_1776:
	.asciz "test_tabs[1]  %s\n"
	.align 8
.string_1779:
	.asciz "test_tabs[1] th=%d, value=%d\n"
	.align 8
.string_1781:
	.asciz "test_tabs[2]  %s\n"
	.align 8
.string_1784:
	.asciz "test_tabs[2] th=%d, value=%d\n"
	.align 8


.comm global_1,8,8
.comm global_2,8,8
.comm global_3,8,8
.comm global_4,8,8
.comm global_5,8,8
.comm global_6,8,8


.text

.globl test_expr
 test_expr:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	subq $144, %rsp
	movq $587, %rax
	movq %rax, -136(%rbp)
	movq $158, %rax
	neg %rax
	movq %rax, -144(%rbp)
	movq $156, %rax
	movq %rax, -8(%rbp)
	movq $129, %rax
	movq %rax, -16(%rbp)
	movq $11, %rax
	movq %rax, -24(%rbp)
	movq $1, %rax
	neg %rax
	movq %rax, -32(%rbp)
	movq $2, %rax
	pushq %rax
	movq $10, %rax
	popq %rcx
	xorq %rdx, %rdx
	cqo
	idivq %rcx
	pushq %rax
	movq $2, %rax
	pushq %rax
	movq -32(%rbp), %rax
	pushq %rax
	movq -24(%rbp), %rax
	pushq %rax
	movq -16(%rbp), %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	imulq %rcx, %rax
	popq %rcx
	addq %rcx, %rax
	popq %rcx
	subq %rcx, %rax
	popq %rcx
	addq %rcx, %rax
	popq %rcx
	addq %rcx, %rax
	neg %rax
	movq %rax, -40(%rbp)
	movq $11, %rax
	pushq %rax
	movq -24(%rbp), %rax
	popq %rcx
	xorq %rdx, %rdx
	cqo
	idivq %rcx
	pushq %rax
	movq $3, %rax
	pushq %rax
	movq $5, %rax
	pushq %rax
	movq -32(%rbp), %rax
	popq %rcx
	imulq %rcx, %rax
	popq %rcx
	addq %rcx, %rax
	pushq %rax
	movq -32(%rbp), %rax
	pushq %rax
	movq -24(%rbp), %rax
	pushq %rax
	movq -16(%rbp), %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	addq %rcx, %rax
	popq %rcx
	addq %rcx, %rax
	popq %rcx
	subq %rcx, %rax
	pushq %rax
	movq $5, %rax
	neg %rax
	popq %rcx
	imulq %rcx, %rax
	popq %rcx
	imulq %rcx, %rax
	popq %rcx
	addq %rcx, %rax
	movq %rax, -48(%rbp)
	movq $6, %rax
	pushq %rax
	movq $7, %rax
	pushq %rax
	movq $8, %rax
	pushq %rax
	movq -24(%rbp), %rax
	pushq %rax
	movq -32(%rbp), %rax
	pushq %rax
	movq -48(%rbp), %rax
	pushq %rax
	movq -40(%rbp), %rax
	popq %rcx
	imulq %rcx, %rax
	popq %rcx
	addq %rcx, %rax
	popq %rcx
	subq %rcx, %rax
	popq %rcx
	addq %rcx, %rax
	popq %rcx
	imulq %rcx, %rax
	popq %rcx
	subq %rcx, %rax
	movq %rax, -56(%rbp)
	movq -48(%rbp), %rax
	pushq %rax	# the value of expr is stored in for later
	inc %rax
	movq %rax, -48(%rbp)
	popq %rax
	pushq %rax
	movq -48(%rbp), %rax
	popq %rcx
	subq %rcx, %rax
	movq %rax, -64(%rbp)
	movq -56(%rbp), %rax
	pushq %rax	# the value of expr is stored in for later
	dec %rax
	movq %rax, -56(%rbp)
	popq %rax
	pushq %rax
	movq -56(%rbp), %rax
	popq %rcx
	subq %rcx, %rax
	movq %rax, -72(%rbp)
	movq -8(%rbp), %rax
	dec %rax
	movq %rax, -8(%rbp)
	pushq %rax
	movq -8(%rbp), %rax
	inc %rax
	movq %rax, -8(%rbp)
	popq %rcx
	subq %rcx, %rax
	movq %rax, -80(%rbp)
	movq -8(%rbp), %rax
	pushq %rax	# the value of expr is stored in for later
	dec %rax
	movq %rax, -8(%rbp)
	popq %rax
	pushq %rax
	movq -8(%rbp), %rax
	pushq %rax	# the value of expr is stored in for later
	inc %rax
	movq %rax, -8(%rbp)
	popq %rax
	popq %rcx
	subq %rcx, %rax
	movq %rax, -104(%rbp)
	movq -24(%rbp), %rax
	not %rax
	movq %rax, -88(%rbp)
	movq -24(%rbp), %rax
	pushq %rax
	movq -32(%rbp), %rax
	popq %rcx
	addq %rcx, %rax
	pushq %rax
	movq -40(%rbp), %rax
	popq %rcx
	xorq %rdx, %rdx
	cqo
	idivq %rcx
	movq %rdx, %rax
	movq %rax, -96(%rbp)
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $7, %rax
	pushq %rax
	movq $8, %rax
	popq %rcx
	imulq %rcx, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq malloc
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	movq %rax, -112(%rbp)
	movq -40(%rbp), %rax
	pushq %rax
	movq $0, %rax
	popq %rcx
	movq -112(%rbp), %rdx
	movq %rcx, (%rdx, %rax, 8)
	movq %rcx, %rax
	movq -48(%rbp), %rax
	pushq %rax
	movq $1, %rax
	popq %rcx
	movq -112(%rbp), %rdx
	movq %rcx, (%rdx, %rax, 8)
	movq %rcx, %rax
	movq -56(%rbp), %rax
	pushq %rax
	movq $3, %rax
	popq %rcx
	movq -112(%rbp), %rdx
	movq %rcx, (%rdx, %rax, 8)
	movq %rcx, %rax
	movq $3, %rax
	pushq %rax
	movq $0, %rax
	pushq %rax
	movq -112(%rbp), %rax
	popq %rcx
	movq $0, %rax
	movq %rax, %rcx
	movq -112(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	popq %rcx
	xorq %rdx, %rdx
	cqo
	idivq %rcx
	movq %rdx, %rax
	pushq %rax
	movq $5, %rax
	pushq %rax
	movq $1, %rax
	pushq %rax
	movq -112(%rbp), %rax
	popq %rcx
	movq $1, %rax
	movq %rax, %rcx
	movq -112(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	popq %rcx
	imulq %rcx, %rax
	pushq %rax
	movq $3, %rax
	pushq %rax
	movq -112(%rbp), %rax
	popq %rcx
	movq $3, %rax
	movq %rax, %rcx
	movq -112(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $0, %rax
	pushq %rax
	movq -112(%rbp), %rax
	popq %rcx
	movq $0, %rax
	movq %rax, %rcx
	movq -112(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	popq %rcx
	addq %rcx, %rax
	popq %rcx
	subq %rcx, %rax
	popq %rcx
	addq %rcx, %rax
	pushq %rax
	movq $4, %rax
	popq %rcx
	movq -112(%rbp), %rdx
	movq %rcx, (%rdx, %rax, 8)
	movq %rcx, %rax
	movq $1, %rax
	pushq %rax
	movq $6, %rax
	popq %rcx
	movq -112(%rbp), %rdx
	movq %rcx, (%rdx, %rax, 8)
	movq %rcx, %rax
	movq $6, %rax
	pushq %rax
	movq -112(%rbp), %rax
	popq %rcx
	movq $6, %rax
	movq %rax, %rcx
	movq -112(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $4, %rax
	pushq %rax
	movq -112(%rbp), %rax
	popq %rcx
	movq $4, %rax
	movq %rax, %rcx
	movq -112(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	popq %rcx
	imulq %rcx, %rax
	not %rax
	pushq %rax
	movq $5, %rax
	popq %rcx
	movq -112(%rbp), %rdx
	movq %rcx, (%rdx, %rax, 8)
	movq %rcx, %rax
	movq -96(%rbp), %rax
	pushq %rax
	movq $56, %rax
	pushq %rax
	movq $0, %rax
	pushq %rax
	movq $0, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_expr_successCmp_1787
	xorq %rax, %rax
	jmp .test_expr_continueCmp_1788
.test_expr_successCmp_1787:
	movq $1, %rax
.test_expr_continueCmp_1788:
	popq %rcx
	cmpq %rcx, %rax
	jl .test_expr_successCmp_1789
	xorq %rax, %rax
	jmp .test_expr_continueCmp_1790
.test_expr_successCmp_1789:
	movq $1, %rax
.test_expr_continueCmp_1790:
	popq %rcx
	cmpq %rcx, %rax
	jle .test_expr_successCmp_1791
	xorq %rax, %rax
	jmp .test_expr_continueCmp_1792
.test_expr_successCmp_1791:
	movq $1, %rax
.test_expr_continueCmp_1792:
	movq %rax, -120(%rbp)
	movq -96(%rbp), %rax
	pushq %rax
	movq -64(%rbp), %rax
	pushq %rax
	movq -40(%rbp), %rax
	pushq %rax
	movq -48(%rbp), %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_expr_successCmp_1793
	xorq %rax, %rax
	jmp .test_expr_continueCmp_1794
.test_expr_successCmp_1793:
	movq $1, %rax
.test_expr_continueCmp_1794:
	popq %rcx
	cmpq %rcx, %rax
	jl .test_expr_successCmp_1795
	xorq %rax, %rax
	jmp .test_expr_continueCmp_1796
.test_expr_successCmp_1795:
	movq $1, %rax
.test_expr_continueCmp_1796:
	popq %rcx
	cmpq %rcx, %rax
	jle .test_expr_successCmp_1797
	xorq %rax, %rax
	jmp .test_expr_continueCmp_1798
.test_expr_successCmp_1797:
	movq $1, %rax
.test_expr_continueCmp_1798:
	pushq %rax
	movq $4, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_expr_successCmp_1799
	xorq %rax, %rax
	jmp .test_expr_continueCmp_1800
.test_expr_successCmp_1799:
	movq $1, %rax
.test_expr_continueCmp_1800:
	movq %rax, -128(%rbp)
	movq $5, %rax
	pushq %rax
	movq -144(%rbp), %rax
	pushq %rax
	movq -136(%rbp), %rax
	popq %rcx
	addq %rcx, %rax
	popq %rcx
	cmpq %rcx, %rax
	jl .test_expr_successCmp_1801
	xorq %rax, %rax
	jmp .test_expr_continueCmp_1802
.test_expr_successCmp_1801:
	movq $1, %rax
.test_expr_continueCmp_1802:
	cmpq $0, %rax
	je .test_expr_failureIf_1804
	movq -48(%rbp), %rax
	pushq %rax
	movq -56(%rbp), %rax
	pushq %rax
	movq -88(%rbp), %rax
	pushq %rax
	movq -80(%rbp), %rax
	pushq %rax
	movq -128(%rbp), %rax
	pushq %rax
	movq -120(%rbp), %rax
	popq %rcx
	addq %rcx, %rax
	popq %rcx
	addq %rcx, %rax
	popq %rcx
	addq %rcx, %rax
	popq %rcx
	addq %rcx, %rax
	popq %rcx
	addq %rcx, %rax
	jmp .test_expr_endIf_1803
.test_expr_failureIf_1804:
	movq -48(%rbp), %rax
	pushq %rax
	movq -56(%rbp), %rax
	pushq %rax
	movq -88(%rbp), %rax
	pushq %rax
	movq $1, %rax
	pushq %rax
	movq -80(%rbp), %rax
	popq %rcx
	subq %rcx, %rax
	popq %rcx
	imulq %rcx, %rax
	popq %rcx
	imulq %rcx, %rax
	pushq %rax
	movq -128(%rbp), %rax
	pushq %rax
	movq -120(%rbp), %rax
	popq %rcx
	imulq %rcx, %rax
	popq %rcx
	addq %rcx, %rax
	popq %rcx
	subq %rcx, %rax
.test_expr_endIf_1803:
	movq %rax, -16(%rbp)
	movq $5, %rax
	pushq %rax
	movq -144(%rbp), %rax
	pushq %rax
	movq -136(%rbp), %rax
	popq %rcx
	addq %rcx, %rax
	popq %rcx
	cmpq %rcx, %rax
	jl .test_expr_successCmp_1805
	xorq %rax, %rax
	jmp .test_expr_continueCmp_1806
.test_expr_successCmp_1805:
	movq $1, %rax
.test_expr_continueCmp_1806:
	cmpq $0, %rax
	je .test_expr_failureIf_1808
	movq -48(%rbp), %rax
	pushq %rax
	movq -56(%rbp), %rax
	pushq %rax
	movq -88(%rbp), %rax
	pushq %rax
	movq -80(%rbp), %rax
	popq %rcx
	imulq %rcx, %rax
	pushq %rax
	movq -128(%rbp), %rax
	pushq %rax
	movq -120(%rbp), %rax
	popq %rcx
	addq %rcx, %rax
	popq %rcx
	subq %rcx, %rax
	popq %rcx
	addq %rcx, %rax
	popq %rcx
	addq %rcx, %rax
	jmp .test_expr_endIf_1807
.test_expr_failureIf_1808:
	movq -72(%rbp), %rax
	pushq %rax
	movq -64(%rbp), %rax
	pushq %rax
	movq $9, %rax
	popq %rcx
	imulq %rcx, %rax
	pushq %rax
	movq -48(%rbp), %rax
	pushq %rax
	movq -56(%rbp), %rax
	pushq %rax
	movq -88(%rbp), %rax
	pushq %rax
	movq $1, %rax
	pushq %rax
	movq -80(%rbp), %rax
	popq %rcx
	subq %rcx, %rax
	popq %rcx
	imulq %rcx, %rax
	popq %rcx
	imulq %rcx, %rax
	pushq %rax
	movq -128(%rbp), %rax
	pushq %rax
	movq -120(%rbp), %rax
	popq %rcx
	imulq %rcx, %rax
	popq %rcx
	addq %rcx, %rax
	popq %rcx
	subq %rcx, %rax
	popq %rcx
	subq %rcx, %rax
	popq %rcx
	addq %rcx, %rax
.test_expr_endIf_1807:
	movq %rax, -24(%rbp)
	movq $2, %rax
	pushq %rax
	movq -24(%rbp), %rax
	popq %rcx
	imulq %rcx, %rax
	pushq %rax
	movq -16(%rbp), %rax
	popq %rcx
	addq %rcx, %rax
	movq %rax, global_1
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -40(%rbp), %rax
	pushq %rax
	movq $20143, %rax
	neg %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_expr_successCmp_1809
	xorq %rax, %rax
	jmp .test_expr_continueCmp_1810
.test_expr_successCmp_1809:
	movq $1, %rax
.test_expr_continueCmp_1810:
	cmpq $0, %rax
	je .test_expr_failureIf_1812
	movq $.string_1782, %rax
	jmp .test_expr_endIf_1811
.test_expr_failureIf_1812:
	movq $.string_1783, %rax
.test_expr_endIf_1811:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -40(%rbp), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $20143, %rax
	neg %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_4, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -48(%rbp), %rax
	pushq %rax
	movq $2972, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_expr_successCmp_1813
	xorq %rax, %rax
	jmp .test_expr_continueCmp_1814
.test_expr_successCmp_1813:
	movq $1, %rax
.test_expr_continueCmp_1814:
	cmpq $0, %rax
	je .test_expr_failureIf_1816
	movq $.string_1782, %rax
	jmp .test_expr_endIf_1815
.test_expr_failureIf_1816:
	movq $.string_1783, %rax
.test_expr_endIf_1815:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_6, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -48(%rbp), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $2972, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_9, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -56(%rbp), %rax
	pushq %rax
	movq $418914006, %rax
	neg %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_expr_successCmp_1817
	xorq %rax, %rax
	jmp .test_expr_continueCmp_1818
.test_expr_successCmp_1817:
	movq $1, %rax
.test_expr_continueCmp_1818:
	cmpq $0, %rax
	je .test_expr_failureIf_1820
	movq $.string_1782, %rax
	jmp .test_expr_endIf_1819
.test_expr_failureIf_1820:
	movq $.string_1783, %rax
.test_expr_endIf_1819:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_11, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -56(%rbp), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $418914006, %rax
	neg %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_14, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -64(%rbp), %rax
	pushq %rax
	movq $1, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_expr_successCmp_1821
	xorq %rax, %rax
	jmp .test_expr_continueCmp_1822
.test_expr_successCmp_1821:
	movq $1, %rax
.test_expr_continueCmp_1822:
	cmpq $0, %rax
	je .test_expr_failureIf_1824
	movq $.string_1782, %rax
	jmp .test_expr_endIf_1823
.test_expr_failureIf_1824:
	movq $.string_1783, %rax
.test_expr_endIf_1823:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_16, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -64(%rbp), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $1, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_19, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -72(%rbp), %rax
	pushq %rax
	movq $1, %rax
	neg %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_expr_successCmp_1825
	xorq %rax, %rax
	jmp .test_expr_continueCmp_1826
.test_expr_successCmp_1825:
	movq $1, %rax
.test_expr_continueCmp_1826:
	cmpq $0, %rax
	je .test_expr_failureIf_1828
	movq $.string_1782, %rax
	jmp .test_expr_endIf_1827
.test_expr_failureIf_1828:
	movq $.string_1783, %rax
.test_expr_endIf_1827:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_21, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -72(%rbp), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $1, %rax
	neg %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_24, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -80(%rbp), %rax
	pushq %rax
	movq $1, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_expr_successCmp_1829
	xorq %rax, %rax
	jmp .test_expr_continueCmp_1830
.test_expr_successCmp_1829:
	movq $1, %rax
.test_expr_continueCmp_1830:
	cmpq $0, %rax
	je .test_expr_failureIf_1832
	movq $.string_1782, %rax
	jmp .test_expr_endIf_1831
.test_expr_failureIf_1832:
	movq $.string_1783, %rax
.test_expr_endIf_1831:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_26, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -80(%rbp), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $1, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_29, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -88(%rbp), %rax
	pushq %rax
	movq $12, %rax
	neg %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_expr_successCmp_1833
	xorq %rax, %rax
	jmp .test_expr_continueCmp_1834
.test_expr_successCmp_1833:
	movq $1, %rax
.test_expr_continueCmp_1834:
	cmpq $0, %rax
	je .test_expr_failureIf_1836
	movq $.string_1782, %rax
	jmp .test_expr_endIf_1835
.test_expr_failureIf_1836:
	movq $.string_1783, %rax
.test_expr_endIf_1835:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_31, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -88(%rbp), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $12, %rax
	neg %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_34, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -96(%rbp), %rax
	pushq %rax
	movq $3, %rax
	neg %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_expr_successCmp_1837
	xorq %rax, %rax
	jmp .test_expr_continueCmp_1838
.test_expr_successCmp_1837:
	movq $1, %rax
.test_expr_continueCmp_1838:
	cmpq $0, %rax
	je .test_expr_failureIf_1840
	movq $.string_1782, %rax
	jmp .test_expr_endIf_1839
.test_expr_failureIf_1840:
	movq $.string_1783, %rax
.test_expr_endIf_1839:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_36, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -96(%rbp), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $3, %rax
	neg %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_39, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -104(%rbp), %rax
	pushq %rax
	movq $1, %rax
	neg %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_expr_successCmp_1841
	xorq %rax, %rax
	jmp .test_expr_continueCmp_1842
.test_expr_successCmp_1841:
	movq $1, %rax
.test_expr_continueCmp_1842:
	cmpq $0, %rax
	je .test_expr_failureIf_1844
	movq $.string_1782, %rax
	jmp .test_expr_endIf_1843
.test_expr_failureIf_1844:
	movq $.string_1783, %rax
.test_expr_endIf_1843:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_41, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -104(%rbp), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $1, %rax
	neg %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_44, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $0, %rax
	pushq %rax
	movq -112(%rbp), %rax
	popq %rcx
	movq $0, %rax
	movq %rax, %rcx
	movq -112(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $20143, %rax
	neg %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_expr_successCmp_1845
	xorq %rax, %rax
	jmp .test_expr_continueCmp_1846
.test_expr_successCmp_1845:
	movq $1, %rax
.test_expr_continueCmp_1846:
	cmpq $0, %rax
	je .test_expr_failureIf_1848
	movq $.string_1782, %rax
	jmp .test_expr_endIf_1847
.test_expr_failureIf_1848:
	movq $.string_1783, %rax
.test_expr_endIf_1847:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_46, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $0, %rax
	pushq %rax
	movq -112(%rbp), %rax
	popq %rcx
	movq $0, %rax
	movq %rax, %rcx
	movq -112(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $20143, %rax
	neg %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_49, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $1, %rax
	pushq %rax
	movq -112(%rbp), %rax
	popq %rcx
	movq $1, %rax
	movq %rax, %rcx
	movq -112(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $2972, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_expr_successCmp_1849
	xorq %rax, %rax
	jmp .test_expr_continueCmp_1850
.test_expr_successCmp_1849:
	movq $1, %rax
.test_expr_continueCmp_1850:
	cmpq $0, %rax
	je .test_expr_failureIf_1852
	movq $.string_1782, %rax
	jmp .test_expr_endIf_1851
.test_expr_failureIf_1852:
	movq $.string_1783, %rax
.test_expr_endIf_1851:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_51, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $1, %rax
	pushq %rax
	movq -112(%rbp), %rax
	popq %rcx
	movq $1, %rax
	movq %rax, %rcx
	movq -112(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $2972, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_54, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $2, %rax
	pushq %rax
	movq -112(%rbp), %rax
	popq %rcx
	movq $2, %rax
	movq %rax, %rcx
	movq -112(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $0, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_expr_successCmp_1853
	xorq %rax, %rax
	jmp .test_expr_continueCmp_1854
.test_expr_successCmp_1853:
	movq $1, %rax
.test_expr_continueCmp_1854:
	cmpq $0, %rax
	je .test_expr_failureIf_1856
	movq $.string_1782, %rax
	jmp .test_expr_endIf_1855
.test_expr_failureIf_1856:
	movq $.string_1783, %rax
.test_expr_endIf_1855:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_56, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $2, %rax
	pushq %rax
	movq -112(%rbp), %rax
	popq %rcx
	movq $2, %rax
	movq %rax, %rcx
	movq -112(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $0, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_59, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $3, %rax
	pushq %rax
	movq -112(%rbp), %rax
	popq %rcx
	movq $3, %rax
	movq %rax, %rcx
	movq -112(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $418914006, %rax
	neg %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_expr_successCmp_1857
	xorq %rax, %rax
	jmp .test_expr_continueCmp_1858
.test_expr_successCmp_1857:
	movq $1, %rax
.test_expr_continueCmp_1858:
	cmpq $0, %rax
	je .test_expr_failureIf_1860
	movq $.string_1782, %rax
	jmp .test_expr_endIf_1859
.test_expr_failureIf_1860:
	movq $.string_1783, %rax
.test_expr_endIf_1859:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_61, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $3, %rax
	pushq %rax
	movq -112(%rbp), %rax
	popq %rcx
	movq $3, %rax
	movq %rax, %rcx
	movq -112(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $418914006, %rax
	neg %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_64, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $4, %rax
	pushq %rax
	movq -112(%rbp), %rax
	popq %rcx
	movq $4, %rax
	movq %rax, %rcx
	movq -112(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $418949010, %rax
	neg %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_expr_successCmp_1861
	xorq %rax, %rax
	jmp .test_expr_continueCmp_1862
.test_expr_successCmp_1861:
	movq $1, %rax
.test_expr_continueCmp_1862:
	cmpq $0, %rax
	je .test_expr_failureIf_1864
	movq $.string_1782, %rax
	jmp .test_expr_endIf_1863
.test_expr_failureIf_1864:
	movq $.string_1783, %rax
.test_expr_endIf_1863:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_66, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $4, %rax
	pushq %rax
	movq -112(%rbp), %rax
	popq %rcx
	movq $4, %rax
	movq %rax, %rcx
	movq -112(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $418949010, %rax
	neg %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_69, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $5, %rax
	pushq %rax
	movq -112(%rbp), %rax
	popq %rcx
	movq $5, %rax
	movq %rax, %rcx
	movq -112(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $418949009, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_expr_successCmp_1865
	xorq %rax, %rax
	jmp .test_expr_continueCmp_1866
.test_expr_successCmp_1865:
	movq $1, %rax
.test_expr_continueCmp_1866:
	cmpq $0, %rax
	je .test_expr_failureIf_1868
	movq $.string_1782, %rax
	jmp .test_expr_endIf_1867
.test_expr_failureIf_1868:
	movq $.string_1783, %rax
.test_expr_endIf_1867:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_71, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $5, %rax
	pushq %rax
	movq -112(%rbp), %rax
	popq %rcx
	movq $5, %rax
	movq %rax, %rcx
	movq -112(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $418949009, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_74, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -120(%rbp), %rax
	pushq %rax
	movq $0, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_expr_successCmp_1869
	xorq %rax, %rax
	jmp .test_expr_continueCmp_1870
.test_expr_successCmp_1869:
	movq $1, %rax
.test_expr_continueCmp_1870:
	cmpq $0, %rax
	je .test_expr_failureIf_1872
	movq $.string_1782, %rax
	jmp .test_expr_endIf_1871
.test_expr_failureIf_1872:
	movq $.string_1783, %rax
.test_expr_endIf_1871:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_76, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -120(%rbp), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $0, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_79, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -128(%rbp), %rax
	pushq %rax
	movq $0, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_expr_successCmp_1873
	xorq %rax, %rax
	jmp .test_expr_continueCmp_1874
.test_expr_successCmp_1873:
	movq $1, %rax
.test_expr_continueCmp_1874:
	cmpq $0, %rax
	je .test_expr_failureIf_1876
	movq $.string_1782, %rax
	jmp .test_expr_endIf_1875
.test_expr_failureIf_1876:
	movq $.string_1783, %rax
.test_expr_endIf_1875:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_81, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -128(%rbp), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $0, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_84, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -16(%rbp), %rax
	pushq %rax
	movq $2972, %rax
	neg %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_expr_successCmp_1877
	xorq %rax, %rax
	jmp .test_expr_continueCmp_1878
.test_expr_successCmp_1877:
	movq $1, %rax
.test_expr_continueCmp_1878:
	cmpq $0, %rax
	je .test_expr_failureIf_1880
	movq $.string_1782, %rax
	jmp .test_expr_endIf_1879
.test_expr_failureIf_1880:
	movq $.string_1783, %rax
.test_expr_endIf_1879:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_86, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -16(%rbp), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $2972, %rax
	neg %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_89, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -24(%rbp), %rax
	pushq %rax
	movq $2982, %rax
	neg %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_expr_successCmp_1881
	xorq %rax, %rax
	jmp .test_expr_continueCmp_1882
.test_expr_successCmp_1881:
	movq $1, %rax
.test_expr_continueCmp_1882:
	cmpq $0, %rax
	je .test_expr_failureIf_1884
	movq $.string_1782, %rax
	jmp .test_expr_endIf_1883
.test_expr_failureIf_1884:
	movq $.string_1783, %rax
.test_expr_endIf_1883:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_91, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -24(%rbp), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $2982, %rax
	neg %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_94, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -112(%rbp), %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq free
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	movq $56, %rax
	jmp .test_expr_endFunction_1786 	# return reached : end function
	addq $144, %rsp
.test_expr_endFunction_1786:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl test_code
 test_code:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	subq $88, %rsp
	movq $0, %rax
	movq %rax, -40(%rbp)
	movq $0, %rax
	movq %rax, -48(%rbp)
	movq $0, %rax
	movq %rax, -56(%rbp)
	movq $0, %rax
	movq %rax, -64(%rbp)
	movq $156, %rax
	movq %rax, -8(%rbp)
	movq $129, %rax
	movq %rax, -16(%rbp)
	movq $11, %rax
	movq %rax, -24(%rbp)
	movq $1, %rax
	neg %rax
	movq %rax, -32(%rbp)
	movq $1, %rax
	pushq %rax
	movq -24(%rbp), %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	addq %rcx, %rax
	popq %rcx
	subq %rcx, %rax
	movq %rax, global_2
	movq global_1, %rax
	pushq %rax	# the value of expr is stored in for later
	dec %rax
	movq %rax, global_1
	popq %rax
	movq $10, %rax
	pushq %rax
	movq $3, %rax
	pushq %rax
	movq -16(%rbp), %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	addq %rcx, %rax
	popq %rcx
	subq %rcx, %rax
	popq %rcx
	cmpq %rcx, %rax
	jl .test_code_successCmp_1886
	xorq %rax, %rax
	jmp .test_code_continueCmp_1887
.test_code_successCmp_1886:
	movq $1, %rax
.test_code_continueCmp_1887:
	cmpq $0, %rax
	je .test_code_failureIf_1889
	movq $50, %rax
	movq %rax, -72(%rbp)
.test_code_loopWhile_1891:
	movq -72(%rbp), %rax
	pushq %rax
	movq $0, %rax
	popq %rcx
	cmpq %rcx, %rax
	jl .test_code_successCmp_1892
	xorq %rax, %rax
	jmp .test_code_continueCmp_1893
.test_code_successCmp_1892:
	movq $1, %rax
.test_code_continueCmp_1893:
	cmpq $0, %rax
	je .test_code_endWhile_1890
	movq -32(%rbp), %rax
	pushq %rax
	movq $3, %rax
	popq %rcx
	imulq %rcx, %rax
	pushq %rax
	movq -40(%rbp), %rax
	pushq %rax
	movq -24(%rbp), %rax
	popq %rcx
	addq %rcx, %rax
	popq %rcx
	addq %rcx, %rax
	movq %rax, -40(%rbp)
	movq -72(%rbp), %rax
	pushq %rax	# the value of expr is stored in for later
	dec %rax
	movq %rax, -72(%rbp)
	popq %rax
	jmp .test_code_loopWhile_1891
.test_code_endWhile_1890:
	movq -32(%rbp), %rax
	pushq %rax
	movq -24(%rbp), %rax
	pushq %rax
	movq -16(%rbp), %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	imulq %rcx, %rax
	popq %rcx
	imulq %rcx, %rax
	popq %rcx
	imulq %rcx, %rax
	pushq %rax
	movq $6, %rax
	pushq %rax
	movq -32(%rbp), %rax
	popq %rcx
	imulq %rcx, %rax
	pushq %rax
	movq -24(%rbp), %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	addq %rcx, %rax
	popq %rcx
	addq %rcx, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_code_successCmp_1894
	xorq %rax, %rax
	jmp .test_code_continueCmp_1895
.test_code_successCmp_1894:
	movq $1, %rax
.test_code_continueCmp_1895:
	cmpq $0, %rax
	je .test_code_failureIf_1897
	movq $42, %rax
	movq %rax, -48(%rbp)
	jmp .test_code_endIf_1896
.test_code_failureIf_1897:
	movq $5, %rax
	movq %rax, -48(%rbp)
.test_code_endIf_1896:
	jmp .test_code_endIf_1888
.test_code_failureIf_1889:
	movq -32(%rbp), %rax
	pushq %rax
	movq -24(%rbp), %rax
	pushq %rax
	movq -16(%rbp), %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	imulq %rcx, %rax
	popq %rcx
	imulq %rcx, %rax
	popq %rcx
	imulq %rcx, %rax
	pushq %rax
	movq $6, %rax
	pushq %rax
	movq -32(%rbp), %rax
	popq %rcx
	imulq %rcx, %rax
	pushq %rax
	movq -24(%rbp), %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	addq %rcx, %rax
	popq %rcx
	addq %rcx, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_code_successCmp_1898
	xorq %rax, %rax
	jmp .test_code_continueCmp_1899
.test_code_successCmp_1898:
	movq $1, %rax
.test_code_continueCmp_1899:
	cmpq $0, %rax
	je .test_code_failureIf_1901
	movq $50, %rax
	movq %rax, -80(%rbp)
.test_code_loopWhile_1903:
	movq -80(%rbp), %rax
	pushq %rax
	movq $0, %rax
	popq %rcx
	cmpq %rcx, %rax
	jle .test_code_successCmp_1904
	xorq %rax, %rax
	jmp .test_code_continueCmp_1905
.test_code_successCmp_1904:
	movq $1, %rax
.test_code_continueCmp_1905:
	cmpq $0, %rax
	je .test_code_endWhile_1902
	movq -32(%rbp), %rax
	pushq %rax
	movq $3, %rax
	popq %rcx
	imulq %rcx, %rax
	pushq %rax
	movq -48(%rbp), %rax
	pushq %rax
	movq -24(%rbp), %rax
	popq %rcx
	addq %rcx, %rax
	popq %rcx
	addq %rcx, %rax
	movq %rax, -48(%rbp)
	movq -80(%rbp), %rax
	pushq %rax	# the value of expr is stored in for later
	dec %rax
	movq %rax, -80(%rbp)
	popq %rax
	jmp .test_code_loopWhile_1903
.test_code_endWhile_1902:
	jmp .test_code_endIf_1900
.test_code_failureIf_1901:
	movq $12, %rax
	movq %rax, -80(%rbp)
.test_code_loopWhile_1907:
	movq -80(%rbp), %rax
	pushq %rax
	movq $0, %rax
	popq %rcx
	cmpq %rcx, %rax
	jle .test_code_successCmp_1908
	xorq %rax, %rax
	jmp .test_code_continueCmp_1909
.test_code_successCmp_1908:
	movq $1, %rax
.test_code_continueCmp_1909:
	cmpq $0, %rax
	je .test_code_endWhile_1906
	movq -32(%rbp), %rax
	pushq %rax
	movq $3, %rax
	popq %rcx
	imulq %rcx, %rax
	pushq %rax
	movq -48(%rbp), %rax
	pushq %rax
	movq -24(%rbp), %rax
	popq %rcx
	addq %rcx, %rax
	popq %rcx
	addq %rcx, %rax
	movq %rax, -40(%rbp)
	movq -80(%rbp), %rax
	pushq %rax	# the value of expr is stored in for later
	dec %rax
	movq %rax, -80(%rbp)
	popq %rax
	jmp .test_code_loopWhile_1907
.test_code_endWhile_1906:
.test_code_endIf_1900:
.test_code_endIf_1888:
	movq $50, %rax
	movq %rax, -72(%rbp)
	movq $0, %rax
	movq %rax, -80(%rbp)
	movq $0, %rax
	movq %rax, -88(%rbp)
.test_code_loopWhile_1911:
	movq -72(%rbp), %rax
	pushq %rax
	movq $0, %rax
	popq %rcx
	cmpq %rcx, %rax
	jl .test_code_successCmp_1912
	xorq %rax, %rax
	jmp .test_code_continueCmp_1913
.test_code_successCmp_1912:
	movq $1, %rax
.test_code_continueCmp_1913:
	cmpq $0, %rax
	je .test_code_endWhile_1910
.test_code_loopWhile_1915:
	movq $15, %rax
	pushq %rax
	movq -80(%rbp), %rax
	popq %rcx
	cmpq %rcx, %rax
	jl .test_code_successCmp_1916
	xorq %rax, %rax
	jmp .test_code_continueCmp_1917
.test_code_successCmp_1916:
	movq $1, %rax
.test_code_continueCmp_1917:
	cmpq $0, %rax
	je .test_code_endWhile_1914
.test_code_loopWhile_1919:
	movq $0, %rax
	pushq %rax
	movq -88(%rbp), %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_code_successCmp_1920
	xorq %rax, %rax
	jmp .test_code_continueCmp_1921
.test_code_successCmp_1920:
	movq $1, %rax
.test_code_continueCmp_1921:
	cmpq $0, %rax
	je .test_code_endWhile_1918
	movq $1, %rax
	movq %rax, -88(%rbp)
	movq -56(%rbp), %rax
	pushq %rax
	movq -64(%rbp), %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	addq %rcx, %rax
	popq %rcx
	subq %rcx, %rax
	movq %rax, -56(%rbp)
	jmp .test_code_loopWhile_1919
.test_code_endWhile_1918:
	movq -64(%rbp), %rax
	pushq %rax
	movq -48(%rbp), %rax
	pushq %rax
	movq -40(%rbp), %rax
	popq %rcx
	addq %rcx, %rax
	popq %rcx
	subq %rcx, %rax
	movq %rax, -64(%rbp)
	movq -80(%rbp), %rax
	pushq %rax	# the value of expr is stored in for later
	inc %rax
	movq %rax, -80(%rbp)
	popq %rax
	jmp .test_code_loopWhile_1915
.test_code_endWhile_1914:
	movq -72(%rbp), %rax
	pushq %rax	# the value of expr is stored in for later
	dec %rax
	movq %rax, -72(%rbp)
	popq %rax
	jmp .test_code_loopWhile_1911
.test_code_endWhile_1910:
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -40(%rbp), %rax
	pushq %rax
	movq $8, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_code_successCmp_1922
	xorq %rax, %rax
	jmp .test_code_continueCmp_1923
.test_code_successCmp_1922:
	movq $1, %rax
.test_code_continueCmp_1923:
	cmpq $0, %rax
	je .test_code_failureIf_1925
	movq $.string_1782, %rax
	jmp .test_code_endIf_1924
.test_code_failureIf_1925:
	movq $.string_1783, %rax
.test_code_endIf_1924:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_96, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -40(%rbp), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $8, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_99, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -48(%rbp), %rax
	pushq %rax
	movq $0, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_code_successCmp_1926
	xorq %rax, %rax
	jmp .test_code_continueCmp_1927
.test_code_successCmp_1926:
	movq $1, %rax
.test_code_continueCmp_1927:
	cmpq $0, %rax
	je .test_code_failureIf_1929
	movq $.string_1782, %rax
	jmp .test_code_endIf_1928
.test_code_failureIf_1929:
	movq $.string_1783, %rax
.test_code_endIf_1928:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_101, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -48(%rbp), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $0, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_104, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -56(%rbp), %rax
	pushq %rax
	movq $156, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_code_successCmp_1930
	xorq %rax, %rax
	jmp .test_code_continueCmp_1931
.test_code_successCmp_1930:
	movq $1, %rax
.test_code_continueCmp_1931:
	cmpq $0, %rax
	je .test_code_failureIf_1933
	movq $.string_1782, %rax
	jmp .test_code_endIf_1932
.test_code_failureIf_1933:
	movq $.string_1783, %rax
.test_code_endIf_1932:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_106, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -56(%rbp), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $156, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_109, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -64(%rbp), %rax
	pushq %rax
	movq $8, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_code_successCmp_1934
	xorq %rax, %rax
	jmp .test_code_continueCmp_1935
.test_code_successCmp_1934:
	movq $1, %rax
.test_code_continueCmp_1935:
	cmpq $0, %rax
	je .test_code_failureIf_1937
	movq $.string_1782, %rax
	jmp .test_code_endIf_1936
.test_code_failureIf_1937:
	movq $.string_1783, %rax
.test_code_endIf_1936:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_111, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -64(%rbp), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $8, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_114, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	movq -64(%rbp), %rax
	pushq %rax
	movq -56(%rbp), %rax
	pushq %rax
	movq $3, %rax
	pushq %rax
	movq $9, %rax
	popq %rcx
	xorq %rdx, %rdx
	cqo
	idivq %rcx
	pushq %rax
	movq -48(%rbp), %rax
	pushq %rax
	movq -40(%rbp), %rax
	popq %rcx
	imulq %rcx, %rax
	popq %rcx
	subq %rcx, %rax
	popq %rcx
	addq %rcx, %rax
	popq %rcx
	subq %rcx, %rax
	jmp .test_code_endFunction_1885 	# return reached : end function
	addq $88, %rsp
.test_code_endFunction_1885:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl test_args
 test_args:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	pushq %rdi	# saving argument number 1 on the stack
	pushq %rsi	# saving argument number 2 on the stack
	pushq %rdx	# saving argument number 3 on the stack
	pushq %rcx	# saving argument number 4 on the stack
	pushq %r8	# saving argument number 5 on the stack
	pushq %r9	# saving argument number 6 on the stack
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -8(%rbp), %rax
	pushq %rax
	movq $5, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_args_successCmp_1939
	xorq %rax, %rax
	jmp .test_args_continueCmp_1940
.test_args_successCmp_1939:
	movq $1, %rax
.test_args_continueCmp_1940:
	cmpq $0, %rax
	je .test_args_failureIf_1942
	movq $.string_1782, %rax
	jmp .test_args_endIf_1941
.test_args_failureIf_1942:
	movq $.string_1783, %rax
.test_args_endIf_1941:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_166, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -8(%rbp), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $5, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_169, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -16(%rbp), %rax
	pushq %rax
	movq $8937, %rax
	neg %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_args_successCmp_1943
	xorq %rax, %rax
	jmp .test_args_continueCmp_1944
.test_args_successCmp_1943:
	movq $1, %rax
.test_args_continueCmp_1944:
	cmpq $0, %rax
	je .test_args_failureIf_1946
	movq $.string_1782, %rax
	jmp .test_args_endIf_1945
.test_args_failureIf_1946:
	movq $.string_1783, %rax
.test_args_endIf_1945:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_171, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -16(%rbp), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $8937, %rax
	neg %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_174, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -24(%rbp), %rax
	pushq %rax
	movq $1483542, %rax
	neg %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_args_successCmp_1947
	xorq %rax, %rax
	jmp .test_args_continueCmp_1948
.test_args_successCmp_1947:
	movq $1, %rax
.test_args_continueCmp_1948:
	cmpq $0, %rax
	je .test_args_failureIf_1950
	movq $.string_1782, %rax
	jmp .test_args_endIf_1949
.test_args_failureIf_1950:
	movq $.string_1783, %rax
.test_args_endIf_1949:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_176, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -24(%rbp), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $1483542, %rax
	neg %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_179, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -32(%rbp), %rax
	pushq %rax
	movq $8938, %rax
	neg %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_args_successCmp_1951
	xorq %rax, %rax
	jmp .test_args_continueCmp_1952
.test_args_successCmp_1951:
	movq $1, %rax
.test_args_continueCmp_1952:
	cmpq $0, %rax
	je .test_args_failureIf_1954
	movq $.string_1782, %rax
	jmp .test_args_endIf_1953
.test_args_failureIf_1954:
	movq $.string_1783, %rax
.test_args_endIf_1953:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_181, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -32(%rbp), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $8938, %rax
	neg %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_184, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -40(%rbp), %rax
	pushq %rax
	movq $1547, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_args_successCmp_1955
	xorq %rax, %rax
	jmp .test_args_continueCmp_1956
.test_args_successCmp_1955:
	movq $1, %rax
.test_args_continueCmp_1956:
	cmpq $0, %rax
	je .test_args_failureIf_1958
	movq $.string_1782, %rax
	jmp .test_args_endIf_1957
.test_args_failureIf_1958:
	movq $.string_1783, %rax
.test_args_endIf_1957:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_186, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -40(%rbp), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $1547, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_189, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -48(%rbp), %rax
	pushq %rax
	movq $12, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_args_successCmp_1959
	xorq %rax, %rax
	jmp .test_args_continueCmp_1960
.test_args_successCmp_1959:
	movq $1, %rax
.test_args_continueCmp_1960:
	cmpq $0, %rax
	je .test_args_failureIf_1962
	movq $.string_1782, %rax
	jmp .test_args_endIf_1961
.test_args_failureIf_1962:
	movq $.string_1783, %rax
.test_args_endIf_1961:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_191, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -48(%rbp), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $12, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_194, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq 56(%rbp), %rax
	pushq %rax
	movq $589, %rax
	neg %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_args_successCmp_1963
	xorq %rax, %rax
	jmp .test_args_continueCmp_1964
.test_args_successCmp_1963:
	movq $1, %rax
.test_args_continueCmp_1964:
	cmpq $0, %rax
	je .test_args_failureIf_1966
	movq $.string_1782, %rax
	jmp .test_args_endIf_1965
.test_args_failureIf_1966:
	movq $.string_1783, %rax
.test_args_endIf_1965:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_196, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq 56(%rbp), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $589, %rax
	neg %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_199, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq 64(%rbp), %rax
	pushq %rax
	movq $166, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_args_successCmp_1967
	xorq %rax, %rax
	jmp .test_args_continueCmp_1968
.test_args_successCmp_1967:
	movq $1, %rax
.test_args_continueCmp_1968:
	cmpq $0, %rax
	je .test_args_failureIf_1970
	movq $.string_1782, %rax
	jmp .test_args_endIf_1969
.test_args_failureIf_1970:
	movq $.string_1783, %rax
.test_args_endIf_1969:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_201, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq 64(%rbp), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $166, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_204, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq 72(%rbp), %rax
	pushq %rax
	movq $8937, %rax
	neg %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_args_successCmp_1971
	xorq %rax, %rax
	jmp .test_args_continueCmp_1972
.test_args_successCmp_1971:
	movq $1, %rax
.test_args_continueCmp_1972:
	cmpq $0, %rax
	je .test_args_failureIf_1974
	movq $.string_1782, %rax
	jmp .test_args_endIf_1973
.test_args_failureIf_1974:
	movq $.string_1783, %rax
.test_args_endIf_1973:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_206, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq 72(%rbp), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $8937, %rax
	neg %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_209, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq 80(%rbp), %rax
	pushq %rax
	movq $5, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_args_successCmp_1975
	xorq %rax, %rax
	jmp .test_args_continueCmp_1976
.test_args_successCmp_1975:
	movq $1, %rax
.test_args_continueCmp_1976:
	cmpq $0, %rax
	je .test_args_failureIf_1978
	movq $.string_1782, %rax
	jmp .test_args_endIf_1977
.test_args_failureIf_1978:
	movq $.string_1783, %rax
.test_args_endIf_1977:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_211, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq 80(%rbp), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $5, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_214, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	movq $0, %rax
	pushq %rax
	movq 80(%rbp), %rax
	pushq %rax
	movq 72(%rbp), %rax
	pushq %rax
	movq 64(%rbp), %rax
	popq %rcx
	imulq %rcx, %rax
	popq %rcx
	imulq %rcx, %rax
	pushq %rax
	movq -48(%rbp), %rax
	pushq %rax
	movq -40(%rbp), %rax
	pushq %rax
	movq -32(%rbp), %rax
	pushq %rax
	movq -24(%rbp), %rax
	pushq %rax
	movq -16(%rbp), %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	addq %rcx, %rax
	popq %rcx
	addq %rcx, %rax
	popq %rcx
	addq %rcx, %rax
	popq %rcx
	addq %rcx, %rax
	popq %rcx
	addq %rcx, %rax
	popq %rcx
	subq %rcx, %rax
	popq %rcx
	cmpq %rcx, %rax
	jl .test_args_successCmp_1979
	xorq %rax, %rax
	jmp .test_args_continueCmp_1980
.test_args_successCmp_1979:
	movq $1, %rax
.test_args_continueCmp_1980:
	jmp .test_args_endFunction_1938 	# return reached : end function
.test_args_endFunction_1938:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl test_args_2
 test_args_2:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	pushq %rdi	# saving argument number 1 on the stack
	pushq %rsi	# saving argument number 2 on the stack
	pushq %rdx	# saving argument number 3 on the stack
	pushq %rcx	# saving argument number 4 on the stack
	pushq %r8	# saving argument number 5 on the stack
	pushq %r9	# saving argument number 6 on the stack
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -8(%rbp), %rax
	pushq %rax
	movq $5, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_args_2_successCmp_1982
	xorq %rax, %rax
	jmp .test_args_2_continueCmp_1983
.test_args_2_successCmp_1982:
	movq $1, %rax
.test_args_2_continueCmp_1983:
	cmpq $0, %rax
	je .test_args_2_failureIf_1985
	movq $.string_1782, %rax
	jmp .test_args_2_endIf_1984
.test_args_2_failureIf_1985:
	movq $.string_1783, %rax
.test_args_2_endIf_1984:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_166, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -8(%rbp), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $5, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_169, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -16(%rbp), %rax
	pushq %rax
	movq $8937, %rax
	neg %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_args_2_successCmp_1986
	xorq %rax, %rax
	jmp .test_args_2_continueCmp_1987
.test_args_2_successCmp_1986:
	movq $1, %rax
.test_args_2_continueCmp_1987:
	cmpq $0, %rax
	je .test_args_2_failureIf_1989
	movq $.string_1782, %rax
	jmp .test_args_2_endIf_1988
.test_args_2_failureIf_1989:
	movq $.string_1783, %rax
.test_args_2_endIf_1988:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_171, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -16(%rbp), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $8937, %rax
	neg %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_174, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -24(%rbp), %rax
	pushq %rax
	movq $1483542, %rax
	neg %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_args_2_successCmp_1990
	xorq %rax, %rax
	jmp .test_args_2_continueCmp_1991
.test_args_2_successCmp_1990:
	movq $1, %rax
.test_args_2_continueCmp_1991:
	cmpq $0, %rax
	je .test_args_2_failureIf_1993
	movq $.string_1782, %rax
	jmp .test_args_2_endIf_1992
.test_args_2_failureIf_1993:
	movq $.string_1783, %rax
.test_args_2_endIf_1992:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_176, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -24(%rbp), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $1483542, %rax
	neg %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_179, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -32(%rbp), %rax
	pushq %rax
	movq $8938, %rax
	neg %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_args_2_successCmp_1994
	xorq %rax, %rax
	jmp .test_args_2_continueCmp_1995
.test_args_2_successCmp_1994:
	movq $1, %rax
.test_args_2_continueCmp_1995:
	cmpq $0, %rax
	je .test_args_2_failureIf_1997
	movq $.string_1782, %rax
	jmp .test_args_2_endIf_1996
.test_args_2_failureIf_1997:
	movq $.string_1783, %rax
.test_args_2_endIf_1996:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_181, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -32(%rbp), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $8938, %rax
	neg %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_184, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -40(%rbp), %rax
	pushq %rax
	movq $1547, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_args_2_successCmp_1998
	xorq %rax, %rax
	jmp .test_args_2_continueCmp_1999
.test_args_2_successCmp_1998:
	movq $1, %rax
.test_args_2_continueCmp_1999:
	cmpq $0, %rax
	je .test_args_2_failureIf_2001
	movq $.string_1782, %rax
	jmp .test_args_2_endIf_2000
.test_args_2_failureIf_2001:
	movq $.string_1783, %rax
.test_args_2_endIf_2000:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_186, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -40(%rbp), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $1547, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_189, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -48(%rbp), %rax
	pushq %rax
	movq $12, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_args_2_successCmp_2002
	xorq %rax, %rax
	jmp .test_args_2_continueCmp_2003
.test_args_2_successCmp_2002:
	movq $1, %rax
.test_args_2_continueCmp_2003:
	cmpq $0, %rax
	je .test_args_2_failureIf_2005
	movq $.string_1782, %rax
	jmp .test_args_2_endIf_2004
.test_args_2_failureIf_2005:
	movq $.string_1783, %rax
.test_args_2_endIf_2004:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_191, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -48(%rbp), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $12, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_194, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq 56(%rbp), %rax
	pushq %rax
	movq $589, %rax
	neg %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_args_2_successCmp_2006
	xorq %rax, %rax
	jmp .test_args_2_continueCmp_2007
.test_args_2_successCmp_2006:
	movq $1, %rax
.test_args_2_continueCmp_2007:
	cmpq $0, %rax
	je .test_args_2_failureIf_2009
	movq $.string_1782, %rax
	jmp .test_args_2_endIf_2008
.test_args_2_failureIf_2009:
	movq $.string_1783, %rax
.test_args_2_endIf_2008:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_196, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq 56(%rbp), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $589, %rax
	neg %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_199, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq 64(%rbp), %rax
	pushq %rax
	movq $166, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_args_2_successCmp_2010
	xorq %rax, %rax
	jmp .test_args_2_continueCmp_2011
.test_args_2_successCmp_2010:
	movq $1, %rax
.test_args_2_continueCmp_2011:
	cmpq $0, %rax
	je .test_args_2_failureIf_2013
	movq $.string_1782, %rax
	jmp .test_args_2_endIf_2012
.test_args_2_failureIf_2013:
	movq $.string_1783, %rax
.test_args_2_endIf_2012:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_201, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq 64(%rbp), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $166, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_204, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq 72(%rbp), %rax
	pushq %rax
	movq $8937, %rax
	neg %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_args_2_successCmp_2014
	xorq %rax, %rax
	jmp .test_args_2_continueCmp_2015
.test_args_2_successCmp_2014:
	movq $1, %rax
.test_args_2_continueCmp_2015:
	cmpq $0, %rax
	je .test_args_2_failureIf_2017
	movq $.string_1782, %rax
	jmp .test_args_2_endIf_2016
.test_args_2_failureIf_2017:
	movq $.string_1783, %rax
.test_args_2_endIf_2016:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_206, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq 72(%rbp), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $8937, %rax
	neg %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_209, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq 80(%rbp), %rax
	pushq %rax
	movq $5, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_args_2_successCmp_2018
	xorq %rax, %rax
	jmp .test_args_2_continueCmp_2019
.test_args_2_successCmp_2018:
	movq $1, %rax
.test_args_2_continueCmp_2019:
	cmpq $0, %rax
	je .test_args_2_failureIf_2021
	movq $.string_1782, %rax
	jmp .test_args_2_endIf_2020
.test_args_2_failureIf_2021:
	movq $.string_1783, %rax
.test_args_2_endIf_2020:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_211, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq 80(%rbp), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $5, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_214, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq 88(%rbp), %rax
	pushq %rax
	movq $2, %rax
	neg %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_args_2_successCmp_2022
	xorq %rax, %rax
	jmp .test_args_2_continueCmp_2023
.test_args_2_successCmp_2022:
	movq $1, %rax
.test_args_2_continueCmp_2023:
	cmpq $0, %rax
	je .test_args_2_failureIf_2025
	movq $.string_1782, %rax
	jmp .test_args_2_endIf_2024
.test_args_2_failureIf_2025:
	movq $.string_1783, %rax
.test_args_2_endIf_2024:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_216, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq 88(%rbp), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $2, %rax
	neg %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_219, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	movq $0, %rax
	pushq %rax
	movq 80(%rbp), %rax
	pushq %rax
	movq 72(%rbp), %rax
	pushq %rax
	movq 64(%rbp), %rax
	popq %rcx
	imulq %rcx, %rax
	popq %rcx
	imulq %rcx, %rax
	pushq %rax
	movq -48(%rbp), %rax
	pushq %rax
	movq -40(%rbp), %rax
	pushq %rax
	movq -32(%rbp), %rax
	pushq %rax
	movq -24(%rbp), %rax
	pushq %rax
	movq -16(%rbp), %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	addq %rcx, %rax
	popq %rcx
	addq %rcx, %rax
	popq %rcx
	addq %rcx, %rax
	popq %rcx
	addq %rcx, %rax
	popq %rcx
	addq %rcx, %rax
	popq %rcx
	subq %rcx, %rax
	popq %rcx
	cmpq %rcx, %rax
	jl .test_args_2_successCmp_2026
	xorq %rax, %rax
	jmp .test_args_2_continueCmp_2027
.test_args_2_successCmp_2026:
	movq $1, %rax
.test_args_2_continueCmp_2027:
	jmp .test_args_2_endFunction_1981 	# return reached : end function
.test_args_2_endFunction_1981:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl test_tabs
 test_tabs:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	pushq %rdi	# saving argument number 1 on the stack
	subq $16, %rsp
	movq $0, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2029
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2030
.test_tabs_successCmp_2029:
	movq $1, %rax
.test_tabs_continueCmp_2030:
	cmpq $0, %rax
	je .test_tabs_failureIf_2032
	movq $0, %rax
	jmp .test_tabs_endIf_2031
.test_tabs_failureIf_2032:
	movq $1, %rax
.test_tabs_endIf_2031:
	cmpq $0, %rax
	je .test_tabs_failureIf_2034
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -8(%rbp), %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq free
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	jmp .test_tabs_endIf_2033
.test_tabs_failureIf_2034:
.test_tabs_endIf_2033:
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $100, %rax
	pushq %rax
	movq $8, %rax
	popq %rcx
	imulq %rcx, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq malloc
	popq %r10	# retrieve caller-saved registers
	popq %r11
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $100, %rax
	pushq %rax
	movq $8, %rax
	popq %rcx
	imulq %rcx, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq malloc
	popq %r10	# retrieve caller-saved registers
	popq %r11
	movq %rax, global_5
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $100, %rax
	pushq %rax
	movq $8, %rax
	popq %rcx
	imulq %rcx, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq malloc
	popq %r10	# retrieve caller-saved registers
	popq %r11
	movq %rax, global_6
	movq $0, %rax
	movq %rax, -16(%rbp)
.test_tabs_loopWhile_2036:
	movq $100, %rax
	pushq %rax
	movq -16(%rbp), %rax
	popq %rcx
	cmpq %rcx, %rax
	jl .test_tabs_successCmp_2037
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2038
.test_tabs_successCmp_2037:
	movq $1, %rax
.test_tabs_continueCmp_2038:
	cmpq $0, %rax
	je .test_tabs_endWhile_2035
	movq $0, %rax
	pushq %rax
	movq -16(%rbp), %rax
	popq %rcx
	movq -8(%rbp), %rdx
	movq %rcx, (%rdx, %rax, 8)
	movq %rcx, %rax
	movq -16(%rbp), %rax
	pushq %rax
	movq -16(%rbp), %rax
	popq %rcx
	movq global_5, %rdx
	movq %rcx, (%rdx, %rax, 8)
	movq %rcx, %rax
	movq -16(%rbp), %rax
	movq global_5, %rdx
	movq (%rdx, %rax, 8), %rcx
	pushq %rcx	# the value of expr is stored in for later
	inc %rcx
	movq %rcx, (%rdx, %rax, 8)
	movq %rcx, %rax
	popq %rax
	pushq %rax
	movq global_4, %rax
	dec %rax
	movq %rax, global_4
	pushq %rax
	movq global_3, %rax
	pushq %rax	# the value of expr is stored in for later
	inc %rax
	movq %rax, global_3
	popq %rax
	popq %rcx
	addq %rcx, %rax
	popq %rcx
	addq %rcx, %rax
	pushq %rax
	movq -16(%rbp), %rax
	popq %rcx
	movq global_6, %rdx
	movq %rcx, (%rdx, %rax, 8)
	movq %rcx, %rax
	movq -16(%rbp), %rax
	pushq %rax	# the value of expr is stored in for later
	inc %rax
	movq %rax, -16(%rbp)
	popq %rax
	jmp .test_tabs_loopWhile_2036
.test_tabs_endWhile_2035:
	movq $1, %rax
	movq %rax, -16(%rbp)
.test_tabs_loopWhile_2040:
	movq $100, %rax
	pushq %rax
	movq -16(%rbp), %rax
	popq %rcx
	cmpq %rcx, %rax
	jl .test_tabs_successCmp_2041
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2042
.test_tabs_successCmp_2041:
	movq $1, %rax
.test_tabs_continueCmp_2042:
	cmpq $0, %rax
	je .test_tabs_endWhile_2039
	movq $2, %rax
	pushq %rax
	movq -16(%rbp), %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq -16(%rbp), %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $1, %rax
	pushq %rax
	movq -16(%rbp), %rax
	popq %rcx
	subq %rcx, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $1, %rax
	pushq %rax
	movq -16(%rbp), %rax
	popq %rcx
	subq %rcx, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	popq %rcx
	addq %rcx, %rax
	popq %rcx
	imulq %rcx, %rax
	pushq %rax
	movq -16(%rbp), %rax
	popq %rcx
	movq -8(%rbp), %rdx
	movq %rcx, (%rdx, %rax, 8)
	movq %rcx, %rax
	movq $9, %rax
	pushq %rax
	movq $1, %rax
	pushq %rax
	movq -16(%rbp), %rax
	popq %rcx
	subq %rcx, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $1, %rax
	pushq %rax
	movq -16(%rbp), %rax
	popq %rcx
	subq %rcx, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq -16(%rbp), %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq -16(%rbp), %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	popq %rcx
	imulq %rcx, %rax
	popq %rcx
	xorq %rdx, %rdx
	cqo
	idivq %rcx
	movq %rdx, %rax
	pushq %rax
	movq -16(%rbp), %rax
	popq %rcx
	movq global_5, %rdx
	movq %rcx, (%rdx, %rax, 8)
	movq %rcx, %rax
	movq -16(%rbp), %rax
	pushq %rax	# the value of expr is stored in for later
	inc %rax
	movq %rax, -16(%rbp)
	popq %rax
	jmp .test_tabs_loopWhile_2040
.test_tabs_endWhile_2039:
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $0, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $0, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $0, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2043
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2044
.test_tabs_successCmp_2043:
	movq $1, %rax
.test_tabs_continueCmp_2044:
	cmpq $0, %rax
	je .test_tabs_failureIf_2046
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2045
.test_tabs_failureIf_2046:
	movq $.string_1783, %rax
.test_tabs_endIf_2045:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_221, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $0, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $0, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $0, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_224, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $1, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $1, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $2, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2047
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2048
.test_tabs_successCmp_2047:
	movq $1, %rax
.test_tabs_continueCmp_2048:
	cmpq $0, %rax
	je .test_tabs_failureIf_2050
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2049
.test_tabs_failureIf_2050:
	movq $.string_1783, %rax
.test_tabs_endIf_2049:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_226, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $1, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $1, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $2, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_229, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $2, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $2, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $2, %rax
	neg %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2051
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2052
.test_tabs_successCmp_2051:
	movq $1, %rax
.test_tabs_continueCmp_2052:
	cmpq $0, %rax
	je .test_tabs_failureIf_2054
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2053
.test_tabs_failureIf_2054:
	movq $.string_1783, %rax
.test_tabs_endIf_2053:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_231, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $2, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $2, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $2, %rax
	neg %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_234, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $3, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $3, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $4, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2055
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2056
.test_tabs_successCmp_2055:
	movq $1, %rax
.test_tabs_continueCmp_2056:
	cmpq $0, %rax
	je .test_tabs_failureIf_2058
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2057
.test_tabs_failureIf_2058:
	movq $.string_1783, %rax
.test_tabs_endIf_2057:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_236, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $3, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $3, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $4, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_239, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $4, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $4, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $14, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2059
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2060
.test_tabs_successCmp_2059:
	movq $1, %rax
.test_tabs_continueCmp_2060:
	cmpq $0, %rax
	je .test_tabs_failureIf_2062
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2061
.test_tabs_failureIf_2062:
	movq $.string_1783, %rax
.test_tabs_endIf_2061:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_241, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $4, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $4, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $14, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_244, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $5, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $5, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $10, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2063
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2064
.test_tabs_successCmp_2063:
	movq $1, %rax
.test_tabs_continueCmp_2064:
	cmpq $0, %rax
	je .test_tabs_failureIf_2066
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2065
.test_tabs_failureIf_2066:
	movq $.string_1783, %rax
.test_tabs_endIf_2065:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_246, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $5, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $5, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $10, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_249, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $6, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $6, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $10, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2067
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2068
.test_tabs_successCmp_2067:
	movq $1, %rax
.test_tabs_continueCmp_2068:
	cmpq $0, %rax
	je .test_tabs_failureIf_2070
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2069
.test_tabs_failureIf_2070:
	movq $.string_1783, %rax
.test_tabs_endIf_2069:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_251, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $6, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $6, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $10, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_254, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $7, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $7, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $14, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2071
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2072
.test_tabs_successCmp_2071:
	movq $1, %rax
.test_tabs_continueCmp_2072:
	cmpq $0, %rax
	je .test_tabs_failureIf_2074
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2073
.test_tabs_failureIf_2074:
	movq $.string_1783, %rax
.test_tabs_endIf_2073:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_256, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $7, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $7, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $14, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_259, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $8, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $8, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $22, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2075
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2076
.test_tabs_successCmp_2075:
	movq $1, %rax
.test_tabs_continueCmp_2076:
	cmpq $0, %rax
	je .test_tabs_failureIf_2078
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2077
.test_tabs_failureIf_2078:
	movq $.string_1783, %rax
.test_tabs_endIf_2077:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_261, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $8, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $8, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $22, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_264, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $9, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $9, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $16, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2079
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2080
.test_tabs_successCmp_2079:
	movq $1, %rax
.test_tabs_continueCmp_2080:
	cmpq $0, %rax
	je .test_tabs_failureIf_2082
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2081
.test_tabs_failureIf_2082:
	movq $.string_1783, %rax
.test_tabs_endIf_2081:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_266, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $9, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $9, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $16, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_269, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $10, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $10, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $32, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2083
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2084
.test_tabs_successCmp_2083:
	movq $1, %rax
.test_tabs_continueCmp_2084:
	cmpq $0, %rax
	je .test_tabs_failureIf_2086
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2085
.test_tabs_failureIf_2086:
	movq $.string_1783, %rax
.test_tabs_endIf_2085:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_271, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $10, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $10, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $32, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_274, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $11, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $11, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $34, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2087
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2088
.test_tabs_successCmp_2087:
	movq $1, %rax
.test_tabs_continueCmp_2088:
	cmpq $0, %rax
	je .test_tabs_failureIf_2090
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2089
.test_tabs_failureIf_2090:
	movq $.string_1783, %rax
.test_tabs_endIf_2089:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_276, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $11, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $11, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $34, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_279, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $12, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $12, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $22, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2091
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2092
.test_tabs_successCmp_2091:
	movq $1, %rax
.test_tabs_continueCmp_2092:
	cmpq $0, %rax
	je .test_tabs_failureIf_2094
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2093
.test_tabs_failureIf_2094:
	movq $.string_1783, %rax
.test_tabs_endIf_2093:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_281, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $12, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $12, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $22, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_284, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $13, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $13, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $32, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2095
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2096
.test_tabs_successCmp_2095:
	movq $1, %rax
.test_tabs_continueCmp_2096:
	cmpq $0, %rax
	je .test_tabs_failureIf_2098
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2097
.test_tabs_failureIf_2098:
	movq $.string_1783, %rax
.test_tabs_endIf_2097:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_286, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $13, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $13, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $32, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_289, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $14, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $14, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $28, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2099
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2100
.test_tabs_successCmp_2099:
	movq $1, %rax
.test_tabs_continueCmp_2100:
	cmpq $0, %rax
	je .test_tabs_failureIf_2102
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2101
.test_tabs_failureIf_2102:
	movq $.string_1783, %rax
.test_tabs_endIf_2101:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_291, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $14, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $14, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $28, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_294, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $15, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $15, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $28, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2103
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2104
.test_tabs_successCmp_2103:
	movq $1, %rax
.test_tabs_continueCmp_2104:
	cmpq $0, %rax
	je .test_tabs_failureIf_2106
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2105
.test_tabs_failureIf_2106:
	movq $.string_1783, %rax
.test_tabs_endIf_2105:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_296, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $15, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $15, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $28, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_299, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $16, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $16, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $32, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2107
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2108
.test_tabs_successCmp_2107:
	movq $1, %rax
.test_tabs_continueCmp_2108:
	cmpq $0, %rax
	je .test_tabs_failureIf_2110
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2109
.test_tabs_failureIf_2110:
	movq $.string_1783, %rax
.test_tabs_endIf_2109:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_301, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $16, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $16, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $32, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_304, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $17, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $17, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $40, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2111
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2112
.test_tabs_successCmp_2111:
	movq $1, %rax
.test_tabs_continueCmp_2112:
	cmpq $0, %rax
	je .test_tabs_failureIf_2114
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2113
.test_tabs_failureIf_2114:
	movq $.string_1783, %rax
.test_tabs_endIf_2113:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_306, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $17, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $17, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $40, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_309, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $18, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $18, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $34, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2115
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2116
.test_tabs_successCmp_2115:
	movq $1, %rax
.test_tabs_continueCmp_2116:
	cmpq $0, %rax
	je .test_tabs_failureIf_2118
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2117
.test_tabs_failureIf_2118:
	movq $.string_1783, %rax
.test_tabs_endIf_2117:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_311, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $18, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $18, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $34, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_314, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $19, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $19, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $50, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2119
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2120
.test_tabs_successCmp_2119:
	movq $1, %rax
.test_tabs_continueCmp_2120:
	cmpq $0, %rax
	je .test_tabs_failureIf_2122
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2121
.test_tabs_failureIf_2122:
	movq $.string_1783, %rax
.test_tabs_endIf_2121:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_316, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $19, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $19, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $50, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_319, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $20, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $20, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $52, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2123
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2124
.test_tabs_successCmp_2123:
	movq $1, %rax
.test_tabs_continueCmp_2124:
	cmpq $0, %rax
	je .test_tabs_failureIf_2126
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2125
.test_tabs_failureIf_2126:
	movq $.string_1783, %rax
.test_tabs_endIf_2125:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_321, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $20, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $20, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $52, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_324, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $21, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $21, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $40, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2127
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2128
.test_tabs_successCmp_2127:
	movq $1, %rax
.test_tabs_continueCmp_2128:
	cmpq $0, %rax
	je .test_tabs_failureIf_2130
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2129
.test_tabs_failureIf_2130:
	movq $.string_1783, %rax
.test_tabs_endIf_2129:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_326, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $21, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $21, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $40, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_329, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $22, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $22, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $50, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2131
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2132
.test_tabs_successCmp_2131:
	movq $1, %rax
.test_tabs_continueCmp_2132:
	cmpq $0, %rax
	je .test_tabs_failureIf_2134
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2133
.test_tabs_failureIf_2134:
	movq $.string_1783, %rax
.test_tabs_endIf_2133:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_331, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $22, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $22, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $50, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_334, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $23, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $23, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $46, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2135
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2136
.test_tabs_successCmp_2135:
	movq $1, %rax
.test_tabs_continueCmp_2136:
	cmpq $0, %rax
	je .test_tabs_failureIf_2138
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2137
.test_tabs_failureIf_2138:
	movq $.string_1783, %rax
.test_tabs_endIf_2137:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_336, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $23, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $23, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $46, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_339, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $24, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $24, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $46, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2139
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2140
.test_tabs_successCmp_2139:
	movq $1, %rax
.test_tabs_continueCmp_2140:
	cmpq $0, %rax
	je .test_tabs_failureIf_2142
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2141
.test_tabs_failureIf_2142:
	movq $.string_1783, %rax
.test_tabs_endIf_2141:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_341, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $24, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $24, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $46, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_344, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $25, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $25, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $50, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2143
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2144
.test_tabs_successCmp_2143:
	movq $1, %rax
.test_tabs_continueCmp_2144:
	cmpq $0, %rax
	je .test_tabs_failureIf_2146
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2145
.test_tabs_failureIf_2146:
	movq $.string_1783, %rax
.test_tabs_endIf_2145:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_346, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $25, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $25, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $50, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_349, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $26, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $26, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $58, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2147
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2148
.test_tabs_successCmp_2147:
	movq $1, %rax
.test_tabs_continueCmp_2148:
	cmpq $0, %rax
	je .test_tabs_failureIf_2150
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2149
.test_tabs_failureIf_2150:
	movq $.string_1783, %rax
.test_tabs_endIf_2149:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_351, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $26, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $26, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $58, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_354, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $27, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $27, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $52, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2151
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2152
.test_tabs_successCmp_2151:
	movq $1, %rax
.test_tabs_continueCmp_2152:
	cmpq $0, %rax
	je .test_tabs_failureIf_2154
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2153
.test_tabs_failureIf_2154:
	movq $.string_1783, %rax
.test_tabs_endIf_2153:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_356, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $27, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $27, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $52, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_359, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $28, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $28, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $68, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2155
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2156
.test_tabs_successCmp_2155:
	movq $1, %rax
.test_tabs_continueCmp_2156:
	cmpq $0, %rax
	je .test_tabs_failureIf_2158
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2157
.test_tabs_failureIf_2158:
	movq $.string_1783, %rax
.test_tabs_endIf_2157:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_361, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $28, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $28, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $68, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_364, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $29, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $29, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $70, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2159
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2160
.test_tabs_successCmp_2159:
	movq $1, %rax
.test_tabs_continueCmp_2160:
	cmpq $0, %rax
	je .test_tabs_failureIf_2162
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2161
.test_tabs_failureIf_2162:
	movq $.string_1783, %rax
.test_tabs_endIf_2161:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_366, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $29, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $29, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $70, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_369, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $30, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $30, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $58, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2163
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2164
.test_tabs_successCmp_2163:
	movq $1, %rax
.test_tabs_continueCmp_2164:
	cmpq $0, %rax
	je .test_tabs_failureIf_2166
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2165
.test_tabs_failureIf_2166:
	movq $.string_1783, %rax
.test_tabs_endIf_2165:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_371, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $30, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $30, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $58, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_374, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $31, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $31, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $68, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2167
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2168
.test_tabs_successCmp_2167:
	movq $1, %rax
.test_tabs_continueCmp_2168:
	cmpq $0, %rax
	je .test_tabs_failureIf_2170
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2169
.test_tabs_failureIf_2170:
	movq $.string_1783, %rax
.test_tabs_endIf_2169:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_376, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $31, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $31, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $68, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_379, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $32, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $32, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $64, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2171
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2172
.test_tabs_successCmp_2171:
	movq $1, %rax
.test_tabs_continueCmp_2172:
	cmpq $0, %rax
	je .test_tabs_failureIf_2174
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2173
.test_tabs_failureIf_2174:
	movq $.string_1783, %rax
.test_tabs_endIf_2173:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_381, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $32, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $32, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $64, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_384, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $33, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $33, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $64, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2175
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2176
.test_tabs_successCmp_2175:
	movq $1, %rax
.test_tabs_continueCmp_2176:
	cmpq $0, %rax
	je .test_tabs_failureIf_2178
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2177
.test_tabs_failureIf_2178:
	movq $.string_1783, %rax
.test_tabs_endIf_2177:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_386, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $33, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $33, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $64, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_389, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $34, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $34, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $68, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2179
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2180
.test_tabs_successCmp_2179:
	movq $1, %rax
.test_tabs_continueCmp_2180:
	cmpq $0, %rax
	je .test_tabs_failureIf_2182
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2181
.test_tabs_failureIf_2182:
	movq $.string_1783, %rax
.test_tabs_endIf_2181:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_391, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $34, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $34, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $68, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_394, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $35, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $35, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $76, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2183
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2184
.test_tabs_successCmp_2183:
	movq $1, %rax
.test_tabs_continueCmp_2184:
	cmpq $0, %rax
	je .test_tabs_failureIf_2186
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2185
.test_tabs_failureIf_2186:
	movq $.string_1783, %rax
.test_tabs_endIf_2185:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_396, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $35, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $35, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $76, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_399, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $36, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $36, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $70, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2187
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2188
.test_tabs_successCmp_2187:
	movq $1, %rax
.test_tabs_continueCmp_2188:
	cmpq $0, %rax
	je .test_tabs_failureIf_2190
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2189
.test_tabs_failureIf_2190:
	movq $.string_1783, %rax
.test_tabs_endIf_2189:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_401, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $36, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $36, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $70, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_404, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $37, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $37, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $86, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2191
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2192
.test_tabs_successCmp_2191:
	movq $1, %rax
.test_tabs_continueCmp_2192:
	cmpq $0, %rax
	je .test_tabs_failureIf_2194
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2193
.test_tabs_failureIf_2194:
	movq $.string_1783, %rax
.test_tabs_endIf_2193:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_406, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $37, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $37, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $86, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_409, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $38, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $38, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $88, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2195
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2196
.test_tabs_successCmp_2195:
	movq $1, %rax
.test_tabs_continueCmp_2196:
	cmpq $0, %rax
	je .test_tabs_failureIf_2198
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2197
.test_tabs_failureIf_2198:
	movq $.string_1783, %rax
.test_tabs_endIf_2197:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_411, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $38, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $38, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $88, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_414, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $39, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $39, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $76, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2199
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2200
.test_tabs_successCmp_2199:
	movq $1, %rax
.test_tabs_continueCmp_2200:
	cmpq $0, %rax
	je .test_tabs_failureIf_2202
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2201
.test_tabs_failureIf_2202:
	movq $.string_1783, %rax
.test_tabs_endIf_2201:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_416, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $39, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $39, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $76, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_419, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $40, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $40, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $86, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2203
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2204
.test_tabs_successCmp_2203:
	movq $1, %rax
.test_tabs_continueCmp_2204:
	cmpq $0, %rax
	je .test_tabs_failureIf_2206
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2205
.test_tabs_failureIf_2206:
	movq $.string_1783, %rax
.test_tabs_endIf_2205:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_421, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $40, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $40, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $86, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_424, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $41, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $41, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $82, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2207
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2208
.test_tabs_successCmp_2207:
	movq $1, %rax
.test_tabs_continueCmp_2208:
	cmpq $0, %rax
	je .test_tabs_failureIf_2210
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2209
.test_tabs_failureIf_2210:
	movq $.string_1783, %rax
.test_tabs_endIf_2209:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_426, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $41, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $41, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $82, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_429, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $42, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $42, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $82, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2211
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2212
.test_tabs_successCmp_2211:
	movq $1, %rax
.test_tabs_continueCmp_2212:
	cmpq $0, %rax
	je .test_tabs_failureIf_2214
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2213
.test_tabs_failureIf_2214:
	movq $.string_1783, %rax
.test_tabs_endIf_2213:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_431, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $42, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $42, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $82, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_434, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $43, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $43, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $86, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2215
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2216
.test_tabs_successCmp_2215:
	movq $1, %rax
.test_tabs_continueCmp_2216:
	cmpq $0, %rax
	je .test_tabs_failureIf_2218
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2217
.test_tabs_failureIf_2218:
	movq $.string_1783, %rax
.test_tabs_endIf_2217:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_436, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $43, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $43, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $86, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_439, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $44, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $44, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $94, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2219
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2220
.test_tabs_successCmp_2219:
	movq $1, %rax
.test_tabs_continueCmp_2220:
	cmpq $0, %rax
	je .test_tabs_failureIf_2222
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2221
.test_tabs_failureIf_2222:
	movq $.string_1783, %rax
.test_tabs_endIf_2221:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_441, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $44, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $44, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $94, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_444, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $45, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $45, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $88, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2223
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2224
.test_tabs_successCmp_2223:
	movq $1, %rax
.test_tabs_continueCmp_2224:
	cmpq $0, %rax
	je .test_tabs_failureIf_2226
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2225
.test_tabs_failureIf_2226:
	movq $.string_1783, %rax
.test_tabs_endIf_2225:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_446, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $45, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $45, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $88, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_449, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $46, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $46, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $104, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2227
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2228
.test_tabs_successCmp_2227:
	movq $1, %rax
.test_tabs_continueCmp_2228:
	cmpq $0, %rax
	je .test_tabs_failureIf_2230
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2229
.test_tabs_failureIf_2230:
	movq $.string_1783, %rax
.test_tabs_endIf_2229:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_451, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $46, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $46, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $104, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_454, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $47, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $47, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $106, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2231
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2232
.test_tabs_successCmp_2231:
	movq $1, %rax
.test_tabs_continueCmp_2232:
	cmpq $0, %rax
	je .test_tabs_failureIf_2234
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2233
.test_tabs_failureIf_2234:
	movq $.string_1783, %rax
.test_tabs_endIf_2233:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_456, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $47, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $47, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $106, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_459, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $48, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $48, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $94, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2235
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2236
.test_tabs_successCmp_2235:
	movq $1, %rax
.test_tabs_continueCmp_2236:
	cmpq $0, %rax
	je .test_tabs_failureIf_2238
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2237
.test_tabs_failureIf_2238:
	movq $.string_1783, %rax
.test_tabs_endIf_2237:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_461, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $48, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $48, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $94, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_464, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $49, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $49, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $104, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2239
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2240
.test_tabs_successCmp_2239:
	movq $1, %rax
.test_tabs_continueCmp_2240:
	cmpq $0, %rax
	je .test_tabs_failureIf_2242
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2241
.test_tabs_failureIf_2242:
	movq $.string_1783, %rax
.test_tabs_endIf_2241:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_466, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $49, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $49, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $104, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_469, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $50, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $50, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $100, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2243
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2244
.test_tabs_successCmp_2243:
	movq $1, %rax
.test_tabs_continueCmp_2244:
	cmpq $0, %rax
	je .test_tabs_failureIf_2246
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2245
.test_tabs_failureIf_2246:
	movq $.string_1783, %rax
.test_tabs_endIf_2245:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_471, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $50, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $50, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $100, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_474, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $51, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $51, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $100, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2247
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2248
.test_tabs_successCmp_2247:
	movq $1, %rax
.test_tabs_continueCmp_2248:
	cmpq $0, %rax
	je .test_tabs_failureIf_2250
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2249
.test_tabs_failureIf_2250:
	movq $.string_1783, %rax
.test_tabs_endIf_2249:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_476, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $51, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $51, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $100, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_479, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $52, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $52, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $104, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2251
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2252
.test_tabs_successCmp_2251:
	movq $1, %rax
.test_tabs_continueCmp_2252:
	cmpq $0, %rax
	je .test_tabs_failureIf_2254
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2253
.test_tabs_failureIf_2254:
	movq $.string_1783, %rax
.test_tabs_endIf_2253:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_481, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $52, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $52, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $104, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_484, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $53, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $53, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $112, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2255
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2256
.test_tabs_successCmp_2255:
	movq $1, %rax
.test_tabs_continueCmp_2256:
	cmpq $0, %rax
	je .test_tabs_failureIf_2258
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2257
.test_tabs_failureIf_2258:
	movq $.string_1783, %rax
.test_tabs_endIf_2257:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_486, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $53, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $53, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $112, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_489, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $54, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $54, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $106, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2259
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2260
.test_tabs_successCmp_2259:
	movq $1, %rax
.test_tabs_continueCmp_2260:
	cmpq $0, %rax
	je .test_tabs_failureIf_2262
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2261
.test_tabs_failureIf_2262:
	movq $.string_1783, %rax
.test_tabs_endIf_2261:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_491, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $54, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $54, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $106, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_494, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $55, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $55, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $122, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2263
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2264
.test_tabs_successCmp_2263:
	movq $1, %rax
.test_tabs_continueCmp_2264:
	cmpq $0, %rax
	je .test_tabs_failureIf_2266
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2265
.test_tabs_failureIf_2266:
	movq $.string_1783, %rax
.test_tabs_endIf_2265:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_496, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $55, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $55, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $122, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_499, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $56, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $56, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $124, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2267
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2268
.test_tabs_successCmp_2267:
	movq $1, %rax
.test_tabs_continueCmp_2268:
	cmpq $0, %rax
	je .test_tabs_failureIf_2270
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2269
.test_tabs_failureIf_2270:
	movq $.string_1783, %rax
.test_tabs_endIf_2269:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_501, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $56, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $56, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $124, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_504, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $57, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $57, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $112, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2271
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2272
.test_tabs_successCmp_2271:
	movq $1, %rax
.test_tabs_continueCmp_2272:
	cmpq $0, %rax
	je .test_tabs_failureIf_2274
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2273
.test_tabs_failureIf_2274:
	movq $.string_1783, %rax
.test_tabs_endIf_2273:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_506, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $57, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $57, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $112, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_509, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $58, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $58, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $122, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2275
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2276
.test_tabs_successCmp_2275:
	movq $1, %rax
.test_tabs_continueCmp_2276:
	cmpq $0, %rax
	je .test_tabs_failureIf_2278
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2277
.test_tabs_failureIf_2278:
	movq $.string_1783, %rax
.test_tabs_endIf_2277:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_511, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $58, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $58, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $122, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_514, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $59, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $59, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $118, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2279
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2280
.test_tabs_successCmp_2279:
	movq $1, %rax
.test_tabs_continueCmp_2280:
	cmpq $0, %rax
	je .test_tabs_failureIf_2282
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2281
.test_tabs_failureIf_2282:
	movq $.string_1783, %rax
.test_tabs_endIf_2281:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_516, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $59, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $59, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $118, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_519, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $60, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $60, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $118, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2283
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2284
.test_tabs_successCmp_2283:
	movq $1, %rax
.test_tabs_continueCmp_2284:
	cmpq $0, %rax
	je .test_tabs_failureIf_2286
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2285
.test_tabs_failureIf_2286:
	movq $.string_1783, %rax
.test_tabs_endIf_2285:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_521, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $60, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $60, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $118, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_524, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $61, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $61, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $122, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2287
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2288
.test_tabs_successCmp_2287:
	movq $1, %rax
.test_tabs_continueCmp_2288:
	cmpq $0, %rax
	je .test_tabs_failureIf_2290
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2289
.test_tabs_failureIf_2290:
	movq $.string_1783, %rax
.test_tabs_endIf_2289:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_526, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $61, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $61, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $122, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_529, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $62, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $62, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $130, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2291
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2292
.test_tabs_successCmp_2291:
	movq $1, %rax
.test_tabs_continueCmp_2292:
	cmpq $0, %rax
	je .test_tabs_failureIf_2294
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2293
.test_tabs_failureIf_2294:
	movq $.string_1783, %rax
.test_tabs_endIf_2293:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_531, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $62, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $62, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $130, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_534, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $63, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $63, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $124, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2295
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2296
.test_tabs_successCmp_2295:
	movq $1, %rax
.test_tabs_continueCmp_2296:
	cmpq $0, %rax
	je .test_tabs_failureIf_2298
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2297
.test_tabs_failureIf_2298:
	movq $.string_1783, %rax
.test_tabs_endIf_2297:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_536, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $63, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $63, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $124, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_539, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $64, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $64, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $140, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2299
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2300
.test_tabs_successCmp_2299:
	movq $1, %rax
.test_tabs_continueCmp_2300:
	cmpq $0, %rax
	je .test_tabs_failureIf_2302
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2301
.test_tabs_failureIf_2302:
	movq $.string_1783, %rax
.test_tabs_endIf_2301:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_541, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $64, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $64, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $140, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_544, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $65, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $65, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $142, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2303
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2304
.test_tabs_successCmp_2303:
	movq $1, %rax
.test_tabs_continueCmp_2304:
	cmpq $0, %rax
	je .test_tabs_failureIf_2306
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2305
.test_tabs_failureIf_2306:
	movq $.string_1783, %rax
.test_tabs_endIf_2305:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_546, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $65, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $65, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $142, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_549, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $66, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $66, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $130, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2307
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2308
.test_tabs_successCmp_2307:
	movq $1, %rax
.test_tabs_continueCmp_2308:
	cmpq $0, %rax
	je .test_tabs_failureIf_2310
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2309
.test_tabs_failureIf_2310:
	movq $.string_1783, %rax
.test_tabs_endIf_2309:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_551, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $66, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $66, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $130, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_554, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $67, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $67, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $140, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2311
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2312
.test_tabs_successCmp_2311:
	movq $1, %rax
.test_tabs_continueCmp_2312:
	cmpq $0, %rax
	je .test_tabs_failureIf_2314
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2313
.test_tabs_failureIf_2314:
	movq $.string_1783, %rax
.test_tabs_endIf_2313:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_556, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $67, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $67, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $140, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_559, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $68, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $68, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $136, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2315
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2316
.test_tabs_successCmp_2315:
	movq $1, %rax
.test_tabs_continueCmp_2316:
	cmpq $0, %rax
	je .test_tabs_failureIf_2318
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2317
.test_tabs_failureIf_2318:
	movq $.string_1783, %rax
.test_tabs_endIf_2317:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_561, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $68, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $68, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $136, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_564, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $69, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $69, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $136, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2319
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2320
.test_tabs_successCmp_2319:
	movq $1, %rax
.test_tabs_continueCmp_2320:
	cmpq $0, %rax
	je .test_tabs_failureIf_2322
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2321
.test_tabs_failureIf_2322:
	movq $.string_1783, %rax
.test_tabs_endIf_2321:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_566, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $69, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $69, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $136, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_569, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $70, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $70, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $140, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2323
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2324
.test_tabs_successCmp_2323:
	movq $1, %rax
.test_tabs_continueCmp_2324:
	cmpq $0, %rax
	je .test_tabs_failureIf_2326
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2325
.test_tabs_failureIf_2326:
	movq $.string_1783, %rax
.test_tabs_endIf_2325:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_571, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $70, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $70, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $140, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_574, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $71, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $71, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $148, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2327
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2328
.test_tabs_successCmp_2327:
	movq $1, %rax
.test_tabs_continueCmp_2328:
	cmpq $0, %rax
	je .test_tabs_failureIf_2330
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2329
.test_tabs_failureIf_2330:
	movq $.string_1783, %rax
.test_tabs_endIf_2329:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_576, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $71, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $71, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $148, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_579, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $72, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $72, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $142, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2331
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2332
.test_tabs_successCmp_2331:
	movq $1, %rax
.test_tabs_continueCmp_2332:
	cmpq $0, %rax
	je .test_tabs_failureIf_2334
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2333
.test_tabs_failureIf_2334:
	movq $.string_1783, %rax
.test_tabs_endIf_2333:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_581, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $72, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $72, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $142, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_584, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $73, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $73, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $158, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2335
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2336
.test_tabs_successCmp_2335:
	movq $1, %rax
.test_tabs_continueCmp_2336:
	cmpq $0, %rax
	je .test_tabs_failureIf_2338
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2337
.test_tabs_failureIf_2338:
	movq $.string_1783, %rax
.test_tabs_endIf_2337:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_586, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $73, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $73, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $158, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_589, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $74, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $74, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $160, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2339
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2340
.test_tabs_successCmp_2339:
	movq $1, %rax
.test_tabs_continueCmp_2340:
	cmpq $0, %rax
	je .test_tabs_failureIf_2342
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2341
.test_tabs_failureIf_2342:
	movq $.string_1783, %rax
.test_tabs_endIf_2341:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_591, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $74, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $74, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $160, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_594, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $75, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $75, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $148, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2343
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2344
.test_tabs_successCmp_2343:
	movq $1, %rax
.test_tabs_continueCmp_2344:
	cmpq $0, %rax
	je .test_tabs_failureIf_2346
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2345
.test_tabs_failureIf_2346:
	movq $.string_1783, %rax
.test_tabs_endIf_2345:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_596, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $75, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $75, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $148, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_599, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $76, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $76, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $158, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2347
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2348
.test_tabs_successCmp_2347:
	movq $1, %rax
.test_tabs_continueCmp_2348:
	cmpq $0, %rax
	je .test_tabs_failureIf_2350
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2349
.test_tabs_failureIf_2350:
	movq $.string_1783, %rax
.test_tabs_endIf_2349:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_601, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $76, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $76, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $158, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_604, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $77, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $77, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $154, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2351
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2352
.test_tabs_successCmp_2351:
	movq $1, %rax
.test_tabs_continueCmp_2352:
	cmpq $0, %rax
	je .test_tabs_failureIf_2354
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2353
.test_tabs_failureIf_2354:
	movq $.string_1783, %rax
.test_tabs_endIf_2353:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_606, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $77, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $77, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $154, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_609, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $78, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $78, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $154, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2355
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2356
.test_tabs_successCmp_2355:
	movq $1, %rax
.test_tabs_continueCmp_2356:
	cmpq $0, %rax
	je .test_tabs_failureIf_2358
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2357
.test_tabs_failureIf_2358:
	movq $.string_1783, %rax
.test_tabs_endIf_2357:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_611, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $78, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $78, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $154, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_614, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $79, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $79, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $158, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2359
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2360
.test_tabs_successCmp_2359:
	movq $1, %rax
.test_tabs_continueCmp_2360:
	cmpq $0, %rax
	je .test_tabs_failureIf_2362
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2361
.test_tabs_failureIf_2362:
	movq $.string_1783, %rax
.test_tabs_endIf_2361:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_616, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $79, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $79, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $158, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_619, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $80, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $80, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $166, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2363
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2364
.test_tabs_successCmp_2363:
	movq $1, %rax
.test_tabs_continueCmp_2364:
	cmpq $0, %rax
	je .test_tabs_failureIf_2366
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2365
.test_tabs_failureIf_2366:
	movq $.string_1783, %rax
.test_tabs_endIf_2365:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_621, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $80, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $80, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $166, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_624, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $81, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $81, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $160, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2367
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2368
.test_tabs_successCmp_2367:
	movq $1, %rax
.test_tabs_continueCmp_2368:
	cmpq $0, %rax
	je .test_tabs_failureIf_2370
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2369
.test_tabs_failureIf_2370:
	movq $.string_1783, %rax
.test_tabs_endIf_2369:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_626, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $81, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $81, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $160, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_629, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $82, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $82, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $176, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2371
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2372
.test_tabs_successCmp_2371:
	movq $1, %rax
.test_tabs_continueCmp_2372:
	cmpq $0, %rax
	je .test_tabs_failureIf_2374
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2373
.test_tabs_failureIf_2374:
	movq $.string_1783, %rax
.test_tabs_endIf_2373:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_631, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $82, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $82, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $176, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_634, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $83, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $83, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $178, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2375
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2376
.test_tabs_successCmp_2375:
	movq $1, %rax
.test_tabs_continueCmp_2376:
	cmpq $0, %rax
	je .test_tabs_failureIf_2378
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2377
.test_tabs_failureIf_2378:
	movq $.string_1783, %rax
.test_tabs_endIf_2377:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_636, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $83, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $83, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $178, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_639, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $84, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $84, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $166, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2379
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2380
.test_tabs_successCmp_2379:
	movq $1, %rax
.test_tabs_continueCmp_2380:
	cmpq $0, %rax
	je .test_tabs_failureIf_2382
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2381
.test_tabs_failureIf_2382:
	movq $.string_1783, %rax
.test_tabs_endIf_2381:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_641, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $84, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $84, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $166, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_644, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $85, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $85, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $176, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2383
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2384
.test_tabs_successCmp_2383:
	movq $1, %rax
.test_tabs_continueCmp_2384:
	cmpq $0, %rax
	je .test_tabs_failureIf_2386
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2385
.test_tabs_failureIf_2386:
	movq $.string_1783, %rax
.test_tabs_endIf_2385:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_646, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $85, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $85, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $176, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_649, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $86, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $86, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $172, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2387
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2388
.test_tabs_successCmp_2387:
	movq $1, %rax
.test_tabs_continueCmp_2388:
	cmpq $0, %rax
	je .test_tabs_failureIf_2390
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2389
.test_tabs_failureIf_2390:
	movq $.string_1783, %rax
.test_tabs_endIf_2389:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_651, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $86, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $86, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $172, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_654, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $87, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $87, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $172, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2391
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2392
.test_tabs_successCmp_2391:
	movq $1, %rax
.test_tabs_continueCmp_2392:
	cmpq $0, %rax
	je .test_tabs_failureIf_2394
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2393
.test_tabs_failureIf_2394:
	movq $.string_1783, %rax
.test_tabs_endIf_2393:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_656, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $87, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $87, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $172, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_659, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $88, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $88, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $176, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2395
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2396
.test_tabs_successCmp_2395:
	movq $1, %rax
.test_tabs_continueCmp_2396:
	cmpq $0, %rax
	je .test_tabs_failureIf_2398
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2397
.test_tabs_failureIf_2398:
	movq $.string_1783, %rax
.test_tabs_endIf_2397:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_661, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $88, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $88, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $176, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_664, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $89, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $89, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $184, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2399
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2400
.test_tabs_successCmp_2399:
	movq $1, %rax
.test_tabs_continueCmp_2400:
	cmpq $0, %rax
	je .test_tabs_failureIf_2402
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2401
.test_tabs_failureIf_2402:
	movq $.string_1783, %rax
.test_tabs_endIf_2401:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_666, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $89, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $89, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $184, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_669, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $90, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $90, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $178, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2403
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2404
.test_tabs_successCmp_2403:
	movq $1, %rax
.test_tabs_continueCmp_2404:
	cmpq $0, %rax
	je .test_tabs_failureIf_2406
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2405
.test_tabs_failureIf_2406:
	movq $.string_1783, %rax
.test_tabs_endIf_2405:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_671, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $90, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $90, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $178, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_674, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $91, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $91, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $194, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2407
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2408
.test_tabs_successCmp_2407:
	movq $1, %rax
.test_tabs_continueCmp_2408:
	cmpq $0, %rax
	je .test_tabs_failureIf_2410
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2409
.test_tabs_failureIf_2410:
	movq $.string_1783, %rax
.test_tabs_endIf_2409:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_676, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $91, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $91, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $194, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_679, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $92, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $92, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $196, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2411
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2412
.test_tabs_successCmp_2411:
	movq $1, %rax
.test_tabs_continueCmp_2412:
	cmpq $0, %rax
	je .test_tabs_failureIf_2414
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2413
.test_tabs_failureIf_2414:
	movq $.string_1783, %rax
.test_tabs_endIf_2413:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_681, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $92, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $92, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $196, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_684, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $93, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $93, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $184, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2415
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2416
.test_tabs_successCmp_2415:
	movq $1, %rax
.test_tabs_continueCmp_2416:
	cmpq $0, %rax
	je .test_tabs_failureIf_2418
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2417
.test_tabs_failureIf_2418:
	movq $.string_1783, %rax
.test_tabs_endIf_2417:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_686, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $93, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $93, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $184, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_689, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $94, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $94, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $194, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2419
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2420
.test_tabs_successCmp_2419:
	movq $1, %rax
.test_tabs_continueCmp_2420:
	cmpq $0, %rax
	je .test_tabs_failureIf_2422
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2421
.test_tabs_failureIf_2422:
	movq $.string_1783, %rax
.test_tabs_endIf_2421:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_691, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $94, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $94, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $194, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_694, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $95, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $95, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $190, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2423
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2424
.test_tabs_successCmp_2423:
	movq $1, %rax
.test_tabs_continueCmp_2424:
	cmpq $0, %rax
	je .test_tabs_failureIf_2426
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2425
.test_tabs_failureIf_2426:
	movq $.string_1783, %rax
.test_tabs_endIf_2425:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_696, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $95, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $95, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $190, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_699, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $96, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $96, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $190, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2427
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2428
.test_tabs_successCmp_2427:
	movq $1, %rax
.test_tabs_continueCmp_2428:
	cmpq $0, %rax
	je .test_tabs_failureIf_2430
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2429
.test_tabs_failureIf_2430:
	movq $.string_1783, %rax
.test_tabs_endIf_2429:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_701, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $96, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $96, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $190, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_704, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $97, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $97, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $194, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2431
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2432
.test_tabs_successCmp_2431:
	movq $1, %rax
.test_tabs_continueCmp_2432:
	cmpq $0, %rax
	je .test_tabs_failureIf_2434
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2433
.test_tabs_failureIf_2434:
	movq $.string_1783, %rax
.test_tabs_endIf_2433:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_706, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $97, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $97, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $194, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_709, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $98, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $98, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $202, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2435
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2436
.test_tabs_successCmp_2435:
	movq $1, %rax
.test_tabs_continueCmp_2436:
	cmpq $0, %rax
	je .test_tabs_failureIf_2438
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2437
.test_tabs_failureIf_2438:
	movq $.string_1783, %rax
.test_tabs_endIf_2437:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_711, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $98, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $98, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $202, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_714, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $99, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $99, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $196, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_tabs_successCmp_2439
	xorq %rax, %rax
	jmp .test_tabs_continueCmp_2440
.test_tabs_successCmp_2439:
	movq $1, %rax
.test_tabs_continueCmp_2440:
	cmpq $0, %rax
	je .test_tabs_failureIf_2442
	movq $.string_1782, %rax
	jmp .test_tabs_endIf_2441
.test_tabs_failureIf_2442:
	movq $.string_1783, %rax
.test_tabs_endIf_2441:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_716, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $99, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $99, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $196, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_719, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $8, %rax
	pushq %rax
	movq $3, %rax
	popq %rcx
	imulq %rcx, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq malloc
	popq %r10	# retrieve caller-saved registers
	popq %r11
	movq %rax, -24(%rbp)
	movq $1, %rax
	pushq %rax
	movq $10, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $10, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $51, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $51, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	popq %rcx
	imulq %rcx, %rax
	pushq %rax
	movq global_1, %rax
	popq %rcx
	addq %rcx, %rax
	popq %rcx
	subq %rcx, %rax
	pushq %rax
	movq $0, %rax
	popq %rcx
	movq -24(%rbp), %rdx
	movq %rcx, (%rdx, %rax, 8)
	movq %rcx, %rax
	movq $4, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	movq $4, %rax
	movq %rax, %rcx
	movq -8(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $1, %rax
	popq %rcx
	movq -24(%rbp), %rdx
	movq %rcx, (%rdx, %rax, 8)
	movq %rcx, %rax
	movq $98, %rax
	pushq %rax
	movq $1, %rax
	pushq %rax
	movq -24(%rbp), %rax
	popq %rcx
	movq $1, %rax
	movq %rax, %rcx
	movq -24(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $0, %rax
	pushq %rax
	movq -24(%rbp), %rax
	popq %rcx
	movq $0, %rax
	movq %rax, %rcx
	movq -24(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	popq %rcx
	imulq %rcx, %rax
	popq %rcx
	xorq %rdx, %rdx
	cqo
	idivq %rcx
	movq %rdx, %rax
	pushq %rax
	movq $2, %rax
	popq %rcx
	movq -24(%rbp), %rdx
	movq %rcx, (%rdx, %rax, 8)
	movq %rcx, %rax
	movq -24(%rbp), %rax
	jmp .test_tabs_endFunction_2028 	# return reached : end function
	addq $16, %rsp
.test_tabs_endFunction_2028:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl verify_global
 verify_global:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq global_1, %rax
	pushq %rax
	movq $0, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2444
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2445
.verify_global_successCmp_2444:
	movq $1, %rax
.verify_global_continueCmp_2445:
	cmpq $0, %rax
	je .verify_global_failureIf_2447
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2446
.verify_global_failureIf_2447:
	movq $.string_1783, %rax
.verify_global_endIf_2446:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_721, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq global_1, %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $0, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_724, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq global_2, %rax
	pushq %rax
	movq $45, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2448
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2449
.verify_global_successCmp_2448:
	movq $1, %rax
.verify_global_continueCmp_2449:
	cmpq $0, %rax
	je .verify_global_failureIf_2451
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2450
.verify_global_failureIf_2451:
	movq $.string_1783, %rax
.verify_global_endIf_2450:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_726, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq global_2, %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $45, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_729, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq global_3, %rax
	pushq %rax
	movq $55, %rax
	neg %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2452
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2453
.verify_global_successCmp_2452:
	movq $1, %rax
.verify_global_continueCmp_2453:
	cmpq $0, %rax
	je .verify_global_failureIf_2455
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2454
.verify_global_failureIf_2455:
	movq $.string_1783, %rax
.verify_global_endIf_2454:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_731, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq global_3, %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $55, %rax
	neg %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_734, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq global_4, %rax
	pushq %rax
	movq $52, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2456
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2457
.verify_global_successCmp_2456:
	movq $1, %rax
.verify_global_continueCmp_2457:
	cmpq $0, %rax
	je .verify_global_failureIf_2459
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2458
.verify_global_failureIf_2459:
	movq $.string_1783, %rax
.verify_global_endIf_2458:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_736, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq global_4, %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $52, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_739, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $0, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $0, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $1, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2460
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2461
.verify_global_successCmp_2460:
	movq $1, %rax
.verify_global_continueCmp_2461:
	cmpq $0, %rax
	je .verify_global_failureIf_2463
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2462
.verify_global_failureIf_2463:
	movq $.string_1783, %rax
.verify_global_endIf_2462:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_741, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $0, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $0, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $1, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_744, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $0, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $0, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $1, %rax
	neg %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2464
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2465
.verify_global_successCmp_2464:
	movq $1, %rax
.verify_global_continueCmp_2465:
	cmpq $0, %rax
	je .verify_global_failureIf_2467
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2466
.verify_global_failureIf_2467:
	movq $.string_1783, %rax
.verify_global_endIf_2466:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_746, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $0, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $0, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $1, %rax
	neg %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_749, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $1, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $1, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $2, %rax
	neg %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2468
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2469
.verify_global_successCmp_2468:
	movq $1, %rax
.verify_global_continueCmp_2469:
	cmpq $0, %rax
	je .verify_global_failureIf_2471
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2470
.verify_global_failureIf_2471:
	movq $.string_1783, %rax
.verify_global_endIf_2470:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_751, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $1, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $1, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $2, %rax
	neg %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_754, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $1, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $1, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $0, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2472
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2473
.verify_global_successCmp_2472:
	movq $1, %rax
.verify_global_continueCmp_2473:
	cmpq $0, %rax
	je .verify_global_failureIf_2475
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2474
.verify_global_failureIf_2475:
	movq $.string_1783, %rax
.verify_global_endIf_2474:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_756, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $1, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $1, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $0, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_759, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $2, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $2, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $0, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2476
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2477
.verify_global_successCmp_2476:
	movq $1, %rax
.verify_global_continueCmp_2477:
	cmpq $0, %rax
	je .verify_global_failureIf_2479
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2478
.verify_global_failureIf_2479:
	movq $.string_1783, %rax
.verify_global_endIf_2478:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_761, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $2, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $2, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $0, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_764, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $2, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $2, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $1, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2480
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2481
.verify_global_successCmp_2480:
	movq $1, %rax
.verify_global_continueCmp_2481:
	cmpq $0, %rax
	je .verify_global_failureIf_2483
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2482
.verify_global_failureIf_2483:
	movq $.string_1783, %rax
.verify_global_endIf_2482:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_766, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $2, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $2, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $1, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_769, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $3, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $3, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $4, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2484
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2485
.verify_global_successCmp_2484:
	movq $1, %rax
.verify_global_continueCmp_2485:
	cmpq $0, %rax
	je .verify_global_failureIf_2487
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2486
.verify_global_failureIf_2487:
	movq $.string_1783, %rax
.verify_global_endIf_2486:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_771, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $3, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $3, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $4, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_774, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $3, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $3, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $2, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2488
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2489
.verify_global_successCmp_2488:
	movq $1, %rax
.verify_global_continueCmp_2489:
	cmpq $0, %rax
	je .verify_global_failureIf_2491
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2490
.verify_global_failureIf_2491:
	movq $.string_1783, %rax
.verify_global_endIf_2490:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_776, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $3, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $3, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $2, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_779, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $4, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $4, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $1, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2492
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2493
.verify_global_successCmp_2492:
	movq $1, %rax
.verify_global_continueCmp_2493:
	cmpq $0, %rax
	je .verify_global_failureIf_2495
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2494
.verify_global_failureIf_2495:
	movq $.string_1783, %rax
.verify_global_endIf_2494:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_781, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $4, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $4, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $1, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_784, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $4, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $4, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $3, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2496
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2497
.verify_global_successCmp_2496:
	movq $1, %rax
.verify_global_continueCmp_2497:
	cmpq $0, %rax
	je .verify_global_failureIf_2499
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2498
.verify_global_failureIf_2499:
	movq $.string_1783, %rax
.verify_global_endIf_2498:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_786, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $4, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $4, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $3, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_789, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $5, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $5, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $0, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2500
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2501
.verify_global_successCmp_2500:
	movq $1, %rax
.verify_global_continueCmp_2501:
	cmpq $0, %rax
	je .verify_global_failureIf_2503
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2502
.verify_global_failureIf_2503:
	movq $.string_1783, %rax
.verify_global_endIf_2502:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_791, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $5, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $5, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $0, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_794, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $5, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $5, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $4, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2504
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2505
.verify_global_successCmp_2504:
	movq $1, %rax
.verify_global_continueCmp_2505:
	cmpq $0, %rax
	je .verify_global_failureIf_2507
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2506
.verify_global_failureIf_2507:
	movq $.string_1783, %rax
.verify_global_endIf_2506:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_796, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $5, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $5, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $4, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_799, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $6, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $6, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $1, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2508
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2509
.verify_global_successCmp_2508:
	movq $1, %rax
.verify_global_continueCmp_2509:
	cmpq $0, %rax
	je .verify_global_failureIf_2511
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2510
.verify_global_failureIf_2511:
	movq $.string_1783, %rax
.verify_global_endIf_2510:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_801, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $6, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $6, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $1, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_804, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $6, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $6, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $5, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2512
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2513
.verify_global_successCmp_2512:
	movq $1, %rax
.verify_global_continueCmp_2513:
	cmpq $0, %rax
	je .verify_global_failureIf_2515
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2514
.verify_global_failureIf_2515:
	movq $.string_1783, %rax
.verify_global_endIf_2514:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_806, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $6, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $6, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $5, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_809, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $7, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $7, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $4, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2516
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2517
.verify_global_successCmp_2516:
	movq $1, %rax
.verify_global_continueCmp_2517:
	cmpq $0, %rax
	je .verify_global_failureIf_2519
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2518
.verify_global_failureIf_2519:
	movq $.string_1783, %rax
.verify_global_endIf_2518:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_811, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $7, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $7, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $4, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_814, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $7, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $7, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $6, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2520
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2521
.verify_global_successCmp_2520:
	movq $1, %rax
.verify_global_continueCmp_2521:
	cmpq $0, %rax
	je .verify_global_failureIf_2523
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2522
.verify_global_failureIf_2523:
	movq $.string_1783, %rax
.verify_global_endIf_2522:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_816, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $7, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $7, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $6, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_819, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $8, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $8, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $0, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2524
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2525
.verify_global_successCmp_2524:
	movq $1, %rax
.verify_global_continueCmp_2525:
	cmpq $0, %rax
	je .verify_global_failureIf_2527
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2526
.verify_global_failureIf_2527:
	movq $.string_1783, %rax
.verify_global_endIf_2526:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_821, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $8, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $8, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $0, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_824, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $8, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $8, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $7, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2528
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2529
.verify_global_successCmp_2528:
	movq $1, %rax
.verify_global_continueCmp_2529:
	cmpq $0, %rax
	je .verify_global_failureIf_2531
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2530
.verify_global_failureIf_2531:
	movq $.string_1783, %rax
.verify_global_endIf_2530:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_826, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $8, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $8, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $7, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_829, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $9, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $9, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $7, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2532
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2533
.verify_global_successCmp_2532:
	movq $1, %rax
.verify_global_continueCmp_2533:
	cmpq $0, %rax
	je .verify_global_failureIf_2535
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2534
.verify_global_failureIf_2535:
	movq $.string_1783, %rax
.verify_global_endIf_2534:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_831, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $9, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $9, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $7, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_834, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $9, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $9, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $8, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2536
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2537
.verify_global_successCmp_2536:
	movq $1, %rax
.verify_global_continueCmp_2537:
	cmpq $0, %rax
	je .verify_global_failureIf_2539
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2538
.verify_global_failureIf_2539:
	movq $.string_1783, %rax
.verify_global_endIf_2538:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_836, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $9, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $9, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $8, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_839, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $10, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $10, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $7, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2540
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2541
.verify_global_successCmp_2540:
	movq $1, %rax
.verify_global_continueCmp_2541:
	cmpq $0, %rax
	je .verify_global_failureIf_2543
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2542
.verify_global_failureIf_2543:
	movq $.string_1783, %rax
.verify_global_endIf_2542:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_841, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $10, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $10, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $7, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_844, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $10, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $10, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $9, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2544
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2545
.verify_global_successCmp_2544:
	movq $1, %rax
.verify_global_continueCmp_2545:
	cmpq $0, %rax
	je .verify_global_failureIf_2547
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2546
.verify_global_failureIf_2547:
	movq $.string_1783, %rax
.verify_global_endIf_2546:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_846, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $10, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $10, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $9, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_849, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $11, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $11, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $0, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2548
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2549
.verify_global_successCmp_2548:
	movq $1, %rax
.verify_global_continueCmp_2549:
	cmpq $0, %rax
	je .verify_global_failureIf_2551
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2550
.verify_global_failureIf_2551:
	movq $.string_1783, %rax
.verify_global_endIf_2550:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_851, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $11, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $11, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $0, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_854, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $11, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $11, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $10, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2552
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2553
.verify_global_successCmp_2552:
	movq $1, %rax
.verify_global_continueCmp_2553:
	cmpq $0, %rax
	je .verify_global_failureIf_2555
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2554
.verify_global_failureIf_2555:
	movq $.string_1783, %rax
.verify_global_endIf_2554:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_856, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $11, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $11, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $10, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_859, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $12, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $12, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $4, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2556
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2557
.verify_global_successCmp_2556:
	movq $1, %rax
.verify_global_continueCmp_2557:
	cmpq $0, %rax
	je .verify_global_failureIf_2559
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2558
.verify_global_failureIf_2559:
	movq $.string_1783, %rax
.verify_global_endIf_2558:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_861, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $12, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $12, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $4, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_864, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $12, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $12, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $11, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2560
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2561
.verify_global_successCmp_2560:
	movq $1, %rax
.verify_global_continueCmp_2561:
	cmpq $0, %rax
	je .verify_global_failureIf_2563
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2562
.verify_global_failureIf_2563:
	movq $.string_1783, %rax
.verify_global_endIf_2562:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_866, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $12, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $12, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $11, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_869, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $13, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $13, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $1, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2564
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2565
.verify_global_successCmp_2564:
	movq $1, %rax
.verify_global_continueCmp_2565:
	cmpq $0, %rax
	je .verify_global_failureIf_2567
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2566
.verify_global_failureIf_2567:
	movq $.string_1783, %rax
.verify_global_endIf_2566:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_871, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $13, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $13, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $1, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_874, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $13, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $13, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $12, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2568
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2569
.verify_global_successCmp_2568:
	movq $1, %rax
.verify_global_continueCmp_2569:
	cmpq $0, %rax
	je .verify_global_failureIf_2571
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2570
.verify_global_failureIf_2571:
	movq $.string_1783, %rax
.verify_global_endIf_2570:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_876, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $13, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $13, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $12, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_879, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $14, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $14, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $0, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2572
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2573
.verify_global_successCmp_2572:
	movq $1, %rax
.verify_global_continueCmp_2573:
	cmpq $0, %rax
	je .verify_global_failureIf_2575
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2574
.verify_global_failureIf_2575:
	movq $.string_1783, %rax
.verify_global_endIf_2574:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_881, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $14, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $14, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $0, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_884, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $14, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $14, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $13, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2576
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2577
.verify_global_successCmp_2576:
	movq $1, %rax
.verify_global_continueCmp_2577:
	cmpq $0, %rax
	je .verify_global_failureIf_2579
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2578
.verify_global_failureIf_2579:
	movq $.string_1783, %rax
.verify_global_endIf_2578:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_886, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $14, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $14, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $13, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_889, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $15, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $15, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $1, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2580
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2581
.verify_global_successCmp_2580:
	movq $1, %rax
.verify_global_continueCmp_2581:
	cmpq $0, %rax
	je .verify_global_failureIf_2583
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2582
.verify_global_failureIf_2583:
	movq $.string_1783, %rax
.verify_global_endIf_2582:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_891, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $15, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $15, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $1, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_894, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $15, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $15, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $14, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2584
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2585
.verify_global_successCmp_2584:
	movq $1, %rax
.verify_global_continueCmp_2585:
	cmpq $0, %rax
	je .verify_global_failureIf_2587
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2586
.verify_global_failureIf_2587:
	movq $.string_1783, %rax
.verify_global_endIf_2586:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_896, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $15, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $15, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $14, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_899, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $16, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $16, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $4, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2588
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2589
.verify_global_successCmp_2588:
	movq $1, %rax
.verify_global_continueCmp_2589:
	cmpq $0, %rax
	je .verify_global_failureIf_2591
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2590
.verify_global_failureIf_2591:
	movq $.string_1783, %rax
.verify_global_endIf_2590:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_901, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $16, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $16, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $4, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_904, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $16, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $16, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $15, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2592
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2593
.verify_global_successCmp_2592:
	movq $1, %rax
.verify_global_continueCmp_2593:
	cmpq $0, %rax
	je .verify_global_failureIf_2595
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2594
.verify_global_failureIf_2595:
	movq $.string_1783, %rax
.verify_global_endIf_2594:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_906, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $16, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $16, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $15, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_909, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $17, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $17, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $0, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2596
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2597
.verify_global_successCmp_2596:
	movq $1, %rax
.verify_global_continueCmp_2597:
	cmpq $0, %rax
	je .verify_global_failureIf_2599
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2598
.verify_global_failureIf_2599:
	movq $.string_1783, %rax
.verify_global_endIf_2598:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_911, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $17, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $17, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $0, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_914, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $17, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $17, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $16, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2600
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2601
.verify_global_successCmp_2600:
	movq $1, %rax
.verify_global_continueCmp_2601:
	cmpq $0, %rax
	je .verify_global_failureIf_2603
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2602
.verify_global_failureIf_2603:
	movq $.string_1783, %rax
.verify_global_endIf_2602:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_916, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $17, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $17, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $16, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_919, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $18, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $18, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $7, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2604
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2605
.verify_global_successCmp_2604:
	movq $1, %rax
.verify_global_continueCmp_2605:
	cmpq $0, %rax
	je .verify_global_failureIf_2607
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2606
.verify_global_failureIf_2607:
	movq $.string_1783, %rax
.verify_global_endIf_2606:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_921, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $18, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $18, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $7, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_924, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $18, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $18, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $17, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2608
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2609
.verify_global_successCmp_2608:
	movq $1, %rax
.verify_global_continueCmp_2609:
	cmpq $0, %rax
	je .verify_global_failureIf_2611
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2610
.verify_global_failureIf_2611:
	movq $.string_1783, %rax
.verify_global_endIf_2610:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_926, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $18, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $18, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $17, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_929, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $19, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $19, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $7, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2612
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2613
.verify_global_successCmp_2612:
	movq $1, %rax
.verify_global_continueCmp_2613:
	cmpq $0, %rax
	je .verify_global_failureIf_2615
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2614
.verify_global_failureIf_2615:
	movq $.string_1783, %rax
.verify_global_endIf_2614:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_931, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $19, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $19, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $7, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_934, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $19, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $19, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $18, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2616
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2617
.verify_global_successCmp_2616:
	movq $1, %rax
.verify_global_continueCmp_2617:
	cmpq $0, %rax
	je .verify_global_failureIf_2619
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2618
.verify_global_failureIf_2619:
	movq $.string_1783, %rax
.verify_global_endIf_2618:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_936, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $19, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $19, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $18, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_939, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $20, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $20, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $0, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2620
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2621
.verify_global_successCmp_2620:
	movq $1, %rax
.verify_global_continueCmp_2621:
	cmpq $0, %rax
	je .verify_global_failureIf_2623
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2622
.verify_global_failureIf_2623:
	movq $.string_1783, %rax
.verify_global_endIf_2622:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_941, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $20, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $20, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $0, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_944, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $20, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $20, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $19, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2624
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2625
.verify_global_successCmp_2624:
	movq $1, %rax
.verify_global_continueCmp_2625:
	cmpq $0, %rax
	je .verify_global_failureIf_2627
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2626
.verify_global_failureIf_2627:
	movq $.string_1783, %rax
.verify_global_endIf_2626:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_946, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $20, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $20, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $19, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_949, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $21, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $21, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $4, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2628
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2629
.verify_global_successCmp_2628:
	movq $1, %rax
.verify_global_continueCmp_2629:
	cmpq $0, %rax
	je .verify_global_failureIf_2631
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2630
.verify_global_failureIf_2631:
	movq $.string_1783, %rax
.verify_global_endIf_2630:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_951, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $21, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $21, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $4, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_954, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $21, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $21, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $20, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2632
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2633
.verify_global_successCmp_2632:
	movq $1, %rax
.verify_global_continueCmp_2633:
	cmpq $0, %rax
	je .verify_global_failureIf_2635
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2634
.verify_global_failureIf_2635:
	movq $.string_1783, %rax
.verify_global_endIf_2634:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_956, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $21, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $21, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $20, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_959, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $22, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $22, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $1, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2636
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2637
.verify_global_successCmp_2636:
	movq $1, %rax
.verify_global_continueCmp_2637:
	cmpq $0, %rax
	je .verify_global_failureIf_2639
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2638
.verify_global_failureIf_2639:
	movq $.string_1783, %rax
.verify_global_endIf_2638:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_961, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $22, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $22, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $1, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_964, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $22, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $22, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $21, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2640
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2641
.verify_global_successCmp_2640:
	movq $1, %rax
.verify_global_continueCmp_2641:
	cmpq $0, %rax
	je .verify_global_failureIf_2643
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2642
.verify_global_failureIf_2643:
	movq $.string_1783, %rax
.verify_global_endIf_2642:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_966, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $22, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $22, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $21, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_969, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $23, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $23, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $0, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2644
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2645
.verify_global_successCmp_2644:
	movq $1, %rax
.verify_global_continueCmp_2645:
	cmpq $0, %rax
	je .verify_global_failureIf_2647
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2646
.verify_global_failureIf_2647:
	movq $.string_1783, %rax
.verify_global_endIf_2646:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_971, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $23, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $23, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $0, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_974, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $23, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $23, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $22, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2648
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2649
.verify_global_successCmp_2648:
	movq $1, %rax
.verify_global_continueCmp_2649:
	cmpq $0, %rax
	je .verify_global_failureIf_2651
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2650
.verify_global_failureIf_2651:
	movq $.string_1783, %rax
.verify_global_endIf_2650:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_976, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $23, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $23, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $22, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_979, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $24, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $24, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $1, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2652
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2653
.verify_global_successCmp_2652:
	movq $1, %rax
.verify_global_continueCmp_2653:
	cmpq $0, %rax
	je .verify_global_failureIf_2655
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2654
.verify_global_failureIf_2655:
	movq $.string_1783, %rax
.verify_global_endIf_2654:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_981, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $24, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $24, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $1, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_984, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $24, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $24, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $23, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2656
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2657
.verify_global_successCmp_2656:
	movq $1, %rax
.verify_global_continueCmp_2657:
	cmpq $0, %rax
	je .verify_global_failureIf_2659
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2658
.verify_global_failureIf_2659:
	movq $.string_1783, %rax
.verify_global_endIf_2658:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_986, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $24, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $24, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $23, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_989, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $25, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $25, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $4, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2660
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2661
.verify_global_successCmp_2660:
	movq $1, %rax
.verify_global_continueCmp_2661:
	cmpq $0, %rax
	je .verify_global_failureIf_2663
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2662
.verify_global_failureIf_2663:
	movq $.string_1783, %rax
.verify_global_endIf_2662:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_991, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $25, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $25, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $4, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_994, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $25, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $25, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $24, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2664
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2665
.verify_global_successCmp_2664:
	movq $1, %rax
.verify_global_continueCmp_2665:
	cmpq $0, %rax
	je .verify_global_failureIf_2667
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2666
.verify_global_failureIf_2667:
	movq $.string_1783, %rax
.verify_global_endIf_2666:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_996, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $25, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $25, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $24, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_999, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $26, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $26, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $0, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2668
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2669
.verify_global_successCmp_2668:
	movq $1, %rax
.verify_global_continueCmp_2669:
	cmpq $0, %rax
	je .verify_global_failureIf_2671
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2670
.verify_global_failureIf_2671:
	movq $.string_1783, %rax
.verify_global_endIf_2670:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1001, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $26, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $26, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $0, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1004, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $26, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $26, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $25, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2672
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2673
.verify_global_successCmp_2672:
	movq $1, %rax
.verify_global_continueCmp_2673:
	cmpq $0, %rax
	je .verify_global_failureIf_2675
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2674
.verify_global_failureIf_2675:
	movq $.string_1783, %rax
.verify_global_endIf_2674:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1006, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $26, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $26, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $25, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1009, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $27, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $27, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $7, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2676
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2677
.verify_global_successCmp_2676:
	movq $1, %rax
.verify_global_continueCmp_2677:
	cmpq $0, %rax
	je .verify_global_failureIf_2679
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2678
.verify_global_failureIf_2679:
	movq $.string_1783, %rax
.verify_global_endIf_2678:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1011, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $27, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $27, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $7, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1014, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $27, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $27, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $26, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2680
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2681
.verify_global_successCmp_2680:
	movq $1, %rax
.verify_global_continueCmp_2681:
	cmpq $0, %rax
	je .verify_global_failureIf_2683
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2682
.verify_global_failureIf_2683:
	movq $.string_1783, %rax
.verify_global_endIf_2682:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1016, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $27, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $27, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $26, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1019, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $28, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $28, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $7, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2684
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2685
.verify_global_successCmp_2684:
	movq $1, %rax
.verify_global_continueCmp_2685:
	cmpq $0, %rax
	je .verify_global_failureIf_2687
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2686
.verify_global_failureIf_2687:
	movq $.string_1783, %rax
.verify_global_endIf_2686:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1021, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $28, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $28, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $7, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1024, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $28, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $28, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $27, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2688
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2689
.verify_global_successCmp_2688:
	movq $1, %rax
.verify_global_continueCmp_2689:
	cmpq $0, %rax
	je .verify_global_failureIf_2691
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2690
.verify_global_failureIf_2691:
	movq $.string_1783, %rax
.verify_global_endIf_2690:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1026, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $28, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $28, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $27, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1029, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $29, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $29, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $0, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2692
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2693
.verify_global_successCmp_2692:
	movq $1, %rax
.verify_global_continueCmp_2693:
	cmpq $0, %rax
	je .verify_global_failureIf_2695
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2694
.verify_global_failureIf_2695:
	movq $.string_1783, %rax
.verify_global_endIf_2694:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1031, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $29, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $29, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $0, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1034, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $29, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $29, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $28, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2696
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2697
.verify_global_successCmp_2696:
	movq $1, %rax
.verify_global_continueCmp_2697:
	cmpq $0, %rax
	je .verify_global_failureIf_2699
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2698
.verify_global_failureIf_2699:
	movq $.string_1783, %rax
.verify_global_endIf_2698:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1036, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $29, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $29, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $28, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1039, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $30, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $30, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $4, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2700
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2701
.verify_global_successCmp_2700:
	movq $1, %rax
.verify_global_continueCmp_2701:
	cmpq $0, %rax
	je .verify_global_failureIf_2703
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2702
.verify_global_failureIf_2703:
	movq $.string_1783, %rax
.verify_global_endIf_2702:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1041, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $30, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $30, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $4, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1044, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $30, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $30, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $29, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2704
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2705
.verify_global_successCmp_2704:
	movq $1, %rax
.verify_global_continueCmp_2705:
	cmpq $0, %rax
	je .verify_global_failureIf_2707
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2706
.verify_global_failureIf_2707:
	movq $.string_1783, %rax
.verify_global_endIf_2706:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1046, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $30, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $30, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $29, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1049, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $31, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $31, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $1, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2708
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2709
.verify_global_successCmp_2708:
	movq $1, %rax
.verify_global_continueCmp_2709:
	cmpq $0, %rax
	je .verify_global_failureIf_2711
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2710
.verify_global_failureIf_2711:
	movq $.string_1783, %rax
.verify_global_endIf_2710:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1051, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $31, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $31, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $1, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1054, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $31, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $31, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $30, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2712
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2713
.verify_global_successCmp_2712:
	movq $1, %rax
.verify_global_continueCmp_2713:
	cmpq $0, %rax
	je .verify_global_failureIf_2715
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2714
.verify_global_failureIf_2715:
	movq $.string_1783, %rax
.verify_global_endIf_2714:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1056, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $31, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $31, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $30, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1059, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $32, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $32, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $0, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2716
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2717
.verify_global_successCmp_2716:
	movq $1, %rax
.verify_global_continueCmp_2717:
	cmpq $0, %rax
	je .verify_global_failureIf_2719
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2718
.verify_global_failureIf_2719:
	movq $.string_1783, %rax
.verify_global_endIf_2718:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1061, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $32, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $32, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $0, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1064, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $32, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $32, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $31, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2720
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2721
.verify_global_successCmp_2720:
	movq $1, %rax
.verify_global_continueCmp_2721:
	cmpq $0, %rax
	je .verify_global_failureIf_2723
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2722
.verify_global_failureIf_2723:
	movq $.string_1783, %rax
.verify_global_endIf_2722:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1066, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $32, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $32, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $31, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1069, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $33, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $33, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $1, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2724
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2725
.verify_global_successCmp_2724:
	movq $1, %rax
.verify_global_continueCmp_2725:
	cmpq $0, %rax
	je .verify_global_failureIf_2727
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2726
.verify_global_failureIf_2727:
	movq $.string_1783, %rax
.verify_global_endIf_2726:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1071, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $33, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $33, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $1, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1074, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $33, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $33, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $32, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2728
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2729
.verify_global_successCmp_2728:
	movq $1, %rax
.verify_global_continueCmp_2729:
	cmpq $0, %rax
	je .verify_global_failureIf_2731
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2730
.verify_global_failureIf_2731:
	movq $.string_1783, %rax
.verify_global_endIf_2730:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1076, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $33, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $33, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $32, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1079, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $34, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $34, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $4, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2732
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2733
.verify_global_successCmp_2732:
	movq $1, %rax
.verify_global_continueCmp_2733:
	cmpq $0, %rax
	je .verify_global_failureIf_2735
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2734
.verify_global_failureIf_2735:
	movq $.string_1783, %rax
.verify_global_endIf_2734:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1081, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $34, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $34, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $4, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1084, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $34, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $34, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $33, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2736
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2737
.verify_global_successCmp_2736:
	movq $1, %rax
.verify_global_continueCmp_2737:
	cmpq $0, %rax
	je .verify_global_failureIf_2739
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2738
.verify_global_failureIf_2739:
	movq $.string_1783, %rax
.verify_global_endIf_2738:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1086, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $34, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $34, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $33, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1089, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $35, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $35, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $0, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2740
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2741
.verify_global_successCmp_2740:
	movq $1, %rax
.verify_global_continueCmp_2741:
	cmpq $0, %rax
	je .verify_global_failureIf_2743
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2742
.verify_global_failureIf_2743:
	movq $.string_1783, %rax
.verify_global_endIf_2742:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1091, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $35, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $35, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $0, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1094, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $35, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $35, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $34, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2744
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2745
.verify_global_successCmp_2744:
	movq $1, %rax
.verify_global_continueCmp_2745:
	cmpq $0, %rax
	je .verify_global_failureIf_2747
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2746
.verify_global_failureIf_2747:
	movq $.string_1783, %rax
.verify_global_endIf_2746:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1096, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $35, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $35, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $34, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1099, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $36, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $36, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $7, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2748
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2749
.verify_global_successCmp_2748:
	movq $1, %rax
.verify_global_continueCmp_2749:
	cmpq $0, %rax
	je .verify_global_failureIf_2751
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2750
.verify_global_failureIf_2751:
	movq $.string_1783, %rax
.verify_global_endIf_2750:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1101, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $36, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $36, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $7, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1104, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $36, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $36, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $35, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2752
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2753
.verify_global_successCmp_2752:
	movq $1, %rax
.verify_global_continueCmp_2753:
	cmpq $0, %rax
	je .verify_global_failureIf_2755
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2754
.verify_global_failureIf_2755:
	movq $.string_1783, %rax
.verify_global_endIf_2754:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1106, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $36, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $36, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $35, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1109, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $37, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $37, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $7, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2756
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2757
.verify_global_successCmp_2756:
	movq $1, %rax
.verify_global_continueCmp_2757:
	cmpq $0, %rax
	je .verify_global_failureIf_2759
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2758
.verify_global_failureIf_2759:
	movq $.string_1783, %rax
.verify_global_endIf_2758:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1111, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $37, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $37, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $7, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1114, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $37, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $37, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $36, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2760
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2761
.verify_global_successCmp_2760:
	movq $1, %rax
.verify_global_continueCmp_2761:
	cmpq $0, %rax
	je .verify_global_failureIf_2763
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2762
.verify_global_failureIf_2763:
	movq $.string_1783, %rax
.verify_global_endIf_2762:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1116, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $37, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $37, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $36, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1119, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $38, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $38, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $0, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2764
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2765
.verify_global_successCmp_2764:
	movq $1, %rax
.verify_global_continueCmp_2765:
	cmpq $0, %rax
	je .verify_global_failureIf_2767
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2766
.verify_global_failureIf_2767:
	movq $.string_1783, %rax
.verify_global_endIf_2766:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1121, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $38, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $38, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $0, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1124, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $38, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $38, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $37, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2768
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2769
.verify_global_successCmp_2768:
	movq $1, %rax
.verify_global_continueCmp_2769:
	cmpq $0, %rax
	je .verify_global_failureIf_2771
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2770
.verify_global_failureIf_2771:
	movq $.string_1783, %rax
.verify_global_endIf_2770:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1126, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $38, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $38, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $37, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1129, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $39, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $39, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $4, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2772
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2773
.verify_global_successCmp_2772:
	movq $1, %rax
.verify_global_continueCmp_2773:
	cmpq $0, %rax
	je .verify_global_failureIf_2775
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2774
.verify_global_failureIf_2775:
	movq $.string_1783, %rax
.verify_global_endIf_2774:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1131, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $39, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $39, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $4, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1134, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $39, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $39, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $38, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2776
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2777
.verify_global_successCmp_2776:
	movq $1, %rax
.verify_global_continueCmp_2777:
	cmpq $0, %rax
	je .verify_global_failureIf_2779
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2778
.verify_global_failureIf_2779:
	movq $.string_1783, %rax
.verify_global_endIf_2778:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1136, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $39, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $39, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $38, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1139, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $40, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $40, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $1, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2780
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2781
.verify_global_successCmp_2780:
	movq $1, %rax
.verify_global_continueCmp_2781:
	cmpq $0, %rax
	je .verify_global_failureIf_2783
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2782
.verify_global_failureIf_2783:
	movq $.string_1783, %rax
.verify_global_endIf_2782:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1141, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $40, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $40, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $1, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1144, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $40, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $40, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $39, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2784
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2785
.verify_global_successCmp_2784:
	movq $1, %rax
.verify_global_continueCmp_2785:
	cmpq $0, %rax
	je .verify_global_failureIf_2787
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2786
.verify_global_failureIf_2787:
	movq $.string_1783, %rax
.verify_global_endIf_2786:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1146, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $40, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $40, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $39, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1149, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $41, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $41, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $0, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2788
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2789
.verify_global_successCmp_2788:
	movq $1, %rax
.verify_global_continueCmp_2789:
	cmpq $0, %rax
	je .verify_global_failureIf_2791
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2790
.verify_global_failureIf_2791:
	movq $.string_1783, %rax
.verify_global_endIf_2790:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1151, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $41, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $41, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $0, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1154, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $41, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $41, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $40, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2792
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2793
.verify_global_successCmp_2792:
	movq $1, %rax
.verify_global_continueCmp_2793:
	cmpq $0, %rax
	je .verify_global_failureIf_2795
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2794
.verify_global_failureIf_2795:
	movq $.string_1783, %rax
.verify_global_endIf_2794:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1156, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $41, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $41, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $40, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1159, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $42, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $42, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $1, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2796
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2797
.verify_global_successCmp_2796:
	movq $1, %rax
.verify_global_continueCmp_2797:
	cmpq $0, %rax
	je .verify_global_failureIf_2799
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2798
.verify_global_failureIf_2799:
	movq $.string_1783, %rax
.verify_global_endIf_2798:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1161, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $42, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $42, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $1, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1164, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $42, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $42, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $41, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2800
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2801
.verify_global_successCmp_2800:
	movq $1, %rax
.verify_global_continueCmp_2801:
	cmpq $0, %rax
	je .verify_global_failureIf_2803
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2802
.verify_global_failureIf_2803:
	movq $.string_1783, %rax
.verify_global_endIf_2802:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1166, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $42, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $42, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $41, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1169, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $43, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $43, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $4, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2804
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2805
.verify_global_successCmp_2804:
	movq $1, %rax
.verify_global_continueCmp_2805:
	cmpq $0, %rax
	je .verify_global_failureIf_2807
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2806
.verify_global_failureIf_2807:
	movq $.string_1783, %rax
.verify_global_endIf_2806:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1171, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $43, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $43, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $4, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1174, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $43, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $43, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $42, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2808
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2809
.verify_global_successCmp_2808:
	movq $1, %rax
.verify_global_continueCmp_2809:
	cmpq $0, %rax
	je .verify_global_failureIf_2811
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2810
.verify_global_failureIf_2811:
	movq $.string_1783, %rax
.verify_global_endIf_2810:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1176, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $43, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $43, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $42, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1179, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $44, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $44, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $0, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2812
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2813
.verify_global_successCmp_2812:
	movq $1, %rax
.verify_global_continueCmp_2813:
	cmpq $0, %rax
	je .verify_global_failureIf_2815
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2814
.verify_global_failureIf_2815:
	movq $.string_1783, %rax
.verify_global_endIf_2814:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1181, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $44, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $44, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $0, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1184, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $44, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $44, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $43, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2816
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2817
.verify_global_successCmp_2816:
	movq $1, %rax
.verify_global_continueCmp_2817:
	cmpq $0, %rax
	je .verify_global_failureIf_2819
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2818
.verify_global_failureIf_2819:
	movq $.string_1783, %rax
.verify_global_endIf_2818:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1186, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $44, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $44, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $43, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1189, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $45, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $45, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $7, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2820
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2821
.verify_global_successCmp_2820:
	movq $1, %rax
.verify_global_continueCmp_2821:
	cmpq $0, %rax
	je .verify_global_failureIf_2823
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2822
.verify_global_failureIf_2823:
	movq $.string_1783, %rax
.verify_global_endIf_2822:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1191, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $45, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $45, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $7, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1194, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $45, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $45, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $44, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2824
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2825
.verify_global_successCmp_2824:
	movq $1, %rax
.verify_global_continueCmp_2825:
	cmpq $0, %rax
	je .verify_global_failureIf_2827
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2826
.verify_global_failureIf_2827:
	movq $.string_1783, %rax
.verify_global_endIf_2826:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1196, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $45, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $45, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $44, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1199, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $46, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $46, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $7, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2828
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2829
.verify_global_successCmp_2828:
	movq $1, %rax
.verify_global_continueCmp_2829:
	cmpq $0, %rax
	je .verify_global_failureIf_2831
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2830
.verify_global_failureIf_2831:
	movq $.string_1783, %rax
.verify_global_endIf_2830:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1201, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $46, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $46, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $7, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1204, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $46, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $46, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $45, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2832
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2833
.verify_global_successCmp_2832:
	movq $1, %rax
.verify_global_continueCmp_2833:
	cmpq $0, %rax
	je .verify_global_failureIf_2835
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2834
.verify_global_failureIf_2835:
	movq $.string_1783, %rax
.verify_global_endIf_2834:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1206, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $46, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $46, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $45, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1209, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $47, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $47, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $0, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2836
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2837
.verify_global_successCmp_2836:
	movq $1, %rax
.verify_global_continueCmp_2837:
	cmpq $0, %rax
	je .verify_global_failureIf_2839
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2838
.verify_global_failureIf_2839:
	movq $.string_1783, %rax
.verify_global_endIf_2838:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1211, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $47, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $47, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $0, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1214, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $47, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $47, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $46, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2840
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2841
.verify_global_successCmp_2840:
	movq $1, %rax
.verify_global_continueCmp_2841:
	cmpq $0, %rax
	je .verify_global_failureIf_2843
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2842
.verify_global_failureIf_2843:
	movq $.string_1783, %rax
.verify_global_endIf_2842:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1216, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $47, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $47, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $46, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1219, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $48, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $48, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $4, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2844
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2845
.verify_global_successCmp_2844:
	movq $1, %rax
.verify_global_continueCmp_2845:
	cmpq $0, %rax
	je .verify_global_failureIf_2847
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2846
.verify_global_failureIf_2847:
	movq $.string_1783, %rax
.verify_global_endIf_2846:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1221, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $48, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $48, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $4, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1224, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $48, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $48, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $47, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2848
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2849
.verify_global_successCmp_2848:
	movq $1, %rax
.verify_global_continueCmp_2849:
	cmpq $0, %rax
	je .verify_global_failureIf_2851
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2850
.verify_global_failureIf_2851:
	movq $.string_1783, %rax
.verify_global_endIf_2850:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1226, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $48, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $48, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $47, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1229, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $49, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $49, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $1, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2852
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2853
.verify_global_successCmp_2852:
	movq $1, %rax
.verify_global_continueCmp_2853:
	cmpq $0, %rax
	je .verify_global_failureIf_2855
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2854
.verify_global_failureIf_2855:
	movq $.string_1783, %rax
.verify_global_endIf_2854:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1231, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $49, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $49, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $1, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1234, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $49, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $49, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $48, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2856
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2857
.verify_global_successCmp_2856:
	movq $1, %rax
.verify_global_continueCmp_2857:
	cmpq $0, %rax
	je .verify_global_failureIf_2859
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2858
.verify_global_failureIf_2859:
	movq $.string_1783, %rax
.verify_global_endIf_2858:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1236, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $49, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $49, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $48, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1239, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $50, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $50, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $0, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2860
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2861
.verify_global_successCmp_2860:
	movq $1, %rax
.verify_global_continueCmp_2861:
	cmpq $0, %rax
	je .verify_global_failureIf_2863
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2862
.verify_global_failureIf_2863:
	movq $.string_1783, %rax
.verify_global_endIf_2862:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1241, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $50, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $50, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $0, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1244, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $50, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $50, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $49, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2864
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2865
.verify_global_successCmp_2864:
	movq $1, %rax
.verify_global_continueCmp_2865:
	cmpq $0, %rax
	je .verify_global_failureIf_2867
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2866
.verify_global_failureIf_2867:
	movq $.string_1783, %rax
.verify_global_endIf_2866:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1246, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $50, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $50, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $49, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1249, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $51, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $51, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $1, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2868
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2869
.verify_global_successCmp_2868:
	movq $1, %rax
.verify_global_continueCmp_2869:
	cmpq $0, %rax
	je .verify_global_failureIf_2871
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2870
.verify_global_failureIf_2871:
	movq $.string_1783, %rax
.verify_global_endIf_2870:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1251, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $51, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $51, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $1, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1254, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $51, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $51, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $50, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2872
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2873
.verify_global_successCmp_2872:
	movq $1, %rax
.verify_global_continueCmp_2873:
	cmpq $0, %rax
	je .verify_global_failureIf_2875
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2874
.verify_global_failureIf_2875:
	movq $.string_1783, %rax
.verify_global_endIf_2874:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1256, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $51, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $51, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $50, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1259, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $52, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $52, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $4, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2876
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2877
.verify_global_successCmp_2876:
	movq $1, %rax
.verify_global_continueCmp_2877:
	cmpq $0, %rax
	je .verify_global_failureIf_2879
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2878
.verify_global_failureIf_2879:
	movq $.string_1783, %rax
.verify_global_endIf_2878:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1261, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $52, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $52, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $4, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1264, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $52, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $52, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $51, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2880
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2881
.verify_global_successCmp_2880:
	movq $1, %rax
.verify_global_continueCmp_2881:
	cmpq $0, %rax
	je .verify_global_failureIf_2883
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2882
.verify_global_failureIf_2883:
	movq $.string_1783, %rax
.verify_global_endIf_2882:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1266, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $52, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $52, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $51, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1269, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $53, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $53, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $0, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2884
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2885
.verify_global_successCmp_2884:
	movq $1, %rax
.verify_global_continueCmp_2885:
	cmpq $0, %rax
	je .verify_global_failureIf_2887
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2886
.verify_global_failureIf_2887:
	movq $.string_1783, %rax
.verify_global_endIf_2886:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1271, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $53, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $53, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $0, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1274, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $53, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $53, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $52, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2888
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2889
.verify_global_successCmp_2888:
	movq $1, %rax
.verify_global_continueCmp_2889:
	cmpq $0, %rax
	je .verify_global_failureIf_2891
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2890
.verify_global_failureIf_2891:
	movq $.string_1783, %rax
.verify_global_endIf_2890:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1276, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $53, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $53, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $52, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1279, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $54, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $54, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $7, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2892
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2893
.verify_global_successCmp_2892:
	movq $1, %rax
.verify_global_continueCmp_2893:
	cmpq $0, %rax
	je .verify_global_failureIf_2895
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2894
.verify_global_failureIf_2895:
	movq $.string_1783, %rax
.verify_global_endIf_2894:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1281, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $54, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $54, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $7, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1284, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $54, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $54, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $53, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2896
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2897
.verify_global_successCmp_2896:
	movq $1, %rax
.verify_global_continueCmp_2897:
	cmpq $0, %rax
	je .verify_global_failureIf_2899
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2898
.verify_global_failureIf_2899:
	movq $.string_1783, %rax
.verify_global_endIf_2898:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1286, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $54, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $54, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $53, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1289, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $55, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $55, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $7, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2900
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2901
.verify_global_successCmp_2900:
	movq $1, %rax
.verify_global_continueCmp_2901:
	cmpq $0, %rax
	je .verify_global_failureIf_2903
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2902
.verify_global_failureIf_2903:
	movq $.string_1783, %rax
.verify_global_endIf_2902:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1291, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $55, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $55, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $7, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1294, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $55, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $55, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $54, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2904
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2905
.verify_global_successCmp_2904:
	movq $1, %rax
.verify_global_continueCmp_2905:
	cmpq $0, %rax
	je .verify_global_failureIf_2907
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2906
.verify_global_failureIf_2907:
	movq $.string_1783, %rax
.verify_global_endIf_2906:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1296, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $55, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $55, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $54, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1299, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $56, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $56, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $0, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2908
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2909
.verify_global_successCmp_2908:
	movq $1, %rax
.verify_global_continueCmp_2909:
	cmpq $0, %rax
	je .verify_global_failureIf_2911
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2910
.verify_global_failureIf_2911:
	movq $.string_1783, %rax
.verify_global_endIf_2910:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1301, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $56, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $56, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $0, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1304, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $56, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $56, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $55, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2912
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2913
.verify_global_successCmp_2912:
	movq $1, %rax
.verify_global_continueCmp_2913:
	cmpq $0, %rax
	je .verify_global_failureIf_2915
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2914
.verify_global_failureIf_2915:
	movq $.string_1783, %rax
.verify_global_endIf_2914:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1306, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $56, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $56, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $55, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1309, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $57, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $57, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $4, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2916
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2917
.verify_global_successCmp_2916:
	movq $1, %rax
.verify_global_continueCmp_2917:
	cmpq $0, %rax
	je .verify_global_failureIf_2919
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2918
.verify_global_failureIf_2919:
	movq $.string_1783, %rax
.verify_global_endIf_2918:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1311, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $57, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $57, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $4, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1314, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $57, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $57, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $56, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2920
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2921
.verify_global_successCmp_2920:
	movq $1, %rax
.verify_global_continueCmp_2921:
	cmpq $0, %rax
	je .verify_global_failureIf_2923
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2922
.verify_global_failureIf_2923:
	movq $.string_1783, %rax
.verify_global_endIf_2922:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1316, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $57, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $57, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $56, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1319, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $58, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $58, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $1, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2924
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2925
.verify_global_successCmp_2924:
	movq $1, %rax
.verify_global_continueCmp_2925:
	cmpq $0, %rax
	je .verify_global_failureIf_2927
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2926
.verify_global_failureIf_2927:
	movq $.string_1783, %rax
.verify_global_endIf_2926:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1321, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $58, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $58, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $1, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1324, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $58, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $58, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $57, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2928
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2929
.verify_global_successCmp_2928:
	movq $1, %rax
.verify_global_continueCmp_2929:
	cmpq $0, %rax
	je .verify_global_failureIf_2931
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2930
.verify_global_failureIf_2931:
	movq $.string_1783, %rax
.verify_global_endIf_2930:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1326, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $58, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $58, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $57, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1329, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $59, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $59, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $0, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2932
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2933
.verify_global_successCmp_2932:
	movq $1, %rax
.verify_global_continueCmp_2933:
	cmpq $0, %rax
	je .verify_global_failureIf_2935
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2934
.verify_global_failureIf_2935:
	movq $.string_1783, %rax
.verify_global_endIf_2934:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1331, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $59, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $59, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $0, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1334, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $59, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $59, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $58, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2936
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2937
.verify_global_successCmp_2936:
	movq $1, %rax
.verify_global_continueCmp_2937:
	cmpq $0, %rax
	je .verify_global_failureIf_2939
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2938
.verify_global_failureIf_2939:
	movq $.string_1783, %rax
.verify_global_endIf_2938:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1336, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $59, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $59, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $58, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1339, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $60, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $60, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $1, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2940
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2941
.verify_global_successCmp_2940:
	movq $1, %rax
.verify_global_continueCmp_2941:
	cmpq $0, %rax
	je .verify_global_failureIf_2943
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2942
.verify_global_failureIf_2943:
	movq $.string_1783, %rax
.verify_global_endIf_2942:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1341, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $60, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $60, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $1, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1344, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $60, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $60, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $59, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2944
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2945
.verify_global_successCmp_2944:
	movq $1, %rax
.verify_global_continueCmp_2945:
	cmpq $0, %rax
	je .verify_global_failureIf_2947
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2946
.verify_global_failureIf_2947:
	movq $.string_1783, %rax
.verify_global_endIf_2946:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1346, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $60, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $60, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $59, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1349, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $61, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $61, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $4, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2948
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2949
.verify_global_successCmp_2948:
	movq $1, %rax
.verify_global_continueCmp_2949:
	cmpq $0, %rax
	je .verify_global_failureIf_2951
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2950
.verify_global_failureIf_2951:
	movq $.string_1783, %rax
.verify_global_endIf_2950:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1351, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $61, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $61, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $4, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1354, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $61, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $61, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $60, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2952
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2953
.verify_global_successCmp_2952:
	movq $1, %rax
.verify_global_continueCmp_2953:
	cmpq $0, %rax
	je .verify_global_failureIf_2955
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2954
.verify_global_failureIf_2955:
	movq $.string_1783, %rax
.verify_global_endIf_2954:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1356, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $61, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $61, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $60, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1359, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $62, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $62, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $0, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2956
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2957
.verify_global_successCmp_2956:
	movq $1, %rax
.verify_global_continueCmp_2957:
	cmpq $0, %rax
	je .verify_global_failureIf_2959
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2958
.verify_global_failureIf_2959:
	movq $.string_1783, %rax
.verify_global_endIf_2958:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1361, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $62, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $62, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $0, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1364, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $62, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $62, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $61, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2960
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2961
.verify_global_successCmp_2960:
	movq $1, %rax
.verify_global_continueCmp_2961:
	cmpq $0, %rax
	je .verify_global_failureIf_2963
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2962
.verify_global_failureIf_2963:
	movq $.string_1783, %rax
.verify_global_endIf_2962:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1366, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $62, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $62, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $61, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1369, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $63, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $63, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $7, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2964
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2965
.verify_global_successCmp_2964:
	movq $1, %rax
.verify_global_continueCmp_2965:
	cmpq $0, %rax
	je .verify_global_failureIf_2967
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2966
.verify_global_failureIf_2967:
	movq $.string_1783, %rax
.verify_global_endIf_2966:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1371, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $63, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $63, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $7, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1374, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $63, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $63, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $62, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2968
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2969
.verify_global_successCmp_2968:
	movq $1, %rax
.verify_global_continueCmp_2969:
	cmpq $0, %rax
	je .verify_global_failureIf_2971
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2970
.verify_global_failureIf_2971:
	movq $.string_1783, %rax
.verify_global_endIf_2970:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1376, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $63, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $63, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $62, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1379, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $64, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $64, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $7, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2972
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2973
.verify_global_successCmp_2972:
	movq $1, %rax
.verify_global_continueCmp_2973:
	cmpq $0, %rax
	je .verify_global_failureIf_2975
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2974
.verify_global_failureIf_2975:
	movq $.string_1783, %rax
.verify_global_endIf_2974:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1381, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $64, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $64, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $7, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1384, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $64, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $64, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $63, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2976
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2977
.verify_global_successCmp_2976:
	movq $1, %rax
.verify_global_continueCmp_2977:
	cmpq $0, %rax
	je .verify_global_failureIf_2979
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2978
.verify_global_failureIf_2979:
	movq $.string_1783, %rax
.verify_global_endIf_2978:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1386, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $64, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $64, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $63, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1389, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $65, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $65, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $0, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2980
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2981
.verify_global_successCmp_2980:
	movq $1, %rax
.verify_global_continueCmp_2981:
	cmpq $0, %rax
	je .verify_global_failureIf_2983
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2982
.verify_global_failureIf_2983:
	movq $.string_1783, %rax
.verify_global_endIf_2982:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1391, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $65, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $65, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $0, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1394, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $65, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $65, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $64, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2984
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2985
.verify_global_successCmp_2984:
	movq $1, %rax
.verify_global_continueCmp_2985:
	cmpq $0, %rax
	je .verify_global_failureIf_2987
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2986
.verify_global_failureIf_2987:
	movq $.string_1783, %rax
.verify_global_endIf_2986:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1396, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $65, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $65, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $64, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1399, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $66, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $66, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $4, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2988
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2989
.verify_global_successCmp_2988:
	movq $1, %rax
.verify_global_continueCmp_2989:
	cmpq $0, %rax
	je .verify_global_failureIf_2991
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2990
.verify_global_failureIf_2991:
	movq $.string_1783, %rax
.verify_global_endIf_2990:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1401, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $66, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $66, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $4, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1404, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $66, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $66, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $65, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2992
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2993
.verify_global_successCmp_2992:
	movq $1, %rax
.verify_global_continueCmp_2993:
	cmpq $0, %rax
	je .verify_global_failureIf_2995
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2994
.verify_global_failureIf_2995:
	movq $.string_1783, %rax
.verify_global_endIf_2994:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1406, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $66, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $66, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $65, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1409, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $67, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $67, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $1, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_2996
	xorq %rax, %rax
	jmp .verify_global_continueCmp_2997
.verify_global_successCmp_2996:
	movq $1, %rax
.verify_global_continueCmp_2997:
	cmpq $0, %rax
	je .verify_global_failureIf_2999
	movq $.string_1782, %rax
	jmp .verify_global_endIf_2998
.verify_global_failureIf_2999:
	movq $.string_1783, %rax
.verify_global_endIf_2998:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1411, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $67, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $67, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $1, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1414, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $67, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $67, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $66, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_3000
	xorq %rax, %rax
	jmp .verify_global_continueCmp_3001
.verify_global_successCmp_3000:
	movq $1, %rax
.verify_global_continueCmp_3001:
	cmpq $0, %rax
	je .verify_global_failureIf_3003
	movq $.string_1782, %rax
	jmp .verify_global_endIf_3002
.verify_global_failureIf_3003:
	movq $.string_1783, %rax
.verify_global_endIf_3002:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1416, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $67, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $67, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $66, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1419, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $68, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $68, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $0, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_3004
	xorq %rax, %rax
	jmp .verify_global_continueCmp_3005
.verify_global_successCmp_3004:
	movq $1, %rax
.verify_global_continueCmp_3005:
	cmpq $0, %rax
	je .verify_global_failureIf_3007
	movq $.string_1782, %rax
	jmp .verify_global_endIf_3006
.verify_global_failureIf_3007:
	movq $.string_1783, %rax
.verify_global_endIf_3006:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1421, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $68, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $68, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $0, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1424, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $68, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $68, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $67, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_3008
	xorq %rax, %rax
	jmp .verify_global_continueCmp_3009
.verify_global_successCmp_3008:
	movq $1, %rax
.verify_global_continueCmp_3009:
	cmpq $0, %rax
	je .verify_global_failureIf_3011
	movq $.string_1782, %rax
	jmp .verify_global_endIf_3010
.verify_global_failureIf_3011:
	movq $.string_1783, %rax
.verify_global_endIf_3010:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1426, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $68, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $68, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $67, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1429, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $69, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $69, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $1, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_3012
	xorq %rax, %rax
	jmp .verify_global_continueCmp_3013
.verify_global_successCmp_3012:
	movq $1, %rax
.verify_global_continueCmp_3013:
	cmpq $0, %rax
	je .verify_global_failureIf_3015
	movq $.string_1782, %rax
	jmp .verify_global_endIf_3014
.verify_global_failureIf_3015:
	movq $.string_1783, %rax
.verify_global_endIf_3014:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1431, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $69, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $69, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $1, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1434, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $69, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $69, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $68, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_3016
	xorq %rax, %rax
	jmp .verify_global_continueCmp_3017
.verify_global_successCmp_3016:
	movq $1, %rax
.verify_global_continueCmp_3017:
	cmpq $0, %rax
	je .verify_global_failureIf_3019
	movq $.string_1782, %rax
	jmp .verify_global_endIf_3018
.verify_global_failureIf_3019:
	movq $.string_1783, %rax
.verify_global_endIf_3018:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1436, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $69, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $69, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $68, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1439, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $70, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $70, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $4, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_3020
	xorq %rax, %rax
	jmp .verify_global_continueCmp_3021
.verify_global_successCmp_3020:
	movq $1, %rax
.verify_global_continueCmp_3021:
	cmpq $0, %rax
	je .verify_global_failureIf_3023
	movq $.string_1782, %rax
	jmp .verify_global_endIf_3022
.verify_global_failureIf_3023:
	movq $.string_1783, %rax
.verify_global_endIf_3022:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1441, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $70, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $70, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $4, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1444, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $70, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $70, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $69, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_3024
	xorq %rax, %rax
	jmp .verify_global_continueCmp_3025
.verify_global_successCmp_3024:
	movq $1, %rax
.verify_global_continueCmp_3025:
	cmpq $0, %rax
	je .verify_global_failureIf_3027
	movq $.string_1782, %rax
	jmp .verify_global_endIf_3026
.verify_global_failureIf_3027:
	movq $.string_1783, %rax
.verify_global_endIf_3026:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1446, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $70, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $70, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $69, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1449, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $71, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $71, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $0, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_3028
	xorq %rax, %rax
	jmp .verify_global_continueCmp_3029
.verify_global_successCmp_3028:
	movq $1, %rax
.verify_global_continueCmp_3029:
	cmpq $0, %rax
	je .verify_global_failureIf_3031
	movq $.string_1782, %rax
	jmp .verify_global_endIf_3030
.verify_global_failureIf_3031:
	movq $.string_1783, %rax
.verify_global_endIf_3030:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1451, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $71, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $71, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $0, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1454, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $71, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $71, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $70, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_3032
	xorq %rax, %rax
	jmp .verify_global_continueCmp_3033
.verify_global_successCmp_3032:
	movq $1, %rax
.verify_global_continueCmp_3033:
	cmpq $0, %rax
	je .verify_global_failureIf_3035
	movq $.string_1782, %rax
	jmp .verify_global_endIf_3034
.verify_global_failureIf_3035:
	movq $.string_1783, %rax
.verify_global_endIf_3034:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1456, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $71, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $71, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $70, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1459, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $72, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $72, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $7, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_3036
	xorq %rax, %rax
	jmp .verify_global_continueCmp_3037
.verify_global_successCmp_3036:
	movq $1, %rax
.verify_global_continueCmp_3037:
	cmpq $0, %rax
	je .verify_global_failureIf_3039
	movq $.string_1782, %rax
	jmp .verify_global_endIf_3038
.verify_global_failureIf_3039:
	movq $.string_1783, %rax
.verify_global_endIf_3038:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1461, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $72, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $72, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $7, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1464, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $72, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $72, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $71, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_3040
	xorq %rax, %rax
	jmp .verify_global_continueCmp_3041
.verify_global_successCmp_3040:
	movq $1, %rax
.verify_global_continueCmp_3041:
	cmpq $0, %rax
	je .verify_global_failureIf_3043
	movq $.string_1782, %rax
	jmp .verify_global_endIf_3042
.verify_global_failureIf_3043:
	movq $.string_1783, %rax
.verify_global_endIf_3042:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1466, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $72, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $72, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $71, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1469, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $73, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $73, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $7, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_3044
	xorq %rax, %rax
	jmp .verify_global_continueCmp_3045
.verify_global_successCmp_3044:
	movq $1, %rax
.verify_global_continueCmp_3045:
	cmpq $0, %rax
	je .verify_global_failureIf_3047
	movq $.string_1782, %rax
	jmp .verify_global_endIf_3046
.verify_global_failureIf_3047:
	movq $.string_1783, %rax
.verify_global_endIf_3046:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1471, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $73, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $73, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $7, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1474, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $73, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $73, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $72, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_3048
	xorq %rax, %rax
	jmp .verify_global_continueCmp_3049
.verify_global_successCmp_3048:
	movq $1, %rax
.verify_global_continueCmp_3049:
	cmpq $0, %rax
	je .verify_global_failureIf_3051
	movq $.string_1782, %rax
	jmp .verify_global_endIf_3050
.verify_global_failureIf_3051:
	movq $.string_1783, %rax
.verify_global_endIf_3050:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1476, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $73, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $73, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $72, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1479, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $74, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $74, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $0, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_3052
	xorq %rax, %rax
	jmp .verify_global_continueCmp_3053
.verify_global_successCmp_3052:
	movq $1, %rax
.verify_global_continueCmp_3053:
	cmpq $0, %rax
	je .verify_global_failureIf_3055
	movq $.string_1782, %rax
	jmp .verify_global_endIf_3054
.verify_global_failureIf_3055:
	movq $.string_1783, %rax
.verify_global_endIf_3054:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1481, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $74, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $74, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $0, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1484, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $74, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $74, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $73, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_3056
	xorq %rax, %rax
	jmp .verify_global_continueCmp_3057
.verify_global_successCmp_3056:
	movq $1, %rax
.verify_global_continueCmp_3057:
	cmpq $0, %rax
	je .verify_global_failureIf_3059
	movq $.string_1782, %rax
	jmp .verify_global_endIf_3058
.verify_global_failureIf_3059:
	movq $.string_1783, %rax
.verify_global_endIf_3058:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1486, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $74, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $74, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $73, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1489, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $75, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $75, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $4, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_3060
	xorq %rax, %rax
	jmp .verify_global_continueCmp_3061
.verify_global_successCmp_3060:
	movq $1, %rax
.verify_global_continueCmp_3061:
	cmpq $0, %rax
	je .verify_global_failureIf_3063
	movq $.string_1782, %rax
	jmp .verify_global_endIf_3062
.verify_global_failureIf_3063:
	movq $.string_1783, %rax
.verify_global_endIf_3062:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1491, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $75, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $75, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $4, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1494, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $75, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $75, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $74, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_3064
	xorq %rax, %rax
	jmp .verify_global_continueCmp_3065
.verify_global_successCmp_3064:
	movq $1, %rax
.verify_global_continueCmp_3065:
	cmpq $0, %rax
	je .verify_global_failureIf_3067
	movq $.string_1782, %rax
	jmp .verify_global_endIf_3066
.verify_global_failureIf_3067:
	movq $.string_1783, %rax
.verify_global_endIf_3066:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1496, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $75, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $75, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $74, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1499, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $76, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $76, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $1, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_3068
	xorq %rax, %rax
	jmp .verify_global_continueCmp_3069
.verify_global_successCmp_3068:
	movq $1, %rax
.verify_global_continueCmp_3069:
	cmpq $0, %rax
	je .verify_global_failureIf_3071
	movq $.string_1782, %rax
	jmp .verify_global_endIf_3070
.verify_global_failureIf_3071:
	movq $.string_1783, %rax
.verify_global_endIf_3070:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1501, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $76, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $76, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $1, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1504, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $76, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $76, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $75, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_3072
	xorq %rax, %rax
	jmp .verify_global_continueCmp_3073
.verify_global_successCmp_3072:
	movq $1, %rax
.verify_global_continueCmp_3073:
	cmpq $0, %rax
	je .verify_global_failureIf_3075
	movq $.string_1782, %rax
	jmp .verify_global_endIf_3074
.verify_global_failureIf_3075:
	movq $.string_1783, %rax
.verify_global_endIf_3074:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1506, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $76, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $76, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $75, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1509, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $77, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $77, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $0, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_3076
	xorq %rax, %rax
	jmp .verify_global_continueCmp_3077
.verify_global_successCmp_3076:
	movq $1, %rax
.verify_global_continueCmp_3077:
	cmpq $0, %rax
	je .verify_global_failureIf_3079
	movq $.string_1782, %rax
	jmp .verify_global_endIf_3078
.verify_global_failureIf_3079:
	movq $.string_1783, %rax
.verify_global_endIf_3078:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1511, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $77, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $77, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $0, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1514, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $77, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $77, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $76, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_3080
	xorq %rax, %rax
	jmp .verify_global_continueCmp_3081
.verify_global_successCmp_3080:
	movq $1, %rax
.verify_global_continueCmp_3081:
	cmpq $0, %rax
	je .verify_global_failureIf_3083
	movq $.string_1782, %rax
	jmp .verify_global_endIf_3082
.verify_global_failureIf_3083:
	movq $.string_1783, %rax
.verify_global_endIf_3082:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1516, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $77, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $77, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $76, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1519, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $78, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $78, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $1, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_3084
	xorq %rax, %rax
	jmp .verify_global_continueCmp_3085
.verify_global_successCmp_3084:
	movq $1, %rax
.verify_global_continueCmp_3085:
	cmpq $0, %rax
	je .verify_global_failureIf_3087
	movq $.string_1782, %rax
	jmp .verify_global_endIf_3086
.verify_global_failureIf_3087:
	movq $.string_1783, %rax
.verify_global_endIf_3086:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1521, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $78, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $78, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $1, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1524, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $78, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $78, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $77, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_3088
	xorq %rax, %rax
	jmp .verify_global_continueCmp_3089
.verify_global_successCmp_3088:
	movq $1, %rax
.verify_global_continueCmp_3089:
	cmpq $0, %rax
	je .verify_global_failureIf_3091
	movq $.string_1782, %rax
	jmp .verify_global_endIf_3090
.verify_global_failureIf_3091:
	movq $.string_1783, %rax
.verify_global_endIf_3090:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1526, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $78, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $78, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $77, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1529, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $79, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $79, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $4, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_3092
	xorq %rax, %rax
	jmp .verify_global_continueCmp_3093
.verify_global_successCmp_3092:
	movq $1, %rax
.verify_global_continueCmp_3093:
	cmpq $0, %rax
	je .verify_global_failureIf_3095
	movq $.string_1782, %rax
	jmp .verify_global_endIf_3094
.verify_global_failureIf_3095:
	movq $.string_1783, %rax
.verify_global_endIf_3094:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1531, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $79, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $79, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $4, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1534, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $79, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $79, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $78, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_3096
	xorq %rax, %rax
	jmp .verify_global_continueCmp_3097
.verify_global_successCmp_3096:
	movq $1, %rax
.verify_global_continueCmp_3097:
	cmpq $0, %rax
	je .verify_global_failureIf_3099
	movq $.string_1782, %rax
	jmp .verify_global_endIf_3098
.verify_global_failureIf_3099:
	movq $.string_1783, %rax
.verify_global_endIf_3098:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1536, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $79, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $79, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $78, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1539, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $80, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $80, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $0, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_3100
	xorq %rax, %rax
	jmp .verify_global_continueCmp_3101
.verify_global_successCmp_3100:
	movq $1, %rax
.verify_global_continueCmp_3101:
	cmpq $0, %rax
	je .verify_global_failureIf_3103
	movq $.string_1782, %rax
	jmp .verify_global_endIf_3102
.verify_global_failureIf_3103:
	movq $.string_1783, %rax
.verify_global_endIf_3102:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1541, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $80, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $80, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $0, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1544, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $80, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $80, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $79, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_3104
	xorq %rax, %rax
	jmp .verify_global_continueCmp_3105
.verify_global_successCmp_3104:
	movq $1, %rax
.verify_global_continueCmp_3105:
	cmpq $0, %rax
	je .verify_global_failureIf_3107
	movq $.string_1782, %rax
	jmp .verify_global_endIf_3106
.verify_global_failureIf_3107:
	movq $.string_1783, %rax
.verify_global_endIf_3106:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1546, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $80, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $80, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $79, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1549, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $81, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $81, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $7, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_3108
	xorq %rax, %rax
	jmp .verify_global_continueCmp_3109
.verify_global_successCmp_3108:
	movq $1, %rax
.verify_global_continueCmp_3109:
	cmpq $0, %rax
	je .verify_global_failureIf_3111
	movq $.string_1782, %rax
	jmp .verify_global_endIf_3110
.verify_global_failureIf_3111:
	movq $.string_1783, %rax
.verify_global_endIf_3110:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1551, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $81, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $81, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $7, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1554, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $81, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $81, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $80, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_3112
	xorq %rax, %rax
	jmp .verify_global_continueCmp_3113
.verify_global_successCmp_3112:
	movq $1, %rax
.verify_global_continueCmp_3113:
	cmpq $0, %rax
	je .verify_global_failureIf_3115
	movq $.string_1782, %rax
	jmp .verify_global_endIf_3114
.verify_global_failureIf_3115:
	movq $.string_1783, %rax
.verify_global_endIf_3114:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1556, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $81, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $81, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $80, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1559, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $82, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $82, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $7, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_3116
	xorq %rax, %rax
	jmp .verify_global_continueCmp_3117
.verify_global_successCmp_3116:
	movq $1, %rax
.verify_global_continueCmp_3117:
	cmpq $0, %rax
	je .verify_global_failureIf_3119
	movq $.string_1782, %rax
	jmp .verify_global_endIf_3118
.verify_global_failureIf_3119:
	movq $.string_1783, %rax
.verify_global_endIf_3118:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1561, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $82, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $82, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $7, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1564, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $82, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $82, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $81, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_3120
	xorq %rax, %rax
	jmp .verify_global_continueCmp_3121
.verify_global_successCmp_3120:
	movq $1, %rax
.verify_global_continueCmp_3121:
	cmpq $0, %rax
	je .verify_global_failureIf_3123
	movq $.string_1782, %rax
	jmp .verify_global_endIf_3122
.verify_global_failureIf_3123:
	movq $.string_1783, %rax
.verify_global_endIf_3122:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1566, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $82, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $82, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $81, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1569, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $83, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $83, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $0, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_3124
	xorq %rax, %rax
	jmp .verify_global_continueCmp_3125
.verify_global_successCmp_3124:
	movq $1, %rax
.verify_global_continueCmp_3125:
	cmpq $0, %rax
	je .verify_global_failureIf_3127
	movq $.string_1782, %rax
	jmp .verify_global_endIf_3126
.verify_global_failureIf_3127:
	movq $.string_1783, %rax
.verify_global_endIf_3126:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1571, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $83, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $83, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $0, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1574, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $83, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $83, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $82, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_3128
	xorq %rax, %rax
	jmp .verify_global_continueCmp_3129
.verify_global_successCmp_3128:
	movq $1, %rax
.verify_global_continueCmp_3129:
	cmpq $0, %rax
	je .verify_global_failureIf_3131
	movq $.string_1782, %rax
	jmp .verify_global_endIf_3130
.verify_global_failureIf_3131:
	movq $.string_1783, %rax
.verify_global_endIf_3130:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1576, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $83, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $83, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $82, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1579, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $84, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $84, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $4, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_3132
	xorq %rax, %rax
	jmp .verify_global_continueCmp_3133
.verify_global_successCmp_3132:
	movq $1, %rax
.verify_global_continueCmp_3133:
	cmpq $0, %rax
	je .verify_global_failureIf_3135
	movq $.string_1782, %rax
	jmp .verify_global_endIf_3134
.verify_global_failureIf_3135:
	movq $.string_1783, %rax
.verify_global_endIf_3134:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1581, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $84, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $84, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $4, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1584, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $84, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $84, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $83, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_3136
	xorq %rax, %rax
	jmp .verify_global_continueCmp_3137
.verify_global_successCmp_3136:
	movq $1, %rax
.verify_global_continueCmp_3137:
	cmpq $0, %rax
	je .verify_global_failureIf_3139
	movq $.string_1782, %rax
	jmp .verify_global_endIf_3138
.verify_global_failureIf_3139:
	movq $.string_1783, %rax
.verify_global_endIf_3138:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1586, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $84, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $84, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $83, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1589, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $85, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $85, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $1, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_3140
	xorq %rax, %rax
	jmp .verify_global_continueCmp_3141
.verify_global_successCmp_3140:
	movq $1, %rax
.verify_global_continueCmp_3141:
	cmpq $0, %rax
	je .verify_global_failureIf_3143
	movq $.string_1782, %rax
	jmp .verify_global_endIf_3142
.verify_global_failureIf_3143:
	movq $.string_1783, %rax
.verify_global_endIf_3142:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1591, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $85, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $85, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $1, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1594, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $85, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $85, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $84, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_3144
	xorq %rax, %rax
	jmp .verify_global_continueCmp_3145
.verify_global_successCmp_3144:
	movq $1, %rax
.verify_global_continueCmp_3145:
	cmpq $0, %rax
	je .verify_global_failureIf_3147
	movq $.string_1782, %rax
	jmp .verify_global_endIf_3146
.verify_global_failureIf_3147:
	movq $.string_1783, %rax
.verify_global_endIf_3146:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1596, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $85, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $85, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $84, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1599, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $86, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $86, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $0, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_3148
	xorq %rax, %rax
	jmp .verify_global_continueCmp_3149
.verify_global_successCmp_3148:
	movq $1, %rax
.verify_global_continueCmp_3149:
	cmpq $0, %rax
	je .verify_global_failureIf_3151
	movq $.string_1782, %rax
	jmp .verify_global_endIf_3150
.verify_global_failureIf_3151:
	movq $.string_1783, %rax
.verify_global_endIf_3150:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1601, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $86, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $86, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $0, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1604, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $86, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $86, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $85, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_3152
	xorq %rax, %rax
	jmp .verify_global_continueCmp_3153
.verify_global_successCmp_3152:
	movq $1, %rax
.verify_global_continueCmp_3153:
	cmpq $0, %rax
	je .verify_global_failureIf_3155
	movq $.string_1782, %rax
	jmp .verify_global_endIf_3154
.verify_global_failureIf_3155:
	movq $.string_1783, %rax
.verify_global_endIf_3154:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1606, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $86, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $86, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $85, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1609, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $87, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $87, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $1, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_3156
	xorq %rax, %rax
	jmp .verify_global_continueCmp_3157
.verify_global_successCmp_3156:
	movq $1, %rax
.verify_global_continueCmp_3157:
	cmpq $0, %rax
	je .verify_global_failureIf_3159
	movq $.string_1782, %rax
	jmp .verify_global_endIf_3158
.verify_global_failureIf_3159:
	movq $.string_1783, %rax
.verify_global_endIf_3158:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1611, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $87, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $87, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $1, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1614, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $87, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $87, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $86, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_3160
	xorq %rax, %rax
	jmp .verify_global_continueCmp_3161
.verify_global_successCmp_3160:
	movq $1, %rax
.verify_global_continueCmp_3161:
	cmpq $0, %rax
	je .verify_global_failureIf_3163
	movq $.string_1782, %rax
	jmp .verify_global_endIf_3162
.verify_global_failureIf_3163:
	movq $.string_1783, %rax
.verify_global_endIf_3162:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1616, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $87, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $87, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $86, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1619, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $88, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $88, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $4, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_3164
	xorq %rax, %rax
	jmp .verify_global_continueCmp_3165
.verify_global_successCmp_3164:
	movq $1, %rax
.verify_global_continueCmp_3165:
	cmpq $0, %rax
	je .verify_global_failureIf_3167
	movq $.string_1782, %rax
	jmp .verify_global_endIf_3166
.verify_global_failureIf_3167:
	movq $.string_1783, %rax
.verify_global_endIf_3166:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1621, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $88, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $88, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $4, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1624, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $88, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $88, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $87, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_3168
	xorq %rax, %rax
	jmp .verify_global_continueCmp_3169
.verify_global_successCmp_3168:
	movq $1, %rax
.verify_global_continueCmp_3169:
	cmpq $0, %rax
	je .verify_global_failureIf_3171
	movq $.string_1782, %rax
	jmp .verify_global_endIf_3170
.verify_global_failureIf_3171:
	movq $.string_1783, %rax
.verify_global_endIf_3170:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1626, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $88, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $88, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $87, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1629, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $89, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $89, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $0, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_3172
	xorq %rax, %rax
	jmp .verify_global_continueCmp_3173
.verify_global_successCmp_3172:
	movq $1, %rax
.verify_global_continueCmp_3173:
	cmpq $0, %rax
	je .verify_global_failureIf_3175
	movq $.string_1782, %rax
	jmp .verify_global_endIf_3174
.verify_global_failureIf_3175:
	movq $.string_1783, %rax
.verify_global_endIf_3174:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1631, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $89, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $89, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $0, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1634, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $89, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $89, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $88, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_3176
	xorq %rax, %rax
	jmp .verify_global_continueCmp_3177
.verify_global_successCmp_3176:
	movq $1, %rax
.verify_global_continueCmp_3177:
	cmpq $0, %rax
	je .verify_global_failureIf_3179
	movq $.string_1782, %rax
	jmp .verify_global_endIf_3178
.verify_global_failureIf_3179:
	movq $.string_1783, %rax
.verify_global_endIf_3178:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1636, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $89, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $89, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $88, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1639, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $90, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $90, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $7, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_3180
	xorq %rax, %rax
	jmp .verify_global_continueCmp_3181
.verify_global_successCmp_3180:
	movq $1, %rax
.verify_global_continueCmp_3181:
	cmpq $0, %rax
	je .verify_global_failureIf_3183
	movq $.string_1782, %rax
	jmp .verify_global_endIf_3182
.verify_global_failureIf_3183:
	movq $.string_1783, %rax
.verify_global_endIf_3182:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1641, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $90, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $90, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $7, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1644, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $90, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $90, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $89, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_3184
	xorq %rax, %rax
	jmp .verify_global_continueCmp_3185
.verify_global_successCmp_3184:
	movq $1, %rax
.verify_global_continueCmp_3185:
	cmpq $0, %rax
	je .verify_global_failureIf_3187
	movq $.string_1782, %rax
	jmp .verify_global_endIf_3186
.verify_global_failureIf_3187:
	movq $.string_1783, %rax
.verify_global_endIf_3186:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1646, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $90, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $90, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $89, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1649, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $91, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $91, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $7, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_3188
	xorq %rax, %rax
	jmp .verify_global_continueCmp_3189
.verify_global_successCmp_3188:
	movq $1, %rax
.verify_global_continueCmp_3189:
	cmpq $0, %rax
	je .verify_global_failureIf_3191
	movq $.string_1782, %rax
	jmp .verify_global_endIf_3190
.verify_global_failureIf_3191:
	movq $.string_1783, %rax
.verify_global_endIf_3190:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1651, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $91, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $91, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $7, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1654, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $91, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $91, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $90, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_3192
	xorq %rax, %rax
	jmp .verify_global_continueCmp_3193
.verify_global_successCmp_3192:
	movq $1, %rax
.verify_global_continueCmp_3193:
	cmpq $0, %rax
	je .verify_global_failureIf_3195
	movq $.string_1782, %rax
	jmp .verify_global_endIf_3194
.verify_global_failureIf_3195:
	movq $.string_1783, %rax
.verify_global_endIf_3194:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1656, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $91, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $91, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $90, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1659, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $92, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $92, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $0, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_3196
	xorq %rax, %rax
	jmp .verify_global_continueCmp_3197
.verify_global_successCmp_3196:
	movq $1, %rax
.verify_global_continueCmp_3197:
	cmpq $0, %rax
	je .verify_global_failureIf_3199
	movq $.string_1782, %rax
	jmp .verify_global_endIf_3198
.verify_global_failureIf_3199:
	movq $.string_1783, %rax
.verify_global_endIf_3198:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1661, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $92, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $92, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $0, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1664, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $92, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $92, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $91, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_3200
	xorq %rax, %rax
	jmp .verify_global_continueCmp_3201
.verify_global_successCmp_3200:
	movq $1, %rax
.verify_global_continueCmp_3201:
	cmpq $0, %rax
	je .verify_global_failureIf_3203
	movq $.string_1782, %rax
	jmp .verify_global_endIf_3202
.verify_global_failureIf_3203:
	movq $.string_1783, %rax
.verify_global_endIf_3202:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1666, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $92, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $92, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $91, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1669, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $93, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $93, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $4, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_3204
	xorq %rax, %rax
	jmp .verify_global_continueCmp_3205
.verify_global_successCmp_3204:
	movq $1, %rax
.verify_global_continueCmp_3205:
	cmpq $0, %rax
	je .verify_global_failureIf_3207
	movq $.string_1782, %rax
	jmp .verify_global_endIf_3206
.verify_global_failureIf_3207:
	movq $.string_1783, %rax
.verify_global_endIf_3206:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1671, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $93, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $93, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $4, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1674, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $93, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $93, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $92, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_3208
	xorq %rax, %rax
	jmp .verify_global_continueCmp_3209
.verify_global_successCmp_3208:
	movq $1, %rax
.verify_global_continueCmp_3209:
	cmpq $0, %rax
	je .verify_global_failureIf_3211
	movq $.string_1782, %rax
	jmp .verify_global_endIf_3210
.verify_global_failureIf_3211:
	movq $.string_1783, %rax
.verify_global_endIf_3210:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1676, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $93, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $93, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $92, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1679, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $94, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $94, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $1, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_3212
	xorq %rax, %rax
	jmp .verify_global_continueCmp_3213
.verify_global_successCmp_3212:
	movq $1, %rax
.verify_global_continueCmp_3213:
	cmpq $0, %rax
	je .verify_global_failureIf_3215
	movq $.string_1782, %rax
	jmp .verify_global_endIf_3214
.verify_global_failureIf_3215:
	movq $.string_1783, %rax
.verify_global_endIf_3214:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1681, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $94, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $94, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $1, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1684, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $94, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $94, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $93, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_3216
	xorq %rax, %rax
	jmp .verify_global_continueCmp_3217
.verify_global_successCmp_3216:
	movq $1, %rax
.verify_global_continueCmp_3217:
	cmpq $0, %rax
	je .verify_global_failureIf_3219
	movq $.string_1782, %rax
	jmp .verify_global_endIf_3218
.verify_global_failureIf_3219:
	movq $.string_1783, %rax
.verify_global_endIf_3218:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1686, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $94, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $94, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $93, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1689, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $95, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $95, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $0, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_3220
	xorq %rax, %rax
	jmp .verify_global_continueCmp_3221
.verify_global_successCmp_3220:
	movq $1, %rax
.verify_global_continueCmp_3221:
	cmpq $0, %rax
	je .verify_global_failureIf_3223
	movq $.string_1782, %rax
	jmp .verify_global_endIf_3222
.verify_global_failureIf_3223:
	movq $.string_1783, %rax
.verify_global_endIf_3222:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1691, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $95, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $95, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $0, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1694, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $95, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $95, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $94, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_3224
	xorq %rax, %rax
	jmp .verify_global_continueCmp_3225
.verify_global_successCmp_3224:
	movq $1, %rax
.verify_global_continueCmp_3225:
	cmpq $0, %rax
	je .verify_global_failureIf_3227
	movq $.string_1782, %rax
	jmp .verify_global_endIf_3226
.verify_global_failureIf_3227:
	movq $.string_1783, %rax
.verify_global_endIf_3226:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1696, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $95, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $95, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $94, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1699, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $96, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $96, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $1, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_3228
	xorq %rax, %rax
	jmp .verify_global_continueCmp_3229
.verify_global_successCmp_3228:
	movq $1, %rax
.verify_global_continueCmp_3229:
	cmpq $0, %rax
	je .verify_global_failureIf_3231
	movq $.string_1782, %rax
	jmp .verify_global_endIf_3230
.verify_global_failureIf_3231:
	movq $.string_1783, %rax
.verify_global_endIf_3230:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1701, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $96, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $96, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $1, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1704, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $96, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $96, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $95, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_3232
	xorq %rax, %rax
	jmp .verify_global_continueCmp_3233
.verify_global_successCmp_3232:
	movq $1, %rax
.verify_global_continueCmp_3233:
	cmpq $0, %rax
	je .verify_global_failureIf_3235
	movq $.string_1782, %rax
	jmp .verify_global_endIf_3234
.verify_global_failureIf_3235:
	movq $.string_1783, %rax
.verify_global_endIf_3234:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1706, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $96, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $96, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $95, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1709, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $97, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $97, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $4, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_3236
	xorq %rax, %rax
	jmp .verify_global_continueCmp_3237
.verify_global_successCmp_3236:
	movq $1, %rax
.verify_global_continueCmp_3237:
	cmpq $0, %rax
	je .verify_global_failureIf_3239
	movq $.string_1782, %rax
	jmp .verify_global_endIf_3238
.verify_global_failureIf_3239:
	movq $.string_1783, %rax
.verify_global_endIf_3238:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1711, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $97, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $97, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $4, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1714, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $97, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $97, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $96, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_3240
	xorq %rax, %rax
	jmp .verify_global_continueCmp_3241
.verify_global_successCmp_3240:
	movq $1, %rax
.verify_global_continueCmp_3241:
	cmpq $0, %rax
	je .verify_global_failureIf_3243
	movq $.string_1782, %rax
	jmp .verify_global_endIf_3242
.verify_global_failureIf_3243:
	movq $.string_1783, %rax
.verify_global_endIf_3242:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1716, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $97, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $97, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $96, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1719, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $98, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $98, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $0, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_3244
	xorq %rax, %rax
	jmp .verify_global_continueCmp_3245
.verify_global_successCmp_3244:
	movq $1, %rax
.verify_global_continueCmp_3245:
	cmpq $0, %rax
	je .verify_global_failureIf_3247
	movq $.string_1782, %rax
	jmp .verify_global_endIf_3246
.verify_global_failureIf_3247:
	movq $.string_1783, %rax
.verify_global_endIf_3246:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1721, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $98, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $98, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $0, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1724, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $98, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $98, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $97, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_3248
	xorq %rax, %rax
	jmp .verify_global_continueCmp_3249
.verify_global_successCmp_3248:
	movq $1, %rax
.verify_global_continueCmp_3249:
	cmpq $0, %rax
	je .verify_global_failureIf_3251
	movq $.string_1782, %rax
	jmp .verify_global_endIf_3250
.verify_global_failureIf_3251:
	movq $.string_1783, %rax
.verify_global_endIf_3250:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1726, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $98, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $98, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $97, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1729, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $99, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $99, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $7, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_3252
	xorq %rax, %rax
	jmp .verify_global_continueCmp_3253
.verify_global_successCmp_3252:
	movq $1, %rax
.verify_global_continueCmp_3253:
	cmpq $0, %rax
	je .verify_global_failureIf_3255
	movq $.string_1782, %rax
	jmp .verify_global_endIf_3254
.verify_global_failureIf_3255:
	movq $.string_1783, %rax
.verify_global_endIf_3254:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1731, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $99, %rax
	pushq %rax
	movq global_5, %rax
	popq %rcx
	movq $99, %rax
	movq %rax, %rcx
	movq global_5, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $7, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1734, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $99, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $99, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $98, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .verify_global_successCmp_3256
	xorq %rax, %rax
	jmp .verify_global_continueCmp_3257
.verify_global_successCmp_3256:
	movq $1, %rax
.verify_global_continueCmp_3257:
	cmpq $0, %rax
	je .verify_global_failureIf_3259
	movq $.string_1782, %rax
	jmp .verify_global_endIf_3258
.verify_global_failureIf_3259:
	movq $.string_1783, %rax
.verify_global_endIf_3258:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1736, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $99, %rax
	pushq %rax
	movq global_6, %rax
	popq %rcx
	movq $99, %rax
	movq %rax, %rcx
	movq global_6, %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $98, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1739, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
.verify_global_endFunction_2443:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl test_global
 test_global:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	pushq %rdi	# saving argument number 1 on the stack
	movq -8(%rbp), %rax
	inc %rax
	movq %rax, -8(%rbp)
	pushq %rax
	movq $10, %rax
	pushq %rax
	movq -8(%rbp), %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	imulq %rcx, %rax
	popq %rcx
	addq %rcx, %rax
	popq %rcx
	addq %rcx, %rax
	movq %rax, -8(%rbp)
	movq global_4, %rax
	pushq %rax
	movq $1, %rax
	pushq %rax
	movq global_3, %rax
	popq %rcx
	addq %rcx, %rax
	pushq %rax
	movq $3, %rax
	pushq %rax
	movq global_2, %rax
	pushq %rax
	movq global_1, %rax
	popq %rcx
	imulq %rcx, %rax
	popq %rcx
	addq %rcx, %rax
	popq %rcx
	xorq %rdx, %rdx
	cqo
	idivq %rcx
	movq %rdx, %rax
	popq %rcx
	xorq %rdx, %rdx
	cqo
	idivq %rcx
	movq %rax, global_1
	movq $121, %rax
	pushq %rax
	movq global_1, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	addq %rcx, %rax
	popq %rcx
	xorq %rdx, %rdx
	cqo
	idivq %rcx
	movq %rdx, %rax
	movq %rax, global_2
	movq global_2, %rax
	pushq %rax
	movq global_4, %rax
	popq %rcx
	addq %rcx, %rax
	movq %rax, global_3
	movq $152, %rax
	pushq %rax
	movq global_4, %rax
	pushq %rax	# the value of expr is stored in for later
	inc %rax
	movq %rax, global_4
	popq %rax
	popq %rcx
	addq %rcx, %rax
	movq %rax, global_4
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq verify_global
	popq %r10	# retrieve caller-saved registers
	popq %r11
.test_global_endFunction_3260:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl test_last
 test_last:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	pushq %rdi	# saving argument number 1 on the stack
	pushq %rsi	# saving argument number 2 on the stack
	subq $16, %rsp
	movq $2, %rax
	pushq %rax
	movq -16(%rbp), %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	addq %rcx, %rax
	popq %rcx
	xorq %rdx, %rdx
	cqo
	idivq %rcx
	movq %rax, -24(%rbp)
	movq $14, %rax
	pushq %rax
	movq -16(%rbp), %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	addq %rcx, %rax
	pushq %rax
	movq -16(%rbp), %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	addq %rcx, %rax
	popq %rcx
	imulq %rcx, %rax
	popq %rcx
	subq %rcx, %rax
	movq %rax, -32(%rbp)
	movq -8(%rbp), %rax
	pushq %rax	# the value of expr is stored in for later
	inc %rax
	movq %rax, -8(%rbp)
	popq %rax
	pushq %rax
	movq -24(%rbp), %rax
	pushq %rax	# the value of expr is stored in for later
	dec %rax
	movq %rax, -24(%rbp)
	popq %rax
	pushq %rax
	movq -32(%rbp), %rax
	pushq %rax	# the value of expr is stored in for later
	inc %rax
	movq %rax, -32(%rbp)
	popq %rax
	popq %rcx
	xorq %rdx, %rdx
	cqo
	idivq %rcx
	pushq %rax
	movq -32(%rbp), %rax
	pushq %rax	# the value of expr is stored in for later
	dec %rax
	movq %rax, -32(%rbp)
	popq %rax
	pushq %rax
	movq -24(%rbp), %rax
	inc %rax
	movq %rax, -24(%rbp)
	pushq %rax
	movq -24(%rbp), %rax
	dec %rax
	movq %rax, -24(%rbp)
	popq %rcx
	imulq %rcx, %rax
	popq %rcx
	xorq %rdx, %rdx
	cqo
	idivq %rcx
	movq %rdx, %rax
	popq %rcx
	addq %rcx, %rax
	popq %rcx
	addq %rcx, %rax
	movq %rax, -24(%rbp)
	movq -16(%rbp), %rax
	pushq %rax	# the value of expr is stored in for later
	dec %rax
	movq %rax, -16(%rbp)
	popq %rax
	pushq %rax
	movq -8(%rbp), %rax
	pushq %rax	# the value of expr is stored in for later
	dec %rax
	movq %rax, -8(%rbp)
	popq %rax
	popq %rcx
	subq %rcx, %rax
	pushq %rax
	movq -24(%rbp), %rax
	pushq %rax	# the value of expr is stored in for later
	dec %rax
	movq %rax, -24(%rbp)
	popq %rax
	pushq %rax
	movq -32(%rbp), %rax
	pushq %rax	# the value of expr is stored in for later
	inc %rax
	movq %rax, -32(%rbp)
	popq %rax
	popq %rcx
	xorq %rdx, %rdx
	cqo
	idivq %rcx
	pushq %rax
	movq -32(%rbp), %rax
	pushq %rax	# the value of expr is stored in for later
	dec %rax
	movq %rax, -32(%rbp)
	popq %rax
	pushq %rax
	movq -24(%rbp), %rax
	inc %rax
	movq %rax, -24(%rbp)
	pushq %rax
	movq -24(%rbp), %rax
	dec %rax
	movq %rax, -24(%rbp)
	popq %rcx
	imulq %rcx, %rax
	popq %rcx
	xorq %rdx, %rdx
	cqo
	idivq %rcx
	movq %rdx, %rax
	popq %rcx
	addq %rcx, %rax
	popq %rcx
	imulq %rcx, %rax
	movq %rax, -32(%rbp)
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -24(%rbp), %rax
	pushq %rax
	movq $6056, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_last_successCmp_3262
	xorq %rax, %rax
	jmp .test_last_continueCmp_3263
.test_last_successCmp_3262:
	movq $1, %rax
.test_last_continueCmp_3263:
	cmpq $0, %rax
	je .test_last_failureIf_3265
	movq $.string_1782, %rax
	jmp .test_last_endIf_3264
.test_last_failureIf_3265:
	movq $.string_1783, %rax
.test_last_endIf_3264:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1741, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -24(%rbp), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $6056, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1744, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -32(%rbp), %rax
	pushq %rax
	movq $545541, %rax
	neg %rax
	popq %rcx
	cmpq %rcx, %rax
	je .test_last_successCmp_3266
	xorq %rax, %rax
	jmp .test_last_continueCmp_3267
.test_last_successCmp_3266:
	movq $1, %rax
.test_last_continueCmp_3267:
	cmpq $0, %rax
	je .test_last_failureIf_3269
	movq $.string_1782, %rax
	jmp .test_last_endIf_3268
.test_last_failureIf_3269:
	movq $.string_1783, %rax
.test_last_endIf_3268:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1746, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -32(%rbp), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $545541, %rax
	neg %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1749, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	addq $16, %rsp
.test_last_endFunction_3261:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl main
 main:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	subq $48, %rsp
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq test_expr
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	movq %rax, -8(%rbp)
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq test_code
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	movq %rax, -16(%rbp)
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $5, %rax
	pushq %rax	# putting argument number 10 on the stack
	movq global_1, %rax
	pushq %rax	# putting argument number 9 on the stack
	movq global_2, %rax
	pushq %rax	# putting argument number 8 on the stack
	movq $589, %rax
	neg %rax
	pushq %rax	# putting argument number 7 on the stack
	movq $12, %rax
	pushq %rax	# putting argument number 6 on the stack
	movq $1547, %rax
	pushq %rax	# putting argument number 5 on the stack
	movq global_1, %rax
	pushq %rax
	movq $9, %rax
	pushq %rax
	movq $8, %rax
	popq %rcx
	subq %rcx, %rax
	popq %rcx
	addq %rcx, %rax
	pushq %rax	# putting argument number 4 on the stack
	movq global_1, %rax
	pushq %rax
	movq global_2, %rax
	popq %rcx
	imulq %rcx, %rax
	pushq %rax	# putting argument number 3 on the stack
	movq global_1, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $5, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	popq %rcx	# putting argument number 4 in register
	popq %r8	# putting argument number 5 in register
	popq %r9	# putting argument number 6 in register
	xorq %rax, %rax
	callq test_args
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	movq %rax, -24(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $2, %rax
	neg %rax
	pushq %rax	# putting argument number 11 on the stack
	movq $5, %rax
	pushq %rax	# putting argument number 10 on the stack
	movq global_1, %rax
	pushq %rax	# putting argument number 9 on the stack
	movq global_2, %rax
	pushq %rax	# putting argument number 8 on the stack
	movq $589, %rax
	neg %rax
	pushq %rax	# putting argument number 7 on the stack
	movq $12, %rax
	pushq %rax	# putting argument number 6 on the stack
	movq $1547, %rax
	pushq %rax	# putting argument number 5 on the stack
	movq global_1, %rax
	pushq %rax
	movq $9, %rax
	pushq %rax
	movq $8, %rax
	popq %rcx
	subq %rcx, %rax
	popq %rcx
	addq %rcx, %rax
	pushq %rax	# putting argument number 4 on the stack
	movq global_1, %rax
	pushq %rax
	movq global_2, %rax
	popq %rcx
	imulq %rcx, %rax
	pushq %rax	# putting argument number 3 on the stack
	movq global_1, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $5, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	popq %rcx	# putting argument number 4 in register
	popq %r8	# putting argument number 5 in register
	popq %r9	# putting argument number 6 in register
	xorq %rax, %rax
	callq test_args
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	movq %rax, -40(%rbp)
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $0, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq test_tabs
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	movq %rax, -48(%rbp)
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $1947, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq test_global
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $98, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $54, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq test_last
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -8(%rbp), %rax
	pushq %rax
	movq $56, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .main_successCmp_3271
	xorq %rax, %rax
	jmp .main_continueCmp_3272
.main_successCmp_3271:
	movq $1, %rax
.main_continueCmp_3272:
	cmpq $0, %rax
	je .main_failureIf_3274
	movq $.string_1782, %rax
	jmp .main_endIf_3273
.main_failureIf_3274:
	movq $.string_1783, %rax
.main_endIf_3273:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1751, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -8(%rbp), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $56, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1754, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -16(%rbp), %rax
	pushq %rax
	movq $145, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .main_successCmp_3275
	xorq %rax, %rax
	jmp .main_continueCmp_3276
.main_successCmp_3275:
	movq $1, %rax
.main_continueCmp_3276:
	cmpq $0, %rax
	je .main_failureIf_3278
	movq $.string_1782, %rax
	jmp .main_endIf_3277
.main_failureIf_3278:
	movq $.string_1783, %rax
.main_endIf_3277:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1756, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -16(%rbp), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $145, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1759, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -24(%rbp), %rax
	pushq %rax
	movq $0, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .main_successCmp_3279
	xorq %rax, %rax
	jmp .main_continueCmp_3280
.main_successCmp_3279:
	movq $1, %rax
.main_continueCmp_3280:
	cmpq $0, %rax
	je .main_failureIf_3282
	movq $.string_1782, %rax
	jmp .main_endIf_3281
.main_failureIf_3282:
	movq $.string_1783, %rax
.main_endIf_3281:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1761, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -24(%rbp), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $0, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1764, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -40(%rbp), %rax
	pushq %rax
	movq $0, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .main_successCmp_3283
	xorq %rax, %rax
	jmp .main_continueCmp_3284
.main_successCmp_3283:
	movq $1, %rax
.main_continueCmp_3284:
	cmpq $0, %rax
	je .main_failureIf_3286
	movq $.string_1782, %rax
	jmp .main_endIf_3285
.main_failureIf_3286:
	movq $.string_1783, %rax
.main_endIf_3285:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1766, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -40(%rbp), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $0, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1769, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $0, %rax
	pushq %rax
	movq -48(%rbp), %rax
	popq %rcx
	movq $0, %rax
	movq %rax, %rcx
	movq -48(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $8929, %rax
	neg %rax
	popq %rcx
	cmpq %rcx, %rax
	je .main_successCmp_3287
	xorq %rax, %rax
	jmp .main_continueCmp_3288
.main_successCmp_3287:
	movq $1, %rax
.main_continueCmp_3288:
	cmpq $0, %rax
	je .main_failureIf_3290
	movq $.string_1782, %rax
	jmp .main_endIf_3289
.main_failureIf_3290:
	movq $.string_1783, %rax
.main_endIf_3289:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1771, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $0, %rax
	pushq %rax
	movq -48(%rbp), %rax
	popq %rcx
	movq $0, %rax
	movq %rax, %rcx
	movq -48(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $8929, %rax
	neg %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1774, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $1, %rax
	pushq %rax
	movq -48(%rbp), %rax
	popq %rcx
	movq $1, %rax
	movq %rax, %rcx
	movq -48(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $14, %rax
	popq %rcx
	cmpq %rcx, %rax
	je .main_successCmp_3291
	xorq %rax, %rax
	jmp .main_continueCmp_3292
.main_successCmp_3291:
	movq $1, %rax
.main_continueCmp_3292:
	cmpq $0, %rax
	je .main_failureIf_3294
	movq $.string_1782, %rax
	jmp .main_endIf_3293
.main_failureIf_3294:
	movq $.string_1783, %rax
.main_endIf_3293:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1776, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $1, %rax
	pushq %rax
	movq -48(%rbp), %rax
	popq %rcx
	movq $1, %rax
	movq %rax, %rcx
	movq -48(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $14, %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1779, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $2, %rax
	pushq %rax
	movq -48(%rbp), %rax
	popq %rcx
	movq $2, %rax
	movq %rax, %rcx
	movq -48(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax
	movq $56, %rax
	neg %rax
	popq %rcx
	cmpq %rcx, %rax
	je .main_successCmp_3295
	xorq %rax, %rax
	jmp .main_continueCmp_3296
.main_successCmp_3295:
	movq $1, %rax
.main_continueCmp_3296:
	cmpq $0, %rax
	je .main_failureIf_3298
	movq $.string_1782, %rax
	jmp .main_endIf_3297
.main_failureIf_3298:
	movq $.string_1783, %rax
.main_endIf_3297:
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1781, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $2, %rax
	pushq %rax
	movq -48(%rbp), %rax
	popq %rcx
	movq $2, %rax
	movq %rax, %rcx
	movq -48(%rbp), %rdx
	movq (%rdx, %rcx, 8), %rax
	pushq %rax	# putting argument number 3 on the stack
	movq $56, %rax
	neg %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_1784, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	popq %rdx	# putting argument number 3 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_1785, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	movq -48(%rbp), %rax
	cmpq $0, %rax
	je .main_failureIf_3300
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -48(%rbp), %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq free
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	jmp .main_endIf_3299
.main_failureIf_3300:
.main_endIf_3299:
	movq global_5, %rax
	cmpq $0, %rax
	je .main_failureIf_3302
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq global_5, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq free
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	jmp .main_endIf_3301
.main_failureIf_3302:
.main_endIf_3301:
	movq global_6, %rax
	cmpq $0, %rax
	je .main_failureIf_3304
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq global_6, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq free
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	jmp .main_endIf_3303
.main_failureIf_3304:
.main_endIf_3303:
	movq $0, %rax
	jmp .main_endFunction_3270 	# return reached : end function
	addq $48, %rsp
.main_endFunction_3270:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
