.data

.string_90:
	.asciz ""
	.align 8
.string_165:
	.asciz "---------------------------------------------------------\n"
	.align 8
.string_113:
	.asciz "---------------------------------------------------------\n\n\n"
	.align 8
.exception_96:
	.asciz "A"
	.align 8
.exception_92:
	.asciz "B"
	.align 8
.exception_121:
	.asciz "E"
	.align 8
.exception_75:
	.asciz "E1"
	.align 8
.exception_77:
	.asciz "E2"
	.align 8
.exception_87:
	.asciz "E20"
	.align 8
.exception_83:
	.asciz "E3"
	.align 8
.exception_79:
	.asciz "E5"
	.align 8
.exception_43:
	.asciz "Ex"
	.align 8
.exception_45:
	.asciz "Ex1"
	.align 8
.string_112:
	.asciz "Expected succeed : 31\n"
	.align 8
.exception_50:
	.asciz "Stop"
	.align 8
.string_119:
	.asciz "Test : result_call\n"
	.align 8
.string_114:
	.asciz "Test : result_throw\n"
	.align 8
.string_151:
	.asciz "Test : test_b2\n"
	.align 8
.string_154:
	.asciz "Test : test_b3\n"
	.align 8
.string_157:
	.asciz "Test : test_b6\n"
	.align 8
.string_160:
	.asciz "Test : test_b7\n"
	.align 8
.string_145:
	.asciz "Test : test_try_excep_finally_return_handler\n"
	.align 8
.string_142:
	.asciz "Test : test_try_excep_finally_return_no_handler\n"
	.align 8
.string_148:
	.asciz "Test : test_try_excep_in_catch\n"
	.align 8
.string_130:
	.asciz "Test : test_try_no_excep_finally_no_return\n"
	.align 8
.string_133:
	.asciz "Test : test_try_no_excep_finally_return\n"
	.align 8
.string_136:
	.asciz "Test : test_try_no_excep_finally_return_2\n"
	.align 8
.string_139:
	.asciz "Test : test_try_no_excep_finally_return_3\n"
	.align 8
.string_124:
	.asciz "Test : test_try_no_excep_no_finally_no_return\n"
	.align 8
.string_127:
	.asciz "Test : test_try_no_excep_no_finally_return\n"
	.align 8
.string_163:
	.asciz "Test : test_twisted1\n"
	.align 8
.string_111:
	.asciz "Tests set : 16 tests\n"
	.align 8
.exception_103:
	.asciz "Z"
	.align 8
.string_161:
	.asciz "expected : 1\n"
	.align 8
.string_164:
	.asciz "expected : 2\n"
	.align 8
.string_146:
	.asciz "expected : 3\n"
	.align 8
.string_61:
	.asciz "failed, aux_try_excep_finally_return_handler 1\n"
	.align 8
.string_63:
	.asciz "failed, aux_try_excep_finally_return_handler 2\n"
	.align 8
.string_65:
	.asciz "failed, aux_try_excep_finally_return_handler 3\n"
	.align 8
.string_69:
	.asciz "failed, aux_try_excep_finally_return_handler 4\n"
	.align 8
.string_59:
	.asciz "failed, aux_try_excep_finally_return_no_handler 3\n"
	.align 8
.string_74:
	.asciz "failed, aux_try_excep_in_catch 1\n"
	.align 8
.string_76:
	.asciz "failed, aux_try_excep_in_catch 2\n"
	.align 8
.string_78:
	.asciz "failed, aux_try_excep_in_catch 3\n"
	.align 8
.string_82:
	.asciz "failed, aux_try_excep_in_catch 4\n"
	.align 8
.string_84:
	.asciz "failed, aux_try_excep_in_catch 5\n"
	.align 8
.string_85:
	.asciz "failed, aux_try_excep_in_catch 6\n"
	.align 8
.string_86:
	.asciz "failed, aux_try_excep_in_catch 7\n"
	.align 8
.string_35:
	.asciz "failed, aux_try_no_excep_finally_return_2 1\n"
	.align 8
.string_37:
	.asciz "failed, aux_try_no_excep_finally_return_2 2\n"
	.align 8
.string_41:
	.asciz "failed, aux_try_no_excep_finally_return_2 4\n"
	.align 8
.string_44:
	.asciz "failed, aux_try_no_excep_finally_return_3 1\n"
	.align 8
.string_46:
	.asciz "failed, aux_try_no_excep_finally_return_3 2\n"
	.align 8
.string_49:
	.asciz "failed, aux_try_no_excep_finally_return_3 3\n"
	.align 8
.string_52:
	.asciz "failed, aux_try_no_excep_finally_return_3 4\n"
	.align 8
.string_94:
	.asciz "failed, test_b2\n"
	.align 8
.string_98:
	.asciz "failed, test_b3\n"
	.align 8
.string_101:
	.asciz "failed, test_b6 1\n"
	.align 8
.string_102:
	.asciz "failed, test_b6 2\n"
	.align 8
.string_106:
	.asciz "failed, test_b7\n"
	.align 8
.string_3:
	.asciz "failed, test_call\n"
	.align 8
.string_2:
	.asciz "failed, test_throw\n"
	.align 8
.string_72:
	.asciz "failed, test_try_excep_finally_return_handler 5\n"
	.align 8
.string_54:
	.asciz "failed, test_try_excep_finally_return_no_handler 1\n"
	.align 8
.string_56:
	.asciz "failed, test_try_excep_finally_return_no_handler 2\n"
	.align 8
.string_19:
	.asciz "failed, test_try_no_excep_finally_no_return 1\n"
	.align 8
.string_21:
	.asciz "failed, test_try_no_excep_finally_no_return 2\n"
	.align 8
.string_26:
	.asciz "failed, test_try_no_excep_finally_return 2\n"
	.align 8
.string_39:
	.asciz "failed, test_try_no_excep_finally_return 3\n"
	.align 8
.string_30:
	.asciz "failed, test_try_no_excep_finally_return 4\n"
	.align 8
.string_32:
	.asciz "failed, test_try_no_excep_finally_return 5\n"
	.align 8
.string_6:
	.asciz "failed, test_try_no_excep_no_finally_no_return 1\n"
	.align 8
.string_8:
	.asciz "failed, test_try_no_excep_no_finally_no_return 2\n"
	.align 8
.string_11:
	.asciz "failed, test_try_no_excep_no_finally_return 1\n"
	.align 8
.string_13:
	.asciz "failed, test_try_no_excep_no_finally_return 2\n"
	.align 8
.string_14:
	.asciz "failed, test_try_no_excep_no_finally_return 3\n"
	.align 8
.string_16:
	.asciz "failed, test_try_no_excep_no_finally_return 4\n"
	.align 8
.string_109:
	.asciz "failed, test_twisted1\n"
	.align 8
.string_67:
	.asciz "pass, aux_try_excep_finally_return_handler 1\n"
	.align 8
.string_70:
	.asciz "pass, aux_try_excep_finally_return_handler 2\n"
	.align 8
.string_58:
	.asciz "pass, aux_try_excep_finally_return_no_handler 2\n"
	.align 8
.string_80:
	.asciz "pass, aux_try_excep_in_catch 1\n"
	.align 8
.string_88:
	.asciz "pass, aux_try_excep_in_catch 2\n"
	.align 8
.string_33:
	.asciz "pass, aux_try_no_excep_finally_return_2 1\n"
	.align 8
.string_38:
	.asciz "pass, aux_try_no_excep_finally_return_2 2\n"
	.align 8
.string_40:
	.asciz "pass, aux_try_no_excep_finally_return_2 3\n"
	.align 8
.string_42:
	.asciz "pass, aux_try_no_excep_finally_return_3 1\n"
	.align 8
.string_47:
	.asciz "pass, aux_try_no_excep_finally_return_3 2\n"
	.align 8
.string_51:
	.asciz "pass, aux_try_no_excep_finally_return_3 3\n"
	.align 8
.string_122:
	.asciz "pass, result_call\n"
	.align 8
.string_117:
	.asciz "pass, result_throw\n"
	.align 8
.string_93:
	.asciz "pass, test_b2\n"
	.align 8
.string_97:
	.asciz "pass, test_b3\n"
	.align 8
.string_100:
	.asciz "pass, test_b6 1\n"
	.align 8
.string_104:
	.asciz "pass, test_b6 2\n"
	.align 8
.string_105:
	.asciz "pass, test_b7\n"
	.align 8
.string_71:
	.asciz "pass, test_try_excep_finally_return_handler 3\n"
	.align 8
.string_57:
	.asciz "pass, test_try_excep_finally_return_no_handler 1\n"
	.align 8
.string_17:
	.asciz "pass, test_try_no_excep_finally_no_return 1\n"
	.align 8
.string_22:
	.asciz "pass, test_try_no_excep_finally_no_return 2\n"
	.align 8
.string_23:
	.asciz "pass, test_try_no_excep_finally_no_return 3\n"
	.align 8
.string_24:
	.asciz "pass, test_try_no_excep_finally_return 1\n"
	.align 8
.string_29:
	.asciz "pass, test_try_no_excep_finally_return 2\n"
	.align 8
.string_31:
	.asciz "pass, test_try_no_excep_finally_return 3\n"
	.align 8
.string_4:
	.asciz "pass, test_try_no_excep_no_finally_no_return 1\n"
	.align 8
.string_9:
	.asciz "pass, test_try_no_excep_no_finally_no_return 2\n"
	.align 8
.string_15:
	.asciz "pass, test_try_no_excep_no_finally_return 1\n"
	.align 8
.string_107:
	.asciz "pass, test_twisted1 1, %d\n"
	.align 8
.string_108:
	.asciz "pass, test_twisted1 2\n"
	.align 8


.comm .exception_not_caught_166,8,8


.text

	movq $0, .exception_not_caught_166
.globl test_throw
 test_throw:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	movq $1, .exception_not_caught_166
	movq $25, %rax
	movq $.exception_121, %rcx
	movq %rcx, %r12
	movq %rax, %r13
	movq $.test_throwreturnPoint_168, %rbx
	jmp .test_throw_endFunction_167 	# exception thrown 
.test_throwreturnPoint_168: # return from a 'finally' without 'packet'
	movq %r12, %rcx
	movq %r13, %rax
	jmp .test_throw_endFunction_167 	# uncaught exception thrown : end function
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_2, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_throw_endExceptionCaught_169
	jmp .test_throw_endFunction_167	# exception still not caught by the caller
.test_throw_endExceptionCaught_169:
	movq %rax, %r13
	jmp .test_throw_endFunction_167 	# return reached : end function
.test_throw_endFunction_167:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl do_nothing
 do_nothing:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	subq $8, %rsp
	movq $5, %rax
	movq %rax, -8(%rbp)
	movq -8(%rbp), %rax
	movq %rax, %r13
	jmp .do_nothing_endFunction_170 	# return reached : end function
	addq $8, %rsp
.do_nothing_endFunction_170:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl test_call
 test_call:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq test_throw
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_call_endExceptionCaught_172
	jmp .test_call_endFunction_171	# exception still not caught by the caller
.test_call_endExceptionCaught_172:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_3, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_call_endExceptionCaught_173
	jmp .test_call_endFunction_171	# exception still not caught by the caller
.test_call_endExceptionCaught_173:
.test_call_endFunction_171:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl test_try_no_excep_no_finally_no_return
 test_try_no_excep_no_finally_no_return:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	jmp .test_try_no_excep_no_finally_no_returntryBegin_176
.test_try_no_excep_no_finally_no_return_Ex_exception_177:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_6, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_no_finally_no_return_endExceptionCaught_178
	jmp .test_try_no_excep_no_finally_no_return_endFunction_174	# exception still not caught by the caller
.test_try_no_excep_no_finally_no_return_endExceptionCaught_178:
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_no_finally_no_return_endExceptionCaught_179
	jmp .test_try_no_excep_no_finally_no_return_endFunction_174	# exception still not caught by the caller
.test_try_no_excep_no_finally_no_return_endExceptionCaught_179:
	addq $8, %rsp
	jmp .test_try_no_excep_no_finally_no_returntryContinue_175
.test_try_no_excep_no_finally_no_return_Ex1_exception_180:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_8, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_no_finally_no_return_endExceptionCaught_181
	jmp .test_try_no_excep_no_finally_no_return_endFunction_174	# exception still not caught by the caller
.test_try_no_excep_no_finally_no_return_endExceptionCaught_181:
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_no_finally_no_return_endExceptionCaught_182
	jmp .test_try_no_excep_no_finally_no_return_endFunction_174	# exception still not caught by the caller
.test_try_no_excep_no_finally_no_return_endExceptionCaught_182:
	addq $8, %rsp
	jmp .test_try_no_excep_no_finally_no_returntryContinue_175
.test_try_no_excep_no_finally_no_returntryBegin_176:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_no_finally_no_return_endExceptionCaught_183
	movq $.exception_43, %rdx
	cmpq %rcx, %rdx
	je .test_try_no_excep_no_finally_no_return_Ex_exception_177
	movq $.exception_45, %rdx
	cmpq %rcx, %rdx
	je .test_try_no_excep_no_finally_no_return_Ex1_exception_180
	jmp .test_try_no_excep_no_finally_no_return_endFunction_174	# exception still not caught by the caller
.test_try_no_excep_no_finally_no_return_endExceptionCaught_183:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_4, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_no_finally_no_return_endExceptionCaught_184
	movq $.exception_43, %rdx
	cmpq %rcx, %rdx
	je .test_try_no_excep_no_finally_no_return_Ex_exception_177
	movq $.exception_45, %rdx
	cmpq %rcx, %rdx
	je .test_try_no_excep_no_finally_no_return_Ex1_exception_180
	jmp .test_try_no_excep_no_finally_no_return_endFunction_174	# exception still not caught by the caller
.test_try_no_excep_no_finally_no_return_endExceptionCaught_184:
.test_try_no_excep_no_finally_no_returntryContinue_175:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_9, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_no_finally_no_return_endExceptionCaught_185
	jmp .test_try_no_excep_no_finally_no_return_endFunction_174	# exception still not caught by the caller
.test_try_no_excep_no_finally_no_return_endExceptionCaught_185:
.test_try_no_excep_no_finally_no_return_endFunction_174:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl aux_try_no_excep_no_finally_return
 aux_try_no_excep_no_finally_return:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	jmp .aux_try_no_excep_no_finally_returntryBegin_188
.aux_try_no_excep_no_finally_return_Ex_exception_189:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_11, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_no_finally_return_endExceptionCaught_190
	jmp .aux_try_no_excep_no_finally_return_endFunction_186	# exception still not caught by the caller
.aux_try_no_excep_no_finally_return_endExceptionCaught_190:
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_no_finally_return_endExceptionCaught_191
	jmp .aux_try_no_excep_no_finally_return_endFunction_186	# exception still not caught by the caller
.aux_try_no_excep_no_finally_return_endExceptionCaught_191:
	addq $8, %rsp
	jmp .aux_try_no_excep_no_finally_returntryContinue_187
.aux_try_no_excep_no_finally_return_Ex1_exception_192:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_13, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_no_finally_return_endExceptionCaught_193
	jmp .aux_try_no_excep_no_finally_return_endFunction_186	# exception still not caught by the caller
.aux_try_no_excep_no_finally_return_endExceptionCaught_193:
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_no_finally_return_endExceptionCaught_194
	jmp .aux_try_no_excep_no_finally_return_endFunction_186	# exception still not caught by the caller
.aux_try_no_excep_no_finally_return_endExceptionCaught_194:
	addq $8, %rsp
	jmp .aux_try_no_excep_no_finally_returntryContinue_187
.aux_try_no_excep_no_finally_returntryBegin_188:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_no_finally_return_endExceptionCaught_195
	movq $.exception_43, %rdx
	cmpq %rcx, %rdx
	je .aux_try_no_excep_no_finally_return_Ex_exception_189
	movq $.exception_45, %rdx
	cmpq %rcx, %rdx
	je .aux_try_no_excep_no_finally_return_Ex1_exception_192
	jmp .aux_try_no_excep_no_finally_return_endFunction_186	# exception still not caught by the caller
.aux_try_no_excep_no_finally_return_endExceptionCaught_195:
	movq $5, %rax
	movq %rax, %r13
	jmp .aux_try_no_excep_no_finally_return_endFunction_186 	# return reached : end function
.aux_try_no_excep_no_finally_returntryContinue_187:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_14, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_no_finally_return_endExceptionCaught_196
	jmp .aux_try_no_excep_no_finally_return_endFunction_186	# exception still not caught by the caller
.aux_try_no_excep_no_finally_return_endExceptionCaught_196:
.aux_try_no_excep_no_finally_return_endFunction_186:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl test_try_no_excep_no_finally_return
 test_try_no_excep_no_finally_return:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	movq $5, %rax
	pushq %rax
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq aux_try_no_excep_no_finally_return
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_no_finally_return_endExceptionCaught_198
	jmp .test_try_no_excep_no_finally_return_endFunction_197	# exception still not caught by the caller
.test_try_no_excep_no_finally_return_endExceptionCaught_198:
	popq %rcx
	cmpq %rcx, %rax
	je .test_try_no_excep_no_finally_return_successCmp_199
	xorq %rax, %rax
	jmp .test_try_no_excep_no_finally_return_continueCmp_200
.test_try_no_excep_no_finally_return_successCmp_199:
	movq $1, %rax
.test_try_no_excep_no_finally_return_continueCmp_200:
	cmpq $0, %rax
	je .test_try_no_excep_no_finally_return_failureIf_202
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_15, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_no_finally_return_endExceptionCaught_203
	jmp .test_try_no_excep_no_finally_return_endFunction_197	# exception still not caught by the caller
.test_try_no_excep_no_finally_return_endExceptionCaught_203:
	jmp .test_try_no_excep_no_finally_return_endIf_201
.test_try_no_excep_no_finally_return_failureIf_202:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_16, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_no_finally_return_endExceptionCaught_204
	jmp .test_try_no_excep_no_finally_return_endFunction_197	# exception still not caught by the caller
.test_try_no_excep_no_finally_return_endExceptionCaught_204:
.test_try_no_excep_no_finally_return_endIf_201:
.test_try_no_excep_no_finally_return_endFunction_197:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl test_try_no_excep_finally_no_return
 test_try_no_excep_finally_no_return:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	jmp .test_try_no_excep_finally_no_returntryBegin_207
.test_try_no_excep_finally_no_returnfinally_208:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_finally_no_return_endExceptionCaught_209
	jmp .test_try_no_excep_finally_no_return_endFunction_205	# exception still not caught by the caller
.test_try_no_excep_finally_no_return_endExceptionCaught_209:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_22, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_finally_no_return_endExceptionCaught_210
	jmp .test_try_no_excep_finally_no_return_endFunction_205	# exception still not caught by the caller
.test_try_no_excep_finally_no_return_endExceptionCaught_210:
	jmp *%rbx
.test_try_no_excep_finally_no_return_Ex_exception_211:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_19, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_finally_no_return_endExceptionCaught_212
	jmp .test_try_no_excep_finally_no_return_endFunction_205	# exception still not caught by the caller
.test_try_no_excep_finally_no_return_endExceptionCaught_212:
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_finally_no_return_endExceptionCaught_213
	jmp .test_try_no_excep_finally_no_return_endFunction_205	# exception still not caught by the caller
.test_try_no_excep_finally_no_return_endExceptionCaught_213:
	addq $8, %rsp
	movq $.test_try_no_excep_finally_no_returntryContinue_206, %rbx
	jmp .test_try_no_excep_finally_no_returnfinally_208
.test_try_no_excep_finally_no_return_Ex1_exception_214:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_21, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_finally_no_return_endExceptionCaught_215
	jmp .test_try_no_excep_finally_no_return_endFunction_205	# exception still not caught by the caller
.test_try_no_excep_finally_no_return_endExceptionCaught_215:
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_finally_no_return_endExceptionCaught_216
	jmp .test_try_no_excep_finally_no_return_endFunction_205	# exception still not caught by the caller
.test_try_no_excep_finally_no_return_endExceptionCaught_216:
	addq $8, %rsp
	movq $.test_try_no_excep_finally_no_returntryContinue_206, %rbx
	jmp .test_try_no_excep_finally_no_returnfinally_208
.test_try_no_excep_finally_no_returntryBegin_207:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_finally_no_return_endExceptionCaught_217
	movq $.exception_43, %rdx
	cmpq %rcx, %rdx
	je .test_try_no_excep_finally_no_return_Ex_exception_211
	movq $.exception_45, %rdx
	cmpq %rcx, %rdx
	je .test_try_no_excep_finally_no_return_Ex1_exception_214
	movq $.test_try_no_excep_finally_no_returnreturnPoint_218, %rbx
	jmp .test_try_no_excep_finally_no_returnfinally_208
.test_try_no_excep_finally_no_returnreturnPoint_218: # return from a 'finally' without 'packet'
	jmp .test_try_no_excep_finally_no_return_endFunction_205	# exception still not caught by the caller
.test_try_no_excep_finally_no_return_endExceptionCaught_217:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_17, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_finally_no_return_endExceptionCaught_219
	movq $.exception_43, %rdx
	cmpq %rcx, %rdx
	je .test_try_no_excep_finally_no_return_Ex_exception_211
	movq $.exception_45, %rdx
	cmpq %rcx, %rdx
	je .test_try_no_excep_finally_no_return_Ex1_exception_214
	movq $.test_try_no_excep_finally_no_returnreturnPoint_220, %rbx
	jmp .test_try_no_excep_finally_no_returnfinally_208
.test_try_no_excep_finally_no_returnreturnPoint_220: # return from a 'finally' without 'packet'
	jmp .test_try_no_excep_finally_no_return_endFunction_205	# exception still not caught by the caller
.test_try_no_excep_finally_no_return_endExceptionCaught_219:
	movq $.test_try_no_excep_finally_no_returntryContinue_206, %rbx
	jmp .test_try_no_excep_finally_no_returnfinally_208
.test_try_no_excep_finally_no_returntryContinue_206:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_23, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_finally_no_return_endExceptionCaught_221
	jmp .test_try_no_excep_finally_no_return_endFunction_205	# exception still not caught by the caller
.test_try_no_excep_finally_no_return_endExceptionCaught_221:
.test_try_no_excep_finally_no_return_endFunction_205:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl aux_try_no_excep_finally_return
 aux_try_no_excep_finally_return:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	jmp .aux_try_no_excep_finally_returntryBegin_224
.aux_try_no_excep_finally_returnfinally_225:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_endExceptionCaught_226
	jmp .aux_try_no_excep_finally_return_endFunction_222	# exception still not caught by the caller
.aux_try_no_excep_finally_return_endExceptionCaught_226:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_29, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_endExceptionCaught_227
	jmp .aux_try_no_excep_finally_return_endFunction_222	# exception still not caught by the caller
.aux_try_no_excep_finally_return_endExceptionCaught_227:
	jmp *%rbx
.aux_try_no_excep_finally_return_Ex_exception_228:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_26, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_endExceptionCaught_229
	jmp .aux_try_no_excep_finally_return_endFunction_222	# exception still not caught by the caller
.aux_try_no_excep_finally_return_endExceptionCaught_229:
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_endExceptionCaught_230
	jmp .aux_try_no_excep_finally_return_endFunction_222	# exception still not caught by the caller
.aux_try_no_excep_finally_return_endExceptionCaught_230:
	addq $8, %rsp
	movq $.aux_try_no_excep_finally_returntryContinue_223, %rbx
	jmp .aux_try_no_excep_finally_returnfinally_225
.aux_try_no_excep_finally_return_Ex1_exception_231:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_39, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_endExceptionCaught_232
	jmp .aux_try_no_excep_finally_return_endFunction_222	# exception still not caught by the caller
.aux_try_no_excep_finally_return_endExceptionCaught_232:
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_endExceptionCaught_233
	jmp .aux_try_no_excep_finally_return_endFunction_222	# exception still not caught by the caller
.aux_try_no_excep_finally_return_endExceptionCaught_233:
	addq $8, %rsp
	movq $.aux_try_no_excep_finally_returntryContinue_223, %rbx
	jmp .aux_try_no_excep_finally_returnfinally_225
.aux_try_no_excep_finally_returntryBegin_224:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_endExceptionCaught_234
	movq $.exception_43, %rdx
	cmpq %rcx, %rdx
	je .aux_try_no_excep_finally_return_Ex_exception_228
	movq $.exception_45, %rdx
	cmpq %rcx, %rdx
	je .aux_try_no_excep_finally_return_Ex1_exception_231
	movq $.aux_try_no_excep_finally_returnreturnPoint_235, %rbx
	jmp .aux_try_no_excep_finally_returnfinally_225
.aux_try_no_excep_finally_returnreturnPoint_235: # return from a 'finally' without 'packet'
	jmp .aux_try_no_excep_finally_return_endFunction_222	# exception still not caught by the caller
.aux_try_no_excep_finally_return_endExceptionCaught_234:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_24, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_endExceptionCaught_236
	movq $.exception_43, %rdx
	cmpq %rcx, %rdx
	je .aux_try_no_excep_finally_return_Ex_exception_228
	movq $.exception_45, %rdx
	cmpq %rcx, %rdx
	je .aux_try_no_excep_finally_return_Ex1_exception_231
	movq $.aux_try_no_excep_finally_returnreturnPoint_237, %rbx
	jmp .aux_try_no_excep_finally_returnfinally_225
.aux_try_no_excep_finally_returnreturnPoint_237: # return from a 'finally' without 'packet'
	jmp .aux_try_no_excep_finally_return_endFunction_222	# exception still not caught by the caller
.aux_try_no_excep_finally_return_endExceptionCaught_236:
	movq $5, %rax
	movq %rax, %r13
	movq $.aux_try_no_excep_finally_returnreturnPoint_238, %rbx
	jmp .aux_try_no_excep_finally_returnfinally_225
.aux_try_no_excep_finally_returnreturnPoint_238: # return from a 'finally' without 'packet'
	movq %r13, %rax
	jmp .aux_try_no_excep_finally_return_endFunction_222 	# return reached : end function
	movq $.aux_try_no_excep_finally_returntryContinue_223, %rbx
	jmp .aux_try_no_excep_finally_returnfinally_225
.aux_try_no_excep_finally_returntryContinue_223:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_30, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_endExceptionCaught_239
	jmp .aux_try_no_excep_finally_return_endFunction_222	# exception still not caught by the caller
.aux_try_no_excep_finally_return_endExceptionCaught_239:
	movq $0, %rax
	movq %rax, %r13
	jmp .aux_try_no_excep_finally_return_endFunction_222 	# return reached : end function
.aux_try_no_excep_finally_return_endFunction_222:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl test_try_no_excep_finally_return
 test_try_no_excep_finally_return:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	movq $5, %rax
	pushq %rax
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq aux_try_no_excep_finally_return
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_finally_return_endExceptionCaught_241
	jmp .test_try_no_excep_finally_return_endFunction_240	# exception still not caught by the caller
.test_try_no_excep_finally_return_endExceptionCaught_241:
	popq %rcx
	cmpq %rcx, %rax
	je .test_try_no_excep_finally_return_successCmp_242
	xorq %rax, %rax
	jmp .test_try_no_excep_finally_return_continueCmp_243
.test_try_no_excep_finally_return_successCmp_242:
	movq $1, %rax
.test_try_no_excep_finally_return_continueCmp_243:
	cmpq $0, %rax
	je .test_try_no_excep_finally_return_failureIf_245
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_31, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_finally_return_endExceptionCaught_246
	jmp .test_try_no_excep_finally_return_endFunction_240	# exception still not caught by the caller
.test_try_no_excep_finally_return_endExceptionCaught_246:
	jmp .test_try_no_excep_finally_return_endIf_244
.test_try_no_excep_finally_return_failureIf_245:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_32, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_finally_return_endExceptionCaught_247
	jmp .test_try_no_excep_finally_return_endFunction_240	# exception still not caught by the caller
.test_try_no_excep_finally_return_endExceptionCaught_247:
.test_try_no_excep_finally_return_endIf_244:
.test_try_no_excep_finally_return_endFunction_240:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl aux_try_no_excep_finally_return_2
 aux_try_no_excep_finally_return_2:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	jmp .aux_try_no_excep_finally_return_2tryBegin_250
.aux_try_no_excep_finally_return_2finally_251:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_2_endExceptionCaught_252
	jmp .aux_try_no_excep_finally_return_2_endFunction_248	# exception still not caught by the caller
.aux_try_no_excep_finally_return_2_endExceptionCaught_252:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_38, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_2_endExceptionCaught_253
	jmp .aux_try_no_excep_finally_return_2_endFunction_248	# exception still not caught by the caller
.aux_try_no_excep_finally_return_2_endExceptionCaught_253:
	movq $0, .exception_not_caught_166
	movq $3, %rax
	movq %rax, %r13
	jmp .aux_try_no_excep_finally_return_2_endFunction_248 	# return reached : end function
	jmp *%rbx
.aux_try_no_excep_finally_return_2_Ex_exception_254:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_35, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_2_endExceptionCaught_255
	jmp .aux_try_no_excep_finally_return_2_endFunction_248	# exception still not caught by the caller
.aux_try_no_excep_finally_return_2_endExceptionCaught_255:
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_2_endExceptionCaught_256
	jmp .aux_try_no_excep_finally_return_2_endFunction_248	# exception still not caught by the caller
.aux_try_no_excep_finally_return_2_endExceptionCaught_256:
	addq $8, %rsp
	movq $.aux_try_no_excep_finally_return_2tryContinue_249, %rbx
	jmp .aux_try_no_excep_finally_return_2finally_251
.aux_try_no_excep_finally_return_2_Ex1_exception_257:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_37, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_2_endExceptionCaught_258
	jmp .aux_try_no_excep_finally_return_2_endFunction_248	# exception still not caught by the caller
.aux_try_no_excep_finally_return_2_endExceptionCaught_258:
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_2_endExceptionCaught_259
	jmp .aux_try_no_excep_finally_return_2_endFunction_248	# exception still not caught by the caller
.aux_try_no_excep_finally_return_2_endExceptionCaught_259:
	addq $8, %rsp
	movq $.aux_try_no_excep_finally_return_2tryContinue_249, %rbx
	jmp .aux_try_no_excep_finally_return_2finally_251
.aux_try_no_excep_finally_return_2tryBegin_250:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_2_endExceptionCaught_260
	movq $.exception_43, %rdx
	cmpq %rcx, %rdx
	je .aux_try_no_excep_finally_return_2_Ex_exception_254
	movq $.exception_45, %rdx
	cmpq %rcx, %rdx
	je .aux_try_no_excep_finally_return_2_Ex1_exception_257
	movq $.aux_try_no_excep_finally_return_2returnPoint_261, %rbx
	jmp .aux_try_no_excep_finally_return_2finally_251
.aux_try_no_excep_finally_return_2returnPoint_261: # return from a 'finally' without 'packet'
	jmp .aux_try_no_excep_finally_return_2_endFunction_248	# exception still not caught by the caller
.aux_try_no_excep_finally_return_2_endExceptionCaught_260:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_33, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_2_endExceptionCaught_262
	movq $.exception_43, %rdx
	cmpq %rcx, %rdx
	je .aux_try_no_excep_finally_return_2_Ex_exception_254
	movq $.exception_45, %rdx
	cmpq %rcx, %rdx
	je .aux_try_no_excep_finally_return_2_Ex1_exception_257
	movq $.aux_try_no_excep_finally_return_2returnPoint_263, %rbx
	jmp .aux_try_no_excep_finally_return_2finally_251
.aux_try_no_excep_finally_return_2returnPoint_263: # return from a 'finally' without 'packet'
	jmp .aux_try_no_excep_finally_return_2_endFunction_248	# exception still not caught by the caller
.aux_try_no_excep_finally_return_2_endExceptionCaught_262:
	movq $5, %rax
	movq %rax, %r13
	movq $.aux_try_no_excep_finally_return_2returnPoint_264, %rbx
	jmp .aux_try_no_excep_finally_return_2finally_251
.aux_try_no_excep_finally_return_2returnPoint_264: # return from a 'finally' without 'packet'
	movq %r13, %rax
	jmp .aux_try_no_excep_finally_return_2_endFunction_248 	# return reached : end function
	movq $.aux_try_no_excep_finally_return_2tryContinue_249, %rbx
	jmp .aux_try_no_excep_finally_return_2finally_251
.aux_try_no_excep_finally_return_2tryContinue_249:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_39, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_2_endExceptionCaught_265
	jmp .aux_try_no_excep_finally_return_2_endFunction_248	# exception still not caught by the caller
.aux_try_no_excep_finally_return_2_endExceptionCaught_265:
	movq $0, %rax
	movq %rax, %r13
	jmp .aux_try_no_excep_finally_return_2_endFunction_248 	# return reached : end function
.aux_try_no_excep_finally_return_2_endFunction_248:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl test_try_no_excep_finally_return_2
 test_try_no_excep_finally_return_2:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	movq $3, %rax
	pushq %rax
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq aux_try_no_excep_finally_return_2
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_finally_return_2_endExceptionCaught_267
	jmp .test_try_no_excep_finally_return_2_endFunction_266	# exception still not caught by the caller
.test_try_no_excep_finally_return_2_endExceptionCaught_267:
	popq %rcx
	cmpq %rcx, %rax
	je .test_try_no_excep_finally_return_2_successCmp_268
	xorq %rax, %rax
	jmp .test_try_no_excep_finally_return_2_continueCmp_269
.test_try_no_excep_finally_return_2_successCmp_268:
	movq $1, %rax
.test_try_no_excep_finally_return_2_continueCmp_269:
	cmpq $0, %rax
	je .test_try_no_excep_finally_return_2_failureIf_271
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_40, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_finally_return_2_endExceptionCaught_272
	jmp .test_try_no_excep_finally_return_2_endFunction_266	# exception still not caught by the caller
.test_try_no_excep_finally_return_2_endExceptionCaught_272:
	jmp .test_try_no_excep_finally_return_2_endIf_270
.test_try_no_excep_finally_return_2_failureIf_271:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_41, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_finally_return_2_endExceptionCaught_273
	jmp .test_try_no_excep_finally_return_2_endFunction_266	# exception still not caught by the caller
.test_try_no_excep_finally_return_2_endExceptionCaught_273:
.test_try_no_excep_finally_return_2_endIf_270:
.test_try_no_excep_finally_return_2_endFunction_266:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl aux_try_no_excep_finally_return_3
 aux_try_no_excep_finally_return_3:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	jmp .aux_try_no_excep_finally_return_3tryBegin_276
.aux_try_no_excep_finally_return_3finally_277:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_3_endExceptionCaught_278
	jmp .aux_try_no_excep_finally_return_3_endFunction_274	# exception still not caught by the caller
.aux_try_no_excep_finally_return_3_endExceptionCaught_278:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_47, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_3_endExceptionCaught_279
	jmp .aux_try_no_excep_finally_return_3_endFunction_274	# exception still not caught by the caller
.aux_try_no_excep_finally_return_3_endExceptionCaught_279:
	movq $1, .exception_not_caught_166
	movq $0, %rax
	movq $.exception_50, %rcx
	movq %rcx, %r12
	movq %rax, %r13
	movq $.aux_try_no_excep_finally_return_3returnPoint_280, %rbx
	jmp .aux_try_no_excep_finally_return_3_endFunction_274 	# exception thrown 
.aux_try_no_excep_finally_return_3returnPoint_280: # return from a 'finally' without 'packet'
	movq %r12, %rcx
	movq %r13, %rax
	jmp .aux_try_no_excep_finally_return_3_endFunction_274 	# uncaught exception thrown : end function
	jmp *%rbx
.aux_try_no_excep_finally_return_3_Ex_exception_281:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_44, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_3_endExceptionCaught_282
	jmp .aux_try_no_excep_finally_return_3_endFunction_274	# exception still not caught by the caller
.aux_try_no_excep_finally_return_3_endExceptionCaught_282:
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_3_endExceptionCaught_283
	jmp .aux_try_no_excep_finally_return_3_endFunction_274	# exception still not caught by the caller
.aux_try_no_excep_finally_return_3_endExceptionCaught_283:
	addq $8, %rsp
	movq $.aux_try_no_excep_finally_return_3tryContinue_275, %rbx
	jmp .aux_try_no_excep_finally_return_3finally_277
.aux_try_no_excep_finally_return_3_Ex1_exception_284:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_46, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_3_endExceptionCaught_285
	jmp .aux_try_no_excep_finally_return_3_endFunction_274	# exception still not caught by the caller
.aux_try_no_excep_finally_return_3_endExceptionCaught_285:
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_3_endExceptionCaught_286
	jmp .aux_try_no_excep_finally_return_3_endFunction_274	# exception still not caught by the caller
.aux_try_no_excep_finally_return_3_endExceptionCaught_286:
	addq $8, %rsp
	movq $.aux_try_no_excep_finally_return_3tryContinue_275, %rbx
	jmp .aux_try_no_excep_finally_return_3finally_277
.aux_try_no_excep_finally_return_3tryBegin_276:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_3_endExceptionCaught_287
	movq $.exception_43, %rdx
	cmpq %rcx, %rdx
	je .aux_try_no_excep_finally_return_3_Ex_exception_281
	movq $.exception_45, %rdx
	cmpq %rcx, %rdx
	je .aux_try_no_excep_finally_return_3_Ex1_exception_284
	movq $.aux_try_no_excep_finally_return_3returnPoint_288, %rbx
	jmp .aux_try_no_excep_finally_return_3finally_277
.aux_try_no_excep_finally_return_3returnPoint_288: # return from a 'finally' without 'packet'
	jmp .aux_try_no_excep_finally_return_3_endFunction_274	# exception still not caught by the caller
.aux_try_no_excep_finally_return_3_endExceptionCaught_287:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_42, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_3_endExceptionCaught_289
	movq $.exception_43, %rdx
	cmpq %rcx, %rdx
	je .aux_try_no_excep_finally_return_3_Ex_exception_281
	movq $.exception_45, %rdx
	cmpq %rcx, %rdx
	je .aux_try_no_excep_finally_return_3_Ex1_exception_284
	movq $.aux_try_no_excep_finally_return_3returnPoint_290, %rbx
	jmp .aux_try_no_excep_finally_return_3finally_277
.aux_try_no_excep_finally_return_3returnPoint_290: # return from a 'finally' without 'packet'
	jmp .aux_try_no_excep_finally_return_3_endFunction_274	# exception still not caught by the caller
.aux_try_no_excep_finally_return_3_endExceptionCaught_289:
	movq $5, %rax
	movq %rax, %r13
	movq $.aux_try_no_excep_finally_return_3returnPoint_291, %rbx
	jmp .aux_try_no_excep_finally_return_3finally_277
.aux_try_no_excep_finally_return_3returnPoint_291: # return from a 'finally' without 'packet'
	movq %r13, %rax
	jmp .aux_try_no_excep_finally_return_3_endFunction_274 	# return reached : end function
	movq $.aux_try_no_excep_finally_return_3tryContinue_275, %rbx
	jmp .aux_try_no_excep_finally_return_3finally_277
.aux_try_no_excep_finally_return_3tryContinue_275:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_49, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_3_endExceptionCaught_292
	jmp .aux_try_no_excep_finally_return_3_endFunction_274	# exception still not caught by the caller
.aux_try_no_excep_finally_return_3_endExceptionCaught_292:
	movq $0, %rax
	movq %rax, %r13
	jmp .aux_try_no_excep_finally_return_3_endFunction_274 	# return reached : end function
.aux_try_no_excep_finally_return_3_endFunction_274:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl test_try_no_excep_finally_return_3
 test_try_no_excep_finally_return_3:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	jmp .test_try_no_excep_finally_return_3tryBegin_295
.test_try_no_excep_finally_return_3_Stop_exception_296:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_51, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_finally_return_3_endExceptionCaught_297
	jmp .test_try_no_excep_finally_return_3_endFunction_293	# exception still not caught by the caller
.test_try_no_excep_finally_return_3_endExceptionCaught_297:
	movq $0, %rax
	movq %rax, %r13
	jmp .test_try_no_excep_finally_return_3_endFunction_293 	# return reached : end function
	addq $8, %rsp
	jmp .test_try_no_excep_finally_return_3tryContinue_294
.test_try_no_excep_finally_return_3tryBegin_295:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq aux_try_no_excep_finally_return_3
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_finally_return_3_endExceptionCaught_298
	movq $.exception_50, %rdx
	cmpq %rcx, %rdx
	je .test_try_no_excep_finally_return_3_Stop_exception_296
	jmp .test_try_no_excep_finally_return_3_endFunction_293	# exception still not caught by the caller
.test_try_no_excep_finally_return_3_endExceptionCaught_298:
.test_try_no_excep_finally_return_3tryContinue_294:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_52, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_finally_return_3_endExceptionCaught_299
	jmp .test_try_no_excep_finally_return_3_endFunction_293	# exception still not caught by the caller
.test_try_no_excep_finally_return_3_endExceptionCaught_299:
.test_try_no_excep_finally_return_3_endFunction_293:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl aux_try_excep_finally_return_no_handler
 aux_try_excep_finally_return_no_handler:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	jmp .aux_try_excep_finally_return_no_handlertryBegin_302
.aux_try_excep_finally_return_no_handlerfinally_303:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_57, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_finally_return_no_handler_endExceptionCaught_304
	jmp .aux_try_excep_finally_return_no_handler_endFunction_300	# exception still not caught by the caller
.aux_try_excep_finally_return_no_handler_endExceptionCaught_304:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_finally_return_no_handler_endExceptionCaught_305
	jmp .aux_try_excep_finally_return_no_handler_endFunction_300	# exception still not caught by the caller
.aux_try_excep_finally_return_no_handler_endExceptionCaught_305:
	movq $0, .exception_not_caught_166
	movq $9, %rax
	movq %rax, %r13
	jmp .aux_try_excep_finally_return_no_handler_endFunction_300 	# return reached : end function
	jmp *%rbx
.aux_try_excep_finally_return_no_handler_E2_exception_306:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_finally_return_no_handler_endExceptionCaught_307
	jmp .aux_try_excep_finally_return_no_handler_endFunction_300	# exception still not caught by the caller
.aux_try_excep_finally_return_no_handler_endExceptionCaught_307:
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_56, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_finally_return_no_handler_endExceptionCaught_308
	jmp .aux_try_excep_finally_return_no_handler_endFunction_300	# exception still not caught by the caller
.aux_try_excep_finally_return_no_handler_endExceptionCaught_308:
	addq $8, %rsp
	movq $.aux_try_excep_finally_return_no_handlertryContinue_301, %rbx
	jmp .aux_try_excep_finally_return_no_handlerfinally_303
.aux_try_excep_finally_return_no_handlertryBegin_302:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_finally_return_no_handler_endExceptionCaught_309
	movq $.exception_77, %rdx
	cmpq %rcx, %rdx
	je .aux_try_excep_finally_return_no_handler_E2_exception_306
	movq $.aux_try_excep_finally_return_no_handlerreturnPoint_310, %rbx
	jmp .aux_try_excep_finally_return_no_handlerfinally_303
.aux_try_excep_finally_return_no_handlerreturnPoint_310: # return from a 'finally' without 'packet'
	jmp .aux_try_excep_finally_return_no_handler_endFunction_300	# exception still not caught by the caller
.aux_try_excep_finally_return_no_handler_endExceptionCaught_309:
	movq $1, .exception_not_caught_166
	movq $5, %rax
	movq $.exception_75, %rcx
	movq %rcx, %r12
	movq %rax, %r13
	movq $.aux_try_excep_finally_return_no_handlerreturnPoint_311, %rbx
	jmp .aux_try_excep_finally_return_no_handlerfinally_303 	# exception thrown 
.aux_try_excep_finally_return_no_handlerreturnPoint_311: # return from a 'finally' without 'packet'
	movq %r12, %rcx
	movq %r13, %rax
	jmp .aux_try_excep_finally_return_no_handler_endFunction_300 	# uncaught exception thrown : end function
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_54, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_finally_return_no_handler_endExceptionCaught_312
	movq $.exception_77, %rdx
	cmpq %rcx, %rdx
	je .aux_try_excep_finally_return_no_handler_E2_exception_306
	movq $.aux_try_excep_finally_return_no_handlerreturnPoint_313, %rbx
	jmp .aux_try_excep_finally_return_no_handlerfinally_303
.aux_try_excep_finally_return_no_handlerreturnPoint_313: # return from a 'finally' without 'packet'
	jmp .aux_try_excep_finally_return_no_handler_endFunction_300	# exception still not caught by the caller
.aux_try_excep_finally_return_no_handler_endExceptionCaught_312:
	movq $1, %rax
	movq %rax, %r13
	movq $.aux_try_excep_finally_return_no_handlerreturnPoint_314, %rbx
	jmp .aux_try_excep_finally_return_no_handlerfinally_303
.aux_try_excep_finally_return_no_handlerreturnPoint_314: # return from a 'finally' without 'packet'
	movq %r13, %rax
	jmp .aux_try_excep_finally_return_no_handler_endFunction_300 	# return reached : end function
	movq $.aux_try_excep_finally_return_no_handlertryContinue_301, %rbx
	jmp .aux_try_excep_finally_return_no_handlerfinally_303
.aux_try_excep_finally_return_no_handlertryContinue_301:
	movq $1, %rax
	neg %rax
	movq %rax, %r13
	jmp .aux_try_excep_finally_return_no_handler_endFunction_300 	# return reached : end function
.aux_try_excep_finally_return_no_handler_endFunction_300:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl test_try_excep_finally_return_no_handler
 test_try_excep_finally_return_no_handler:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	movq $9, %rax
	pushq %rax
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq aux_try_excep_finally_return_no_handler
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .test_try_excep_finally_return_no_handler_endExceptionCaught_316
	jmp .test_try_excep_finally_return_no_handler_endFunction_315	# exception still not caught by the caller
.test_try_excep_finally_return_no_handler_endExceptionCaught_316:
	popq %rcx
	cmpq %rcx, %rax
	je .test_try_excep_finally_return_no_handler_successCmp_317
	xorq %rax, %rax
	jmp .test_try_excep_finally_return_no_handler_continueCmp_318
.test_try_excep_finally_return_no_handler_successCmp_317:
	movq $1, %rax
.test_try_excep_finally_return_no_handler_continueCmp_318:
	cmpq $0, %rax
	je .test_try_excep_finally_return_no_handler_failureIf_320
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_58, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_try_excep_finally_return_no_handler_endExceptionCaught_321
	jmp .test_try_excep_finally_return_no_handler_endFunction_315	# exception still not caught by the caller
.test_try_excep_finally_return_no_handler_endExceptionCaught_321:
	jmp .test_try_excep_finally_return_no_handler_endIf_319
.test_try_excep_finally_return_no_handler_failureIf_320:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_59, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_try_excep_finally_return_no_handler_endExceptionCaught_322
	jmp .test_try_excep_finally_return_no_handler_endFunction_315	# exception still not caught by the caller
.test_try_excep_finally_return_no_handler_endExceptionCaught_322:
.test_try_excep_finally_return_no_handler_endIf_319:
.test_try_excep_finally_return_no_handler_endFunction_315:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl aux_try_excep_finally_return_handler
 aux_try_excep_finally_return_handler:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	jmp .aux_try_excep_finally_return_handlertryBegin_325
.aux_try_excep_finally_return_handlerfinally_326:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_70, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_finally_return_handler_endExceptionCaught_327
	jmp .aux_try_excep_finally_return_handler_endFunction_323	# exception still not caught by the caller
.aux_try_excep_finally_return_handler_endExceptionCaught_327:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_finally_return_handler_endExceptionCaught_328
	jmp .aux_try_excep_finally_return_handler_endFunction_323	# exception still not caught by the caller
.aux_try_excep_finally_return_handler_endExceptionCaught_328:
	jmp *%rbx
.aux_try_excep_finally_return_handler_E1_exception_329:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_finally_return_handler_endExceptionCaught_330
	jmp .aux_try_excep_finally_return_handler_endFunction_323	# exception still not caught by the caller
.aux_try_excep_finally_return_handler_endExceptionCaught_330:
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_63, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_finally_return_handler_endExceptionCaught_331
	jmp .aux_try_excep_finally_return_handler_endFunction_323	# exception still not caught by the caller
.aux_try_excep_finally_return_handler_endExceptionCaught_331:
	addq $8, %rsp
	movq $.aux_try_excep_finally_return_handlertryContinue_324, %rbx
	jmp .aux_try_excep_finally_return_handlerfinally_326
.aux_try_excep_finally_return_handler_E2_exception_332:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_finally_return_handler_endExceptionCaught_333
	jmp .aux_try_excep_finally_return_handler_endFunction_323	# exception still not caught by the caller
.aux_try_excep_finally_return_handler_endExceptionCaught_333:
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_65, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_finally_return_handler_endExceptionCaught_334
	jmp .aux_try_excep_finally_return_handler_endFunction_323	# exception still not caught by the caller
.aux_try_excep_finally_return_handler_endExceptionCaught_334:
	addq $8, %rsp
	movq $.aux_try_excep_finally_return_handlertryContinue_324, %rbx
	jmp .aux_try_excep_finally_return_handlerfinally_326
.aux_try_excep_finally_return_handler_E5_exception_335:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_finally_return_handler_endExceptionCaught_336
	jmp .aux_try_excep_finally_return_handler_endFunction_323	# exception still not caught by the caller
.aux_try_excep_finally_return_handler_endExceptionCaught_336:
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_67, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_finally_return_handler_endExceptionCaught_337
	jmp .aux_try_excep_finally_return_handler_endFunction_323	# exception still not caught by the caller
.aux_try_excep_finally_return_handler_endExceptionCaught_337:
	addq $8, %rsp
	movq $.aux_try_excep_finally_return_handlertryContinue_324, %rbx
	jmp .aux_try_excep_finally_return_handlerfinally_326
.aux_try_excep_finally_return_handler_E3_exception_338:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_finally_return_handler_endExceptionCaught_339
	jmp .aux_try_excep_finally_return_handler_endFunction_323	# exception still not caught by the caller
.aux_try_excep_finally_return_handler_endExceptionCaught_339:
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_69, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_finally_return_handler_endExceptionCaught_340
	jmp .aux_try_excep_finally_return_handler_endFunction_323	# exception still not caught by the caller
.aux_try_excep_finally_return_handler_endExceptionCaught_340:
	addq $8, %rsp
	movq $.aux_try_excep_finally_return_handlertryContinue_324, %rbx
	jmp .aux_try_excep_finally_return_handlerfinally_326
.aux_try_excep_finally_return_handlertryBegin_325:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_finally_return_handler_endExceptionCaught_341
	movq $.exception_75, %rdx
	cmpq %rcx, %rdx
	je .aux_try_excep_finally_return_handler_E1_exception_329
	movq $.exception_77, %rdx
	cmpq %rcx, %rdx
	je .aux_try_excep_finally_return_handler_E2_exception_332
	movq $.exception_83, %rdx
	cmpq %rcx, %rdx
	je .aux_try_excep_finally_return_handler_E3_exception_338
	movq $.exception_79, %rdx
	cmpq %rcx, %rdx
	je .aux_try_excep_finally_return_handler_E5_exception_335
	movq $.aux_try_excep_finally_return_handlerreturnPoint_342, %rbx
	jmp .aux_try_excep_finally_return_handlerfinally_326
.aux_try_excep_finally_return_handlerreturnPoint_342: # return from a 'finally' without 'packet'
	jmp .aux_try_excep_finally_return_handler_endFunction_323	# exception still not caught by the caller
.aux_try_excep_finally_return_handler_endExceptionCaught_341:
	movq $0, .exception_not_caught_166
	movq $5, %rax
	movq $.exception_79, %rcx
	movq %rcx, %r12
	movq %rax, %r13
	movq $.aux_try_excep_finally_return_handlerreturnPoint_343, %rbx
	jmp .aux_try_excep_finally_return_handler_E5_exception_335 	# exception thrown 
.aux_try_excep_finally_return_handlerreturnPoint_343: # return from a 'finally' without 'packet'
	movq %r12, %rcx
	movq %r13, %rax
	jmp .aux_try_excep_finally_return_handler_endFunction_323 	# uncaught exception thrown : end function
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_61, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_finally_return_handler_endExceptionCaught_344
	movq $.exception_75, %rdx
	cmpq %rcx, %rdx
	je .aux_try_excep_finally_return_handler_E1_exception_329
	movq $.exception_77, %rdx
	cmpq %rcx, %rdx
	je .aux_try_excep_finally_return_handler_E2_exception_332
	movq $.exception_83, %rdx
	cmpq %rcx, %rdx
	je .aux_try_excep_finally_return_handler_E3_exception_338
	movq $.exception_79, %rdx
	cmpq %rcx, %rdx
	je .aux_try_excep_finally_return_handler_E5_exception_335
	movq $.aux_try_excep_finally_return_handlerreturnPoint_345, %rbx
	jmp .aux_try_excep_finally_return_handlerfinally_326
.aux_try_excep_finally_return_handlerreturnPoint_345: # return from a 'finally' without 'packet'
	jmp .aux_try_excep_finally_return_handler_endFunction_323	# exception still not caught by the caller
.aux_try_excep_finally_return_handler_endExceptionCaught_344:
	movq $5, %rax
	movq %rax, %r13
	movq $.aux_try_excep_finally_return_handlerreturnPoint_346, %rbx
	jmp .aux_try_excep_finally_return_handlerfinally_326
.aux_try_excep_finally_return_handlerreturnPoint_346: # return from a 'finally' without 'packet'
	movq %r13, %rax
	jmp .aux_try_excep_finally_return_handler_endFunction_323 	# return reached : end function
	movq $.aux_try_excep_finally_return_handlertryContinue_324, %rbx
	jmp .aux_try_excep_finally_return_handlerfinally_326
.aux_try_excep_finally_return_handlertryContinue_324:
	movq $1, %rax
	neg %rax
	movq %rax, %r13
	jmp .aux_try_excep_finally_return_handler_endFunction_323 	# return reached : end function
.aux_try_excep_finally_return_handler_endFunction_323:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl test_try_excep_finally_return_handler
 test_try_excep_finally_return_handler:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	movq $1, %rax
	neg %rax
	pushq %rax
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq aux_try_excep_finally_return_handler
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .test_try_excep_finally_return_handler_endExceptionCaught_348
	jmp .test_try_excep_finally_return_handler_endFunction_347	# exception still not caught by the caller
.test_try_excep_finally_return_handler_endExceptionCaught_348:
	popq %rcx
	cmpq %rcx, %rax
	je .test_try_excep_finally_return_handler_successCmp_349
	xorq %rax, %rax
	jmp .test_try_excep_finally_return_handler_continueCmp_350
.test_try_excep_finally_return_handler_successCmp_349:
	movq $1, %rax
.test_try_excep_finally_return_handler_continueCmp_350:
	cmpq $0, %rax
	je .test_try_excep_finally_return_handler_failureIf_352
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_71, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_try_excep_finally_return_handler_endExceptionCaught_353
	jmp .test_try_excep_finally_return_handler_endFunction_347	# exception still not caught by the caller
.test_try_excep_finally_return_handler_endExceptionCaught_353:
	jmp .test_try_excep_finally_return_handler_endIf_351
.test_try_excep_finally_return_handler_failureIf_352:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_72, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_try_excep_finally_return_handler_endExceptionCaught_354
	jmp .test_try_excep_finally_return_handler_endFunction_347	# exception still not caught by the caller
.test_try_excep_finally_return_handler_endExceptionCaught_354:
.test_try_excep_finally_return_handler_endIf_351:
.test_try_excep_finally_return_handler_endFunction_347:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl aux_try_excep_in_catch
 aux_try_excep_in_catch:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	jmp .aux_try_excep_in_catchtryBegin_357
.aux_try_excep_in_catchfinally_358:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_85, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_in_catch_endExceptionCaught_359
	jmp .aux_try_excep_in_catch_endFunction_355	# exception still not caught by the caller
.aux_try_excep_in_catch_endExceptionCaught_359:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_in_catch_endExceptionCaught_360
	jmp .aux_try_excep_in_catch_endFunction_355	# exception still not caught by the caller
.aux_try_excep_in_catch_endExceptionCaught_360:
	jmp *%rbx
.aux_try_excep_in_catch_E1_exception_361:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_in_catch_endExceptionCaught_362
	jmp .aux_try_excep_in_catch_endFunction_355	# exception still not caught by the caller
.aux_try_excep_in_catch_endExceptionCaught_362:
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_76, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_in_catch_endExceptionCaught_363
	jmp .aux_try_excep_in_catch_endFunction_355	# exception still not caught by the caller
.aux_try_excep_in_catch_endExceptionCaught_363:
	addq $8, %rsp
	movq $.aux_try_excep_in_catchtryContinue_356, %rbx
	jmp .aux_try_excep_in_catchfinally_358
.aux_try_excep_in_catch_E2_exception_364:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_in_catch_endExceptionCaught_365
	jmp .aux_try_excep_in_catch_endFunction_355	# exception still not caught by the caller
.aux_try_excep_in_catch_endExceptionCaught_365:
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_78, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_in_catch_endExceptionCaught_366
	jmp .aux_try_excep_in_catch_endFunction_355	# exception still not caught by the caller
.aux_try_excep_in_catch_endExceptionCaught_366:
	addq $8, %rsp
	movq $.aux_try_excep_in_catchtryContinue_356, %rbx
	jmp .aux_try_excep_in_catchfinally_358
.aux_try_excep_in_catch_E5_exception_367:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_in_catch_endExceptionCaught_368
	jmp .aux_try_excep_in_catch_endFunction_355	# exception still not caught by the caller
.aux_try_excep_in_catch_endExceptionCaught_368:
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_80, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_in_catch_endExceptionCaught_369
	jmp .aux_try_excep_in_catch_endFunction_355	# exception still not caught by the caller
.aux_try_excep_in_catch_endExceptionCaught_369:
	movq $1, .exception_not_caught_166
	movq $21569, %rax
	movq $.exception_87, %rcx
	movq %rcx, %r12
	movq %rax, %r13
	movq $.aux_try_excep_in_catchreturnPoint_370, %rbx
	jmp .aux_try_excep_in_catch_endFunction_355 	# exception thrown 
.aux_try_excep_in_catchreturnPoint_370: # return from a 'finally' without 'packet'
	movq %r12, %rcx
	movq %r13, %rax
	jmp .aux_try_excep_in_catch_endFunction_355 	# uncaught exception thrown : end function
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_82, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_in_catch_endExceptionCaught_371
	jmp .aux_try_excep_in_catch_endFunction_355	# exception still not caught by the caller
.aux_try_excep_in_catch_endExceptionCaught_371:
	addq $8, %rsp
	movq $.aux_try_excep_in_catchtryContinue_356, %rbx
	jmp .aux_try_excep_in_catchfinally_358
.aux_try_excep_in_catch_E3_exception_372:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_in_catch_endExceptionCaught_373
	jmp .aux_try_excep_in_catch_endFunction_355	# exception still not caught by the caller
.aux_try_excep_in_catch_endExceptionCaught_373:
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_84, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_in_catch_endExceptionCaught_374
	jmp .aux_try_excep_in_catch_endFunction_355	# exception still not caught by the caller
.aux_try_excep_in_catch_endExceptionCaught_374:
	addq $8, %rsp
	movq $.aux_try_excep_in_catchtryContinue_356, %rbx
	jmp .aux_try_excep_in_catchfinally_358
.aux_try_excep_in_catchtryBegin_357:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_in_catch_endExceptionCaught_375
	movq $.exception_75, %rdx
	cmpq %rcx, %rdx
	je .aux_try_excep_in_catch_E1_exception_361
	movq $.exception_77, %rdx
	cmpq %rcx, %rdx
	je .aux_try_excep_in_catch_E2_exception_364
	movq $.exception_83, %rdx
	cmpq %rcx, %rdx
	je .aux_try_excep_in_catch_E3_exception_372
	movq $.exception_79, %rdx
	cmpq %rcx, %rdx
	je .aux_try_excep_in_catch_E5_exception_367
	movq $.aux_try_excep_in_catchreturnPoint_376, %rbx
	jmp .aux_try_excep_in_catchfinally_358
.aux_try_excep_in_catchreturnPoint_376: # return from a 'finally' without 'packet'
	jmp .aux_try_excep_in_catch_endFunction_355	# exception still not caught by the caller
.aux_try_excep_in_catch_endExceptionCaught_375:
	movq $0, .exception_not_caught_166
	movq $5, %rax
	movq $.exception_79, %rcx
	movq %rcx, %r12
	movq %rax, %r13
	movq $.aux_try_excep_in_catchreturnPoint_377, %rbx
	jmp .aux_try_excep_in_catch_E5_exception_367 	# exception thrown 
.aux_try_excep_in_catchreturnPoint_377: # return from a 'finally' without 'packet'
	movq %r12, %rcx
	movq %r13, %rax
	jmp .aux_try_excep_in_catch_endFunction_355 	# uncaught exception thrown : end function
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_74, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_in_catch_endExceptionCaught_378
	movq $.exception_75, %rdx
	cmpq %rcx, %rdx
	je .aux_try_excep_in_catch_E1_exception_361
	movq $.exception_77, %rdx
	cmpq %rcx, %rdx
	je .aux_try_excep_in_catch_E2_exception_364
	movq $.exception_83, %rdx
	cmpq %rcx, %rdx
	je .aux_try_excep_in_catch_E3_exception_372
	movq $.exception_79, %rdx
	cmpq %rcx, %rdx
	je .aux_try_excep_in_catch_E5_exception_367
	movq $.aux_try_excep_in_catchreturnPoint_379, %rbx
	jmp .aux_try_excep_in_catchfinally_358
.aux_try_excep_in_catchreturnPoint_379: # return from a 'finally' without 'packet'
	jmp .aux_try_excep_in_catch_endFunction_355	# exception still not caught by the caller
.aux_try_excep_in_catch_endExceptionCaught_378:
	movq $5, %rax
	movq %rax, %r13
	movq $.aux_try_excep_in_catchreturnPoint_380, %rbx
	jmp .aux_try_excep_in_catchfinally_358
.aux_try_excep_in_catchreturnPoint_380: # return from a 'finally' without 'packet'
	movq %r13, %rax
	jmp .aux_try_excep_in_catch_endFunction_355 	# return reached : end function
	movq $.aux_try_excep_in_catchtryContinue_356, %rbx
	jmp .aux_try_excep_in_catchfinally_358
.aux_try_excep_in_catchtryContinue_356:
	movq $1, %rax
	neg %rax
	movq %rax, %r13
	jmp .aux_try_excep_in_catch_endFunction_355 	# return reached : end function
.aux_try_excep_in_catch_endFunction_355:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl test_try_excep_in_catch
 test_try_excep_in_catch:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	jmp .test_try_excep_in_catchtryBegin_383
.test_try_excep_in_catch_E20_exception_384:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_88, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .test_try_excep_in_catch_endExceptionCaught_385
	jmp .test_try_excep_in_catch_endFunction_381	# exception still not caught by the caller
.test_try_excep_in_catch_endExceptionCaught_385:
	addq $8, %rsp
	jmp .test_try_excep_in_catchtryContinue_382
.test_try_excep_in_catchtryBegin_383:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq aux_try_excep_in_catch
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_try_excep_in_catch_endExceptionCaught_386
	movq $.exception_87, %rdx
	cmpq %rcx, %rdx
	je .test_try_excep_in_catch_E20_exception_384
	jmp .test_try_excep_in_catch_endFunction_381	# exception still not caught by the caller
.test_try_excep_in_catch_endExceptionCaught_386:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_86, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_try_excep_in_catch_endExceptionCaught_387
	movq $.exception_87, %rdx
	cmpq %rcx, %rdx
	je .test_try_excep_in_catch_E20_exception_384
	jmp .test_try_excep_in_catch_endFunction_381	# exception still not caught by the caller
.test_try_excep_in_catch_endExceptionCaught_387:
.test_try_excep_in_catchtryContinue_382:
.test_try_excep_in_catch_endFunction_381:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl aux_b2
 aux_b2:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	jmp .aux_b2tryBegin_390
.aux_b2_A_exception_391:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	movq $1, %rax
	movq %rax, %r13
	jmp .aux_b2_endFunction_388 	# return reached : end function
	addq $8, %rsp
	jmp .aux_b2tryContinue_389
.aux_b2_B_exception_392:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	movq $2, %rax
	movq %rax, %r13
	jmp .aux_b2_endFunction_388 	# return reached : end function
	addq $8, %rsp
	jmp .aux_b2tryContinue_389
.aux_b2tryBegin_390:
	movq $0, .exception_not_caught_166
	movq $.string_90, %rax
	movq $.exception_92, %rcx
	movq %rcx, %r12
	movq %rax, %r13
	movq $.aux_b2returnPoint_393, %rbx
	jmp .aux_b2_B_exception_392 	# exception thrown 
.aux_b2returnPoint_393: # return from a 'finally' without 'packet'
	movq %r12, %rcx
	movq %r13, %rax
	jmp .aux_b2_endFunction_388 	# uncaught exception thrown : end function
.aux_b2tryContinue_389:
.aux_b2_endFunction_388:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl test_b2
 test_b2:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	movq $2, %rax
	pushq %rax
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq aux_b2
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .test_b2_endExceptionCaught_395
	jmp .test_b2_endFunction_394	# exception still not caught by the caller
.test_b2_endExceptionCaught_395:
	popq %rcx
	cmpq %rcx, %rax
	je .test_b2_successCmp_396
	xorq %rax, %rax
	jmp .test_b2_continueCmp_397
.test_b2_successCmp_396:
	movq $1, %rax
.test_b2_continueCmp_397:
	cmpq $0, %rax
	je .test_b2_failureIf_399
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_93, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_b2_endExceptionCaught_400
	jmp .test_b2_endFunction_394	# exception still not caught by the caller
.test_b2_endExceptionCaught_400:
	jmp .test_b2_endIf_398
.test_b2_failureIf_399:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_94, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_b2_endExceptionCaught_401
	jmp .test_b2_endFunction_394	# exception still not caught by the caller
.test_b2_endExceptionCaught_401:
.test_b2_endIf_398:
.test_b2_endFunction_394:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl aux_b3
 aux_b3:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	jmp .aux_b3tryBegin_404
.aux_b3finally_405:
	movq $0, .exception_not_caught_166
	movq $0, %rax
	movq %rax, %r13
	jmp .aux_b3_endFunction_402 	# return reached : end function
	jmp *%rbx
.aux_b3_A_exception_406:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	movq $1, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	addq %rcx, %rax
	movq %rax, %r13
	jmp .aux_b3_endFunction_402 	# return reached : end function
	addq $8, %rsp
	movq $.aux_b3tryContinue_403, %rbx
	jmp .aux_b3finally_405
.aux_b3tryBegin_404:
	movq $0, .exception_not_caught_166
	movq $2, %rax
	movq $.exception_96, %rcx
	movq %rcx, %r12
	movq %rax, %r13
	movq $.aux_b3returnPoint_407, %rbx
	jmp .aux_b3_A_exception_406 	# exception thrown 
.aux_b3returnPoint_407: # return from a 'finally' without 'packet'
	movq %r12, %rcx
	movq %r13, %rax
	jmp .aux_b3_endFunction_402 	# uncaught exception thrown : end function
	movq $.aux_b3tryContinue_403, %rbx
	jmp .aux_b3finally_405
.aux_b3tryContinue_403:
.aux_b3_endFunction_402:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl test_b3
 test_b3:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	movq $3, %rax
	pushq %rax
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq aux_b3
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .test_b3_endExceptionCaught_409
	jmp .test_b3_endFunction_408	# exception still not caught by the caller
.test_b3_endExceptionCaught_409:
	popq %rcx
	cmpq %rcx, %rax
	je .test_b3_successCmp_410
	xorq %rax, %rax
	jmp .test_b3_continueCmp_411
.test_b3_successCmp_410:
	movq $1, %rax
.test_b3_continueCmp_411:
	cmpq $0, %rax
	je .test_b3_failureIf_413
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_97, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_b3_endExceptionCaught_414
	jmp .test_b3_endFunction_408	# exception still not caught by the caller
.test_b3_endExceptionCaught_414:
	jmp .test_b3_endIf_412
.test_b3_failureIf_413:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_98, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_b3_endExceptionCaught_415
	jmp .test_b3_endFunction_408	# exception still not caught by the caller
.test_b3_endExceptionCaught_415:
.test_b3_endIf_412:
.test_b3_endFunction_408:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl aux_b6
 aux_b6:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	subq $8, %rsp
	movq $0, %rax
	movq %rax, -8(%rbp)
	jmp .aux_b6tryBegin_418
.aux_b6finally_419:
	movq -8(%rbp), %rax
	pushq %rax	# the value of expr is stored in for later
	inc %rax
	movq %rax, -8(%rbp)
	popq %rax
	movq $1, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	cmpq %rcx, %rax
	je .aux_b6_successCmp_420
	xorq %rax, %rax
	jmp .aux_b6_continueCmp_421
.aux_b6_successCmp_420:
	movq $1, %rax
.aux_b6_continueCmp_421:
	cmpq $0, %rax
	je .aux_b6_failureIf_423
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_100, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_b6_endExceptionCaught_424
	jmp .aux_b6_endFunction_416	# exception still not caught by the caller
.aux_b6_endExceptionCaught_424:
	jmp .aux_b6_endIf_422
.aux_b6_failureIf_423:
.aux_b6_endIf_422:
	jmp *%rbx
.aux_b6tryBegin_418:
	movq $1, .exception_not_caught_166
	movq $2, %rax
	movq $.exception_103, %rcx
	movq %rcx, %r12
	movq %rax, %r13
	movq $.aux_b6returnPoint_425, %rbx
	jmp .aux_b6finally_419 	# exception thrown 
.aux_b6returnPoint_425: # return from a 'finally' without 'packet'
	movq %r12, %rcx
	movq %r13, %rax
	jmp .aux_b6_endFunction_416 	# uncaught exception thrown : end function
	movq $.aux_b6tryContinue_417, %rbx
	jmp .aux_b6finally_419
.aux_b6tryContinue_417:
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_101, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_b6_endExceptionCaught_426
	jmp .aux_b6_endFunction_416	# exception still not caught by the caller
.aux_b6_endExceptionCaught_426:
	movq -8(%rbp), %rax
	movq %rax, %r13
	jmp .aux_b6_endFunction_416 	# return reached : end function
	addq $8, %rsp
.aux_b6_endFunction_416:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl test_b6
 test_b6:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	jmp .test_b6tryBegin_429
.test_b6_Z_exception_430:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_104, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .test_b6_endExceptionCaught_431
	jmp .test_b6_endFunction_427	# exception still not caught by the caller
.test_b6_endExceptionCaught_431:
	addq $8, %rsp
	jmp .test_b6tryContinue_428
.test_b6tryBegin_429:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq aux_b6
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_b6_endExceptionCaught_432
	movq $.exception_103, %rdx
	cmpq %rcx, %rdx
	je .test_b6_Z_exception_430
	jmp .test_b6_endFunction_427	# exception still not caught by the caller
.test_b6_endExceptionCaught_432:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_102, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_b6_endExceptionCaught_433
	movq $.exception_103, %rdx
	cmpq %rcx, %rdx
	je .test_b6_Z_exception_430
	jmp .test_b6_endFunction_427	# exception still not caught by the caller
.test_b6_endExceptionCaught_433:
.test_b6tryContinue_428:
.test_b6_endFunction_427:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl aux1_b7
 aux1_b7:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	pushq %rdi	# saving argument number 1 on the stack
	jmp .aux1_b7tryBegin_436
.aux1_b7finally_437:
	movq $0, %rax
	movq -8(%rbp), %rdx
	movq (%rdx, %rax, 8), %rcx
	pushq %rcx	# the value of expr is stored in for later
	inc %rcx
	movq %rcx, (%rdx, %rax, 8)
	movq %rcx, %rax
	popq %rax
	jmp *%rbx
.aux1_b7tryBegin_436:
	movq $0, %rax
	movq -8(%rbp), %rdx
	movq (%rdx, %rax, 8), %rcx
	pushq %rcx	# the value of expr is stored in for later
	inc %rcx
	movq %rcx, (%rdx, %rax, 8)
	movq %rcx, %rax
	popq %rax
	movq -8(%rbp), %rax
	movq %rax, %r13
	movq $.aux1_b7returnPoint_438, %rbx
	jmp .aux1_b7finally_437
.aux1_b7returnPoint_438: # return from a 'finally' without 'packet'
	movq %r13, %rax
	jmp .aux1_b7_endFunction_434 	# return reached : end function
	movq $.aux1_b7tryContinue_435, %rbx
	jmp .aux1_b7finally_437
.aux1_b7tryContinue_435:
.aux1_b7_endFunction_434:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl aux2_b7
 aux2_b7:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	subq $8, %rsp
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $8, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq malloc
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux2_b7_endExceptionCaught_440
	jmp .aux2_b7_endFunction_439	# exception still not caught by the caller
.aux2_b7_endExceptionCaught_440:
	movq %rax, -8(%rbp)
	movq $0, %rax
	pushq %rax
	movq $0, %rax
	popq %rcx
	movq -8(%rbp), %rdx
	movq %rcx, (%rdx, %rax, 8)
	movq %rcx, %rax
	movq $0, %rax
	pushq %rax
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -8(%rbp), %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq aux1_b7
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux2_b7_endExceptionCaught_441
	jmp .aux2_b7_endFunction_439	# exception still not caught by the caller
.aux2_b7_endExceptionCaught_441:
	popq %rcx
	movq %rax, %r13
	jmp .aux2_b7_endFunction_439 	# return reached : end function
	addq $8, %rsp
.aux2_b7_endFunction_439:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl test_b7
 test_b7:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	movq $2, %rax
	pushq %rax
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq aux2_b7
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .test_b7_endExceptionCaught_443
	jmp .test_b7_endFunction_442	# exception still not caught by the caller
.test_b7_endExceptionCaught_443:
	popq %rcx
	cmpq %rcx, %rax
	je .test_b7_successCmp_444
	xorq %rax, %rax
	jmp .test_b7_continueCmp_445
.test_b7_successCmp_444:
	movq $1, %rax
.test_b7_continueCmp_445:
	cmpq $0, %rax
	je .test_b7_failureIf_447
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_105, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_b7_endExceptionCaught_448
	jmp .test_b7_endFunction_442	# exception still not caught by the caller
.test_b7_endExceptionCaught_448:
	jmp .test_b7_endIf_446
.test_b7_failureIf_447:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_106, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_b7_endExceptionCaught_449
	jmp .test_b7_endFunction_442	# exception still not caught by the caller
.test_b7_endExceptionCaught_449:
.test_b7_endIf_446:
.test_b7_endFunction_442:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl aux1_twisted1
 aux1_twisted1:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	movq $42, %rax
	movq %rax, %r13
	jmp .aux1_twisted1_endFunction_450 	# return reached : end function
.aux1_twisted1_endFunction_450:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl aux2_twisted1
 aux2_twisted1:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	subq $8, %rsp
	jmp .aux2_twisted1tryBegin_453
.aux2_twisted1finally_454:
	movq -8(%rbp), %rax
	pushq %rax	# the value of expr is stored in for later
	inc %rax
	movq %rax, -8(%rbp)
	popq %rax
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -8(%rbp), %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_107, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux2_twisted1_endExceptionCaught_455
	jmp .aux2_twisted1_endFunction_451	# exception still not caught by the caller
.aux2_twisted1_endExceptionCaught_455:
	jmp *%rbx
.aux2_twisted1tryBegin_453:
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq aux1_twisted1
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux2_twisted1_endExceptionCaught_456
	movq $.aux2_twisted1returnPoint_457, %rbx
	jmp .aux2_twisted1finally_454
.aux2_twisted1returnPoint_457: # return from a 'finally' without 'packet'
	jmp .aux2_twisted1_endFunction_451	# exception still not caught by the caller
.aux2_twisted1_endExceptionCaught_456:
	movq %rax, -8(%rbp)
	movq -8(%rbp), %rax
	pushq %rax	# the value of expr is stored in for later
	inc %rax
	movq %rax, -8(%rbp)
	popq %rax
	movq -8(%rbp), %rax
	movq %rax, %r13
	movq $.aux2_twisted1returnPoint_458, %rbx
	jmp .aux2_twisted1finally_454
.aux2_twisted1returnPoint_458: # return from a 'finally' without 'packet'
	movq %r13, %rax
	jmp .aux2_twisted1_endFunction_451 	# return reached : end function
	movq $.aux2_twisted1tryContinue_452, %rbx
	jmp .aux2_twisted1finally_454
.aux2_twisted1tryContinue_452:
	addq $8, %rsp
.aux2_twisted1_endFunction_451:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl test_twisted1
 test_twisted1:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	movq $43, %rax
	pushq %rax
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq aux2_twisted1
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .test_twisted1_endExceptionCaught_460
	jmp .test_twisted1_endFunction_459	# exception still not caught by the caller
.test_twisted1_endExceptionCaught_460:
	popq %rcx
	cmpq %rcx, %rax
	je .test_twisted1_successCmp_461
	xorq %rax, %rax
	jmp .test_twisted1_continueCmp_462
.test_twisted1_successCmp_461:
	movq $1, %rax
.test_twisted1_continueCmp_462:
	cmpq $0, %rax
	je .test_twisted1_failureIf_464
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_108, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_twisted1_endExceptionCaught_465
	jmp .test_twisted1_endFunction_459	# exception still not caught by the caller
.test_twisted1_endExceptionCaught_465:
	jmp .test_twisted1_endIf_463
.test_twisted1_failureIf_464:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_109, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_twisted1_endExceptionCaught_466
	jmp .test_twisted1_endFunction_459	# exception still not caught by the caller
.test_twisted1_endExceptionCaught_466:
.test_twisted1_endIf_463:
.test_twisted1_endFunction_459:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl launch_test
 launch_test:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_165, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_468
	jmp .launch_test_endFunction_467	# exception still not caught by the caller
.launch_test_endExceptionCaught_468:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_111, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_469
	jmp .launch_test_endFunction_467	# exception still not caught by the caller
.launch_test_endExceptionCaught_469:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_112, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_470
	jmp .launch_test_endFunction_467	# exception still not caught by the caller
.launch_test_endExceptionCaught_470:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_113, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_471
	jmp .launch_test_endFunction_467	# exception still not caught by the caller
.launch_test_endExceptionCaught_471:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_114, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_472
	jmp .launch_test_endFunction_467	# exception still not caught by the caller
.launch_test_endExceptionCaught_472:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_161, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_473
	jmp .launch_test_endFunction_467	# exception still not caught by the caller
.launch_test_endExceptionCaught_473:
	jmp .launch_testtryBegin_475
.launch_test_E_exception_476:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_117, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_477
	jmp .launch_test_endFunction_467	# exception still not caught by the caller
.launch_test_endExceptionCaught_477:
	addq $8, %rsp
	jmp .launch_testtryContinue_474
.launch_testtryBegin_475:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq test_throw
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_478
	movq $.exception_121, %rdx
	cmpq %rcx, %rdx
	je .launch_test_E_exception_476
	jmp .launch_test_endFunction_467	# exception still not caught by the caller
.launch_test_endExceptionCaught_478:
.launch_testtryContinue_474:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_165, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_479
	jmp .launch_test_endFunction_467	# exception still not caught by the caller
.launch_test_endExceptionCaught_479:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_119, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_480
	jmp .launch_test_endFunction_467	# exception still not caught by the caller
.launch_test_endExceptionCaught_480:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_161, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_481
	jmp .launch_test_endFunction_467	# exception still not caught by the caller
.launch_test_endExceptionCaught_481:
	jmp .launch_testtryBegin_483
.launch_test_E_exception_484:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_122, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_485
	jmp .launch_test_endFunction_467	# exception still not caught by the caller
.launch_test_endExceptionCaught_485:
	addq $8, %rsp
	jmp .launch_testtryContinue_482
.launch_testtryBegin_483:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq test_call
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_486
	movq $.exception_121, %rdx
	cmpq %rcx, %rdx
	je .launch_test_E_exception_484
	jmp .launch_test_endFunction_467	# exception still not caught by the caller
.launch_test_endExceptionCaught_486:
.launch_testtryContinue_482:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_165, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_487
	jmp .launch_test_endFunction_467	# exception still not caught by the caller
.launch_test_endExceptionCaught_487:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_124, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_488
	jmp .launch_test_endFunction_467	# exception still not caught by the caller
.launch_test_endExceptionCaught_488:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_164, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_489
	jmp .launch_test_endFunction_467	# exception still not caught by the caller
.launch_test_endExceptionCaught_489:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq test_try_no_excep_no_finally_no_return
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_490
	jmp .launch_test_endFunction_467	# exception still not caught by the caller
.launch_test_endExceptionCaught_490:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_165, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_491
	jmp .launch_test_endFunction_467	# exception still not caught by the caller
.launch_test_endExceptionCaught_491:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_127, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_492
	jmp .launch_test_endFunction_467	# exception still not caught by the caller
.launch_test_endExceptionCaught_492:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_161, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_493
	jmp .launch_test_endFunction_467	# exception still not caught by the caller
.launch_test_endExceptionCaught_493:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq test_try_no_excep_no_finally_return
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_494
	jmp .launch_test_endFunction_467	# exception still not caught by the caller
.launch_test_endExceptionCaught_494:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_165, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_495
	jmp .launch_test_endFunction_467	# exception still not caught by the caller
.launch_test_endExceptionCaught_495:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_130, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_496
	jmp .launch_test_endFunction_467	# exception still not caught by the caller
.launch_test_endExceptionCaught_496:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_146, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_497
	jmp .launch_test_endFunction_467	# exception still not caught by the caller
.launch_test_endExceptionCaught_497:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq test_try_no_excep_finally_no_return
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_498
	jmp .launch_test_endFunction_467	# exception still not caught by the caller
.launch_test_endExceptionCaught_498:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_165, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_499
	jmp .launch_test_endFunction_467	# exception still not caught by the caller
.launch_test_endExceptionCaught_499:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_133, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_500
	jmp .launch_test_endFunction_467	# exception still not caught by the caller
.launch_test_endExceptionCaught_500:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_146, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_501
	jmp .launch_test_endFunction_467	# exception still not caught by the caller
.launch_test_endExceptionCaught_501:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq test_try_no_excep_finally_return
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_502
	jmp .launch_test_endFunction_467	# exception still not caught by the caller
.launch_test_endExceptionCaught_502:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_165, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_503
	jmp .launch_test_endFunction_467	# exception still not caught by the caller
.launch_test_endExceptionCaught_503:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_136, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_504
	jmp .launch_test_endFunction_467	# exception still not caught by the caller
.launch_test_endExceptionCaught_504:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_146, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_505
	jmp .launch_test_endFunction_467	# exception still not caught by the caller
.launch_test_endExceptionCaught_505:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq test_try_no_excep_finally_return_2
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_506
	jmp .launch_test_endFunction_467	# exception still not caught by the caller
.launch_test_endExceptionCaught_506:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_165, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_507
	jmp .launch_test_endFunction_467	# exception still not caught by the caller
.launch_test_endExceptionCaught_507:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_139, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_508
	jmp .launch_test_endFunction_467	# exception still not caught by the caller
.launch_test_endExceptionCaught_508:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_146, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_509
	jmp .launch_test_endFunction_467	# exception still not caught by the caller
.launch_test_endExceptionCaught_509:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq test_try_no_excep_finally_return_3
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_510
	jmp .launch_test_endFunction_467	# exception still not caught by the caller
.launch_test_endExceptionCaught_510:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_165, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_511
	jmp .launch_test_endFunction_467	# exception still not caught by the caller
.launch_test_endExceptionCaught_511:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_142, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_512
	jmp .launch_test_endFunction_467	# exception still not caught by the caller
.launch_test_endExceptionCaught_512:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_164, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_513
	jmp .launch_test_endFunction_467	# exception still not caught by the caller
.launch_test_endExceptionCaught_513:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq test_try_excep_finally_return_no_handler
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_514
	jmp .launch_test_endFunction_467	# exception still not caught by the caller
.launch_test_endExceptionCaught_514:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_165, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_515
	jmp .launch_test_endFunction_467	# exception still not caught by the caller
.launch_test_endExceptionCaught_515:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_145, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_516
	jmp .launch_test_endFunction_467	# exception still not caught by the caller
.launch_test_endExceptionCaught_516:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_146, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_517
	jmp .launch_test_endFunction_467	# exception still not caught by the caller
.launch_test_endExceptionCaught_517:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq test_try_excep_finally_return_handler
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_518
	jmp .launch_test_endFunction_467	# exception still not caught by the caller
.launch_test_endExceptionCaught_518:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_165, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_519
	jmp .launch_test_endFunction_467	# exception still not caught by the caller
.launch_test_endExceptionCaught_519:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_148, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_520
	jmp .launch_test_endFunction_467	# exception still not caught by the caller
.launch_test_endExceptionCaught_520:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_164, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_521
	jmp .launch_test_endFunction_467	# exception still not caught by the caller
.launch_test_endExceptionCaught_521:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq test_try_excep_in_catch
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_522
	jmp .launch_test_endFunction_467	# exception still not caught by the caller
.launch_test_endExceptionCaught_522:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_165, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_523
	jmp .launch_test_endFunction_467	# exception still not caught by the caller
.launch_test_endExceptionCaught_523:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_151, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_524
	jmp .launch_test_endFunction_467	# exception still not caught by the caller
.launch_test_endExceptionCaught_524:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_161, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_525
	jmp .launch_test_endFunction_467	# exception still not caught by the caller
.launch_test_endExceptionCaught_525:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq test_b2
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_526
	jmp .launch_test_endFunction_467	# exception still not caught by the caller
.launch_test_endExceptionCaught_526:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_165, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_527
	jmp .launch_test_endFunction_467	# exception still not caught by the caller
.launch_test_endExceptionCaught_527:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_154, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_528
	jmp .launch_test_endFunction_467	# exception still not caught by the caller
.launch_test_endExceptionCaught_528:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_161, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_529
	jmp .launch_test_endFunction_467	# exception still not caught by the caller
.launch_test_endExceptionCaught_529:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq test_b3
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_530
	jmp .launch_test_endFunction_467	# exception still not caught by the caller
.launch_test_endExceptionCaught_530:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_165, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_531
	jmp .launch_test_endFunction_467	# exception still not caught by the caller
.launch_test_endExceptionCaught_531:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_157, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_532
	jmp .launch_test_endFunction_467	# exception still not caught by the caller
.launch_test_endExceptionCaught_532:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_164, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_533
	jmp .launch_test_endFunction_467	# exception still not caught by the caller
.launch_test_endExceptionCaught_533:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq test_b6
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_534
	jmp .launch_test_endFunction_467	# exception still not caught by the caller
.launch_test_endExceptionCaught_534:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_165, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_535
	jmp .launch_test_endFunction_467	# exception still not caught by the caller
.launch_test_endExceptionCaught_535:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_160, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_536
	jmp .launch_test_endFunction_467	# exception still not caught by the caller
.launch_test_endExceptionCaught_536:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_161, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_537
	jmp .launch_test_endFunction_467	# exception still not caught by the caller
.launch_test_endExceptionCaught_537:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq test_b7
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_538
	jmp .launch_test_endFunction_467	# exception still not caught by the caller
.launch_test_endExceptionCaught_538:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_165, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_539
	jmp .launch_test_endFunction_467	# exception still not caught by the caller
.launch_test_endExceptionCaught_539:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_163, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_540
	jmp .launch_test_endFunction_467	# exception still not caught by the caller
.launch_test_endExceptionCaught_540:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_164, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_541
	jmp .launch_test_endFunction_467	# exception still not caught by the caller
.launch_test_endExceptionCaught_541:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq test_twisted1
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_542
	jmp .launch_test_endFunction_467	# exception still not caught by the caller
.launch_test_endExceptionCaught_542:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_165, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_543
	jmp .launch_test_endFunction_467	# exception still not caught by the caller
.launch_test_endExceptionCaught_543:
.launch_test_endFunction_467:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl main
 main:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq launch_test
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .main_endExceptionCaught_545
	jmp .main_endFunction_544	# exception still not caught by the caller
.main_endExceptionCaught_545:
.main_endFunction_544:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
