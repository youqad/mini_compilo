.data

.string_90:
	.asciz ""
	.align 8
.string_165:
	.asciz "---------------------------------------------------------\n"
	.align 8
.string_113:
	.asciz "---------------------------------------------------------\n\n\n"
	.align 8
.exception_96:
	.asciz "A"
	.align 8
.exception_92:
	.asciz "B"
	.align 8
.exception_121:
	.asciz "E"
	.align 8
.exception_75:
	.asciz "E1"
	.align 8
.exception_77:
	.asciz "E2"
	.align 8
.exception_87:
	.asciz "E20"
	.align 8
.exception_83:
	.asciz "E3"
	.align 8
.exception_79:
	.asciz "E5"
	.align 8
.exception_43:
	.asciz "Ex"
	.align 8
.exception_45:
	.asciz "Ex1"
	.align 8
.string_112:
	.asciz "Expected succeed : 31\n"
	.align 8
.exception_50:
	.asciz "Stop"
	.align 8
.string_119:
	.asciz "Test : result_call\n"
	.align 8
.string_114:
	.asciz "Test : result_throw\n"
	.align 8
.string_151:
	.asciz "Test : test_b2\n"
	.align 8
.string_154:
	.asciz "Test : test_b3\n"
	.align 8
.string_157:
	.asciz "Test : test_b6\n"
	.align 8
.string_160:
	.asciz "Test : test_b7\n"
	.align 8
.string_145:
	.asciz "Test : test_try_excep_finally_return_handler\n"
	.align 8
.string_142:
	.asciz "Test : test_try_excep_finally_return_no_handler\n"
	.align 8
.string_148:
	.asciz "Test : test_try_excep_in_catch\n"
	.align 8
.string_130:
	.asciz "Test : test_try_no_excep_finally_no_return\n"
	.align 8
.string_133:
	.asciz "Test : test_try_no_excep_finally_return\n"
	.align 8
.string_136:
	.asciz "Test : test_try_no_excep_finally_return_2\n"
	.align 8
.string_139:
	.asciz "Test : test_try_no_excep_finally_return_3\n"
	.align 8
.string_124:
	.asciz "Test : test_try_no_excep_no_finally_no_return\n"
	.align 8
.string_127:
	.asciz "Test : test_try_no_excep_no_finally_return\n"
	.align 8
.string_163:
	.asciz "Test : test_twisted1\n"
	.align 8
.string_111:
	.asciz "Tests set : 16 tests\n"
	.align 8
.exception_103:
	.asciz "Z"
	.align 8
.string_161:
	.asciz "expected : 1\n"
	.align 8
.string_164:
	.asciz "expected : 2\n"
	.align 8
.string_146:
	.asciz "expected : 3\n"
	.align 8
.string_61:
	.asciz "failed, aux_try_excep_finally_return_handler 1\n"
	.align 8
.string_63:
	.asciz "failed, aux_try_excep_finally_return_handler 2\n"
	.align 8
.string_65:
	.asciz "failed, aux_try_excep_finally_return_handler 3\n"
	.align 8
.string_69:
	.asciz "failed, aux_try_excep_finally_return_handler 4\n"
	.align 8
.string_59:
	.asciz "failed, aux_try_excep_finally_return_no_handler 3\n"
	.align 8
.string_74:
	.asciz "failed, aux_try_excep_in_catch 1\n"
	.align 8
.string_76:
	.asciz "failed, aux_try_excep_in_catch 2\n"
	.align 8
.string_78:
	.asciz "failed, aux_try_excep_in_catch 3\n"
	.align 8
.string_82:
	.asciz "failed, aux_try_excep_in_catch 4\n"
	.align 8
.string_84:
	.asciz "failed, aux_try_excep_in_catch 5\n"
	.align 8
.string_85:
	.asciz "failed, aux_try_excep_in_catch 6\n"
	.align 8
.string_86:
	.asciz "failed, aux_try_excep_in_catch 7\n"
	.align 8
.string_35:
	.asciz "failed, aux_try_no_excep_finally_return_2 1\n"
	.align 8
.string_37:
	.asciz "failed, aux_try_no_excep_finally_return_2 2\n"
	.align 8
.string_41:
	.asciz "failed, aux_try_no_excep_finally_return_2 4\n"
	.align 8
.string_44:
	.asciz "failed, aux_try_no_excep_finally_return_3 1\n"
	.align 8
.string_46:
	.asciz "failed, aux_try_no_excep_finally_return_3 2\n"
	.align 8
.string_49:
	.asciz "failed, aux_try_no_excep_finally_return_3 3\n"
	.align 8
.string_52:
	.asciz "failed, aux_try_no_excep_finally_return_3 4\n"
	.align 8
.string_94:
	.asciz "failed, test_b2\n"
	.align 8
.string_98:
	.asciz "failed, test_b3\n"
	.align 8
.string_101:
	.asciz "failed, test_b6 1\n"
	.align 8
.string_102:
	.asciz "failed, test_b6 2\n"
	.align 8
.string_106:
	.asciz "failed, test_b7\n"
	.align 8
.string_3:
	.asciz "failed, test_call\n"
	.align 8
.string_2:
	.asciz "failed, test_throw\n"
	.align 8
.string_72:
	.asciz "failed, test_try_excep_finally_return_handler 5\n"
	.align 8
.string_54:
	.asciz "failed, test_try_excep_finally_return_no_handler 1\n"
	.align 8
.string_56:
	.asciz "failed, test_try_excep_finally_return_no_handler 2\n"
	.align 8
.string_19:
	.asciz "failed, test_try_no_excep_finally_no_return 1\n"
	.align 8
.string_21:
	.asciz "failed, test_try_no_excep_finally_no_return 2\n"
	.align 8
.string_26:
	.asciz "failed, test_try_no_excep_finally_return 2\n"
	.align 8
.string_39:
	.asciz "failed, test_try_no_excep_finally_return 3\n"
	.align 8
.string_30:
	.asciz "failed, test_try_no_excep_finally_return 4\n"
	.align 8
.string_32:
	.asciz "failed, test_try_no_excep_finally_return 5\n"
	.align 8
.string_6:
	.asciz "failed, test_try_no_excep_no_finally_no_return 1\n"
	.align 8
.string_8:
	.asciz "failed, test_try_no_excep_no_finally_no_return 2\n"
	.align 8
.string_11:
	.asciz "failed, test_try_no_excep_no_finally_return 1\n"
	.align 8
.string_13:
	.asciz "failed, test_try_no_excep_no_finally_return 2\n"
	.align 8
.string_14:
	.asciz "failed, test_try_no_excep_no_finally_return 3\n"
	.align 8
.string_16:
	.asciz "failed, test_try_no_excep_no_finally_return 4\n"
	.align 8
.string_109:
	.asciz "failed, test_twisted1\n"
	.align 8
.string_67:
	.asciz "pass, aux_try_excep_finally_return_handler 1\n"
	.align 8
.string_70:
	.asciz "pass, aux_try_excep_finally_return_handler 2\n"
	.align 8
.string_58:
	.asciz "pass, aux_try_excep_finally_return_no_handler 2\n"
	.align 8
.string_80:
	.asciz "pass, aux_try_excep_in_catch 1\n"
	.align 8
.string_88:
	.asciz "pass, aux_try_excep_in_catch 2\n"
	.align 8
.string_33:
	.asciz "pass, aux_try_no_excep_finally_return_2 1\n"
	.align 8
.string_38:
	.asciz "pass, aux_try_no_excep_finally_return_2 2\n"
	.align 8
.string_40:
	.asciz "pass, aux_try_no_excep_finally_return_2 3\n"
	.align 8
.string_42:
	.asciz "pass, aux_try_no_excep_finally_return_3 1\n"
	.align 8
.string_47:
	.asciz "pass, aux_try_no_excep_finally_return_3 2\n"
	.align 8
.string_51:
	.asciz "pass, aux_try_no_excep_finally_return_3 3\n"
	.align 8
.string_122:
	.asciz "pass, result_call\n"
	.align 8
.string_117:
	.asciz "pass, result_throw\n"
	.align 8
.string_93:
	.asciz "pass, test_b2\n"
	.align 8
.string_97:
	.asciz "pass, test_b3\n"
	.align 8
.string_100:
	.asciz "pass, test_b6 1\n"
	.align 8
.string_104:
	.asciz "pass, test_b6 2\n"
	.align 8
.string_105:
	.asciz "pass, test_b7\n"
	.align 8
.string_71:
	.asciz "pass, test_try_excep_finally_return_handler 3\n"
	.align 8
.string_57:
	.asciz "pass, test_try_excep_finally_return_no_handler 1\n"
	.align 8
.string_17:
	.asciz "pass, test_try_no_excep_finally_no_return 1\n"
	.align 8
.string_22:
	.asciz "pass, test_try_no_excep_finally_no_return 2\n"
	.align 8
.string_23:
	.asciz "pass, test_try_no_excep_finally_no_return 3\n"
	.align 8
.string_24:
	.asciz "pass, test_try_no_excep_finally_return 1\n"
	.align 8
.string_29:
	.asciz "pass, test_try_no_excep_finally_return 2\n"
	.align 8
.string_31:
	.asciz "pass, test_try_no_excep_finally_return 3\n"
	.align 8
.string_4:
	.asciz "pass, test_try_no_excep_no_finally_no_return 1\n"
	.align 8
.string_9:
	.asciz "pass, test_try_no_excep_no_finally_no_return 2\n"
	.align 8
.string_15:
	.asciz "pass, test_try_no_excep_no_finally_return 1\n"
	.align 8
.string_107:
	.asciz "pass, test_twisted1 1, %d\n"
	.align 8
.string_108:
	.asciz "pass, test_twisted1 2\n"
	.align 8


.comm .exception_not_caught_166,8,8


.text

	movq $0, .exception_not_caught_166
.globl test_throw
 test_throw:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	movq $1, .exception_not_caught_166
	movq $25, %rax
	movq $.exception_121, %rcx
	jmp .test_throw_endFunction_167 	# exception thrown 
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_2, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_throw_endExceptionCaught_168
	jmp .test_throw_endFunction_167
.test_throw_endExceptionCaught_168:
	jmp .test_throw_endFunction_167 	# return reached : end function
.test_throw_endFunction_167:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl do_nothing
 do_nothing:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	subq $8, %rsp
	movq $5, %rax
	movq %rax, -8(%rbp)
	movq -8(%rbp), %rax
	jmp .do_nothing_endFunction_169 	# return reached : end function
	addq $8, %rsp
.do_nothing_endFunction_169:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl test_call
 test_call:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq test_throw
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_call_endExceptionCaught_171
	jmp .test_call_endFunction_170
.test_call_endExceptionCaught_171:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_3, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_call_endExceptionCaught_172
	jmp .test_call_endFunction_170
.test_call_endExceptionCaught_172:
.test_call_endFunction_170:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl test_try_no_excep_no_finally_no_return
 test_try_no_excep_no_finally_no_return:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	jmp .test_try_no_excep_no_finally_no_returntryBegin_175
.test_try_no_excep_no_finally_no_return_Ex_exception_176:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_6, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_no_finally_no_return_endExceptionCaught_177
	jmp .test_try_no_excep_no_finally_no_return_endFunction_173
.test_try_no_excep_no_finally_no_return_endExceptionCaught_177:
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_no_finally_no_return_endExceptionCaught_178
	jmp .test_try_no_excep_no_finally_no_return_endFunction_173
.test_try_no_excep_no_finally_no_return_endExceptionCaught_178:
	jmp .test_try_no_excep_no_finally_no_returntryContinue_174
.test_try_no_excep_no_finally_no_return_Ex1_exception_179:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_8, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_no_finally_no_return_endExceptionCaught_180
	jmp .test_try_no_excep_no_finally_no_return_endFunction_173
.test_try_no_excep_no_finally_no_return_endExceptionCaught_180:
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_no_finally_no_return_endExceptionCaught_181
	jmp .test_try_no_excep_no_finally_no_return_endFunction_173
.test_try_no_excep_no_finally_no_return_endExceptionCaught_181:
	jmp .test_try_no_excep_no_finally_no_returntryContinue_174
.test_try_no_excep_no_finally_no_returntryBegin_175:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_no_finally_no_return_endExceptionCaught_182
	movq $.exception_43, %rdx
	cmpq %rcx, %rdx
	je .test_try_no_excep_no_finally_no_return_Ex_exception_176
	movq $.exception_45, %rdx
	cmpq %rcx, %rdx
	je .test_try_no_excep_no_finally_no_return_Ex1_exception_179
	jmp .test_try_no_excep_no_finally_no_return_endFunction_173
.test_try_no_excep_no_finally_no_return_endExceptionCaught_182:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_4, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_no_finally_no_return_endExceptionCaught_183
	movq $.exception_43, %rdx
	cmpq %rcx, %rdx
	je .test_try_no_excep_no_finally_no_return_Ex_exception_176
	movq $.exception_45, %rdx
	cmpq %rcx, %rdx
	je .test_try_no_excep_no_finally_no_return_Ex1_exception_179
	jmp .test_try_no_excep_no_finally_no_return_endFunction_173
.test_try_no_excep_no_finally_no_return_endExceptionCaught_183:
.test_try_no_excep_no_finally_no_returntryContinue_174:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_9, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_no_finally_no_return_endExceptionCaught_184
	jmp .test_try_no_excep_no_finally_no_return_endFunction_173
.test_try_no_excep_no_finally_no_return_endExceptionCaught_184:
.test_try_no_excep_no_finally_no_return_endFunction_173:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl aux_try_no_excep_no_finally_return
 aux_try_no_excep_no_finally_return:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	jmp .aux_try_no_excep_no_finally_returntryBegin_187
.aux_try_no_excep_no_finally_return_Ex_exception_188:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_11, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_no_finally_return_endExceptionCaught_189
	jmp .aux_try_no_excep_no_finally_return_endFunction_185
.aux_try_no_excep_no_finally_return_endExceptionCaught_189:
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_no_finally_return_endExceptionCaught_190
	jmp .aux_try_no_excep_no_finally_return_endFunction_185
.aux_try_no_excep_no_finally_return_endExceptionCaught_190:
	jmp .aux_try_no_excep_no_finally_returntryContinue_186
.aux_try_no_excep_no_finally_return_Ex1_exception_191:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_13, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_no_finally_return_endExceptionCaught_192
	jmp .aux_try_no_excep_no_finally_return_endFunction_185
.aux_try_no_excep_no_finally_return_endExceptionCaught_192:
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_no_finally_return_endExceptionCaught_193
	jmp .aux_try_no_excep_no_finally_return_endFunction_185
.aux_try_no_excep_no_finally_return_endExceptionCaught_193:
	jmp .aux_try_no_excep_no_finally_returntryContinue_186
.aux_try_no_excep_no_finally_returntryBegin_187:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_no_finally_return_endExceptionCaught_194
	movq $.exception_43, %rdx
	cmpq %rcx, %rdx
	je .aux_try_no_excep_no_finally_return_Ex_exception_188
	movq $.exception_45, %rdx
	cmpq %rcx, %rdx
	je .aux_try_no_excep_no_finally_return_Ex1_exception_191
	jmp .aux_try_no_excep_no_finally_return_endFunction_185
.aux_try_no_excep_no_finally_return_endExceptionCaught_194:
	movq $5, %rax
	jmp .aux_try_no_excep_no_finally_return_endFunction_185 	# return reached : end function
.aux_try_no_excep_no_finally_returntryContinue_186:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_14, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_no_finally_return_endExceptionCaught_195
	jmp .aux_try_no_excep_no_finally_return_endFunction_185
.aux_try_no_excep_no_finally_return_endExceptionCaught_195:
.aux_try_no_excep_no_finally_return_endFunction_185:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl test_try_no_excep_no_finally_return
 test_try_no_excep_no_finally_return:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	movq $5, %rax
	pushq %rax
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq aux_try_no_excep_no_finally_return
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_no_finally_return_endExceptionCaught_197
	jmp .test_try_no_excep_no_finally_return_endFunction_196
.test_try_no_excep_no_finally_return_endExceptionCaught_197:
	popq %rcx
	cmpq %rcx, %rax
	je .test_try_no_excep_no_finally_return_successCmp_198
	xorq %rax, %rax
	jmp .test_try_no_excep_no_finally_return_continueCmp_199
.test_try_no_excep_no_finally_return_successCmp_198:
	movq $1, %rax
.test_try_no_excep_no_finally_return_continueCmp_199:
	cmpq $0, %rax
	je .test_try_no_excep_no_finally_return_failureIf_201
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_15, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_no_finally_return_endExceptionCaught_202
	jmp .test_try_no_excep_no_finally_return_endFunction_196
.test_try_no_excep_no_finally_return_endExceptionCaught_202:
	jmp .test_try_no_excep_no_finally_return_endIf_200
.test_try_no_excep_no_finally_return_failureIf_201:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_16, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_no_finally_return_endExceptionCaught_203
	jmp .test_try_no_excep_no_finally_return_endFunction_196
.test_try_no_excep_no_finally_return_endExceptionCaught_203:
.test_try_no_excep_no_finally_return_endIf_200:
.test_try_no_excep_no_finally_return_endFunction_196:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl test_try_no_excep_finally_no_return
 test_try_no_excep_finally_no_return:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	jmp .test_try_no_excep_finally_no_returntryBegin_206
.test_try_no_excep_finally_no_returnfinally_207:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_finally_no_return_endExceptionCaught_208
	jmp .test_try_no_excep_finally_no_return_endFunction_204
.test_try_no_excep_finally_no_return_endExceptionCaught_208:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_22, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_finally_no_return_endExceptionCaught_209
	jmp .test_try_no_excep_finally_no_return_endFunction_204
.test_try_no_excep_finally_no_return_endExceptionCaught_209:
	jmp .test_try_no_excep_finally_no_returntryContinue_205 	# end of finally reached 
.test_try_no_excep_finally_no_return_Ex_exception_210:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_19, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_finally_no_return_endExceptionCaught_211
	jmp .test_try_no_excep_finally_no_returnfinally_207
.test_try_no_excep_finally_no_return_endExceptionCaught_211:
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_finally_no_return_endExceptionCaught_212
	jmp .test_try_no_excep_finally_no_returnfinally_207
.test_try_no_excep_finally_no_return_endExceptionCaught_212:
	jmp .test_try_no_excep_finally_no_returnfinally_207
.test_try_no_excep_finally_no_return_Ex1_exception_213:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_21, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_finally_no_return_endExceptionCaught_214
	jmp .test_try_no_excep_finally_no_returnfinally_207
.test_try_no_excep_finally_no_return_endExceptionCaught_214:
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_finally_no_return_endExceptionCaught_215
	jmp .test_try_no_excep_finally_no_returnfinally_207
.test_try_no_excep_finally_no_return_endExceptionCaught_215:
	jmp .test_try_no_excep_finally_no_returnfinally_207
.test_try_no_excep_finally_no_returntryBegin_206:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_finally_no_return_endExceptionCaught_216
	movq $.exception_43, %rdx
	cmpq %rcx, %rdx
	je .test_try_no_excep_finally_no_return_Ex_exception_210
	movq $.exception_45, %rdx
	cmpq %rcx, %rdx
	je .test_try_no_excep_finally_no_return_Ex1_exception_213
	jmp .test_try_no_excep_finally_no_returnfinally_207
.test_try_no_excep_finally_no_return_endExceptionCaught_216:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_17, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_finally_no_return_endExceptionCaught_217
	movq $.exception_43, %rdx
	cmpq %rcx, %rdx
	je .test_try_no_excep_finally_no_return_Ex_exception_210
	movq $.exception_45, %rdx
	cmpq %rcx, %rdx
	je .test_try_no_excep_finally_no_return_Ex1_exception_213
	jmp .test_try_no_excep_finally_no_returnfinally_207
.test_try_no_excep_finally_no_return_endExceptionCaught_217:
	jmp .test_try_no_excep_finally_no_returnfinally_207
.test_try_no_excep_finally_no_returntryContinue_205:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_23, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_finally_no_return_endExceptionCaught_218
	jmp .test_try_no_excep_finally_no_return_endFunction_204
.test_try_no_excep_finally_no_return_endExceptionCaught_218:
.test_try_no_excep_finally_no_return_endFunction_204:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl aux_try_no_excep_finally_return
 aux_try_no_excep_finally_return:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	jmp .aux_try_no_excep_finally_returntryBegin_221
.aux_try_no_excep_finally_returnfinally_222:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_endExceptionCaught_223
	jmp .aux_try_no_excep_finally_return_endFunction_219
.aux_try_no_excep_finally_return_endExceptionCaught_223:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_29, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_endExceptionCaught_224
	jmp .aux_try_no_excep_finally_return_endFunction_219
.aux_try_no_excep_finally_return_endExceptionCaught_224:
	jmp .aux_try_no_excep_finally_returntryContinue_220 	# end of finally reached 
.aux_try_no_excep_finally_return_Ex_exception_225:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_26, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_endExceptionCaught_226
	jmp .aux_try_no_excep_finally_returnfinally_222
.aux_try_no_excep_finally_return_endExceptionCaught_226:
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_endExceptionCaught_227
	jmp .aux_try_no_excep_finally_returnfinally_222
.aux_try_no_excep_finally_return_endExceptionCaught_227:
	jmp .aux_try_no_excep_finally_returnfinally_222
.aux_try_no_excep_finally_return_Ex1_exception_228:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_39, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_endExceptionCaught_229
	jmp .aux_try_no_excep_finally_returnfinally_222
.aux_try_no_excep_finally_return_endExceptionCaught_229:
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_endExceptionCaught_230
	jmp .aux_try_no_excep_finally_returnfinally_222
.aux_try_no_excep_finally_return_endExceptionCaught_230:
	jmp .aux_try_no_excep_finally_returnfinally_222
.aux_try_no_excep_finally_returntryBegin_221:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_endExceptionCaught_231
	movq $.exception_43, %rdx
	cmpq %rcx, %rdx
	je .aux_try_no_excep_finally_return_Ex_exception_225
	movq $.exception_45, %rdx
	cmpq %rcx, %rdx
	je .aux_try_no_excep_finally_return_Ex1_exception_228
	jmp .aux_try_no_excep_finally_returnfinally_222
.aux_try_no_excep_finally_return_endExceptionCaught_231:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_24, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_endExceptionCaught_232
	movq $.exception_43, %rdx
	cmpq %rcx, %rdx
	je .aux_try_no_excep_finally_return_Ex_exception_225
	movq $.exception_45, %rdx
	cmpq %rcx, %rdx
	je .aux_try_no_excep_finally_return_Ex1_exception_228
	jmp .aux_try_no_excep_finally_returnfinally_222
.aux_try_no_excep_finally_return_endExceptionCaught_232:
	movq $5, %rax
	jmp .aux_try_no_excep_finally_returnfinally_222
	jmp .aux_try_no_excep_finally_return_endFunction_219 	# return reached : end function
	jmp .aux_try_no_excep_finally_returnfinally_222
.aux_try_no_excep_finally_returntryContinue_220:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_30, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_endExceptionCaught_233
	jmp .aux_try_no_excep_finally_return_endFunction_219
.aux_try_no_excep_finally_return_endExceptionCaught_233:
	movq $0, %rax
	jmp .aux_try_no_excep_finally_return_endFunction_219 	# return reached : end function
.aux_try_no_excep_finally_return_endFunction_219:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl test_try_no_excep_finally_return
 test_try_no_excep_finally_return:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	movq $5, %rax
	pushq %rax
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq aux_try_no_excep_finally_return
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_finally_return_endExceptionCaught_235
	jmp .test_try_no_excep_finally_return_endFunction_234
.test_try_no_excep_finally_return_endExceptionCaught_235:
	popq %rcx
	cmpq %rcx, %rax
	je .test_try_no_excep_finally_return_successCmp_236
	xorq %rax, %rax
	jmp .test_try_no_excep_finally_return_continueCmp_237
.test_try_no_excep_finally_return_successCmp_236:
	movq $1, %rax
.test_try_no_excep_finally_return_continueCmp_237:
	cmpq $0, %rax
	je .test_try_no_excep_finally_return_failureIf_239
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_31, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_finally_return_endExceptionCaught_240
	jmp .test_try_no_excep_finally_return_endFunction_234
.test_try_no_excep_finally_return_endExceptionCaught_240:
	jmp .test_try_no_excep_finally_return_endIf_238
.test_try_no_excep_finally_return_failureIf_239:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_32, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_finally_return_endExceptionCaught_241
	jmp .test_try_no_excep_finally_return_endFunction_234
.test_try_no_excep_finally_return_endExceptionCaught_241:
.test_try_no_excep_finally_return_endIf_238:
.test_try_no_excep_finally_return_endFunction_234:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl aux_try_no_excep_finally_return_2
 aux_try_no_excep_finally_return_2:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	jmp .aux_try_no_excep_finally_return_2tryBegin_244
.aux_try_no_excep_finally_return_2finally_245:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_2_endExceptionCaught_246
	jmp .aux_try_no_excep_finally_return_2_endFunction_242
.aux_try_no_excep_finally_return_2_endExceptionCaught_246:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_38, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_2_endExceptionCaught_247
	jmp .aux_try_no_excep_finally_return_2_endFunction_242
.aux_try_no_excep_finally_return_2_endExceptionCaught_247:
	movq $0, .exception_not_caught_166
	movq $3, %rax
	jmp .aux_try_no_excep_finally_return_2_endFunction_242 	# return reached : end function
	jmp .aux_try_no_excep_finally_return_2tryContinue_243 	# end of finally reached 
.aux_try_no_excep_finally_return_2_Ex_exception_248:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_35, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_2_endExceptionCaught_249
	jmp .aux_try_no_excep_finally_return_2finally_245
.aux_try_no_excep_finally_return_2_endExceptionCaught_249:
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_2_endExceptionCaught_250
	jmp .aux_try_no_excep_finally_return_2finally_245
.aux_try_no_excep_finally_return_2_endExceptionCaught_250:
	jmp .aux_try_no_excep_finally_return_2finally_245
.aux_try_no_excep_finally_return_2_Ex1_exception_251:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_37, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_2_endExceptionCaught_252
	jmp .aux_try_no_excep_finally_return_2finally_245
.aux_try_no_excep_finally_return_2_endExceptionCaught_252:
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_2_endExceptionCaught_253
	jmp .aux_try_no_excep_finally_return_2finally_245
.aux_try_no_excep_finally_return_2_endExceptionCaught_253:
	jmp .aux_try_no_excep_finally_return_2finally_245
.aux_try_no_excep_finally_return_2tryBegin_244:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_2_endExceptionCaught_254
	movq $.exception_43, %rdx
	cmpq %rcx, %rdx
	je .aux_try_no_excep_finally_return_2_Ex_exception_248
	movq $.exception_45, %rdx
	cmpq %rcx, %rdx
	je .aux_try_no_excep_finally_return_2_Ex1_exception_251
	jmp .aux_try_no_excep_finally_return_2finally_245
.aux_try_no_excep_finally_return_2_endExceptionCaught_254:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_33, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_2_endExceptionCaught_255
	movq $.exception_43, %rdx
	cmpq %rcx, %rdx
	je .aux_try_no_excep_finally_return_2_Ex_exception_248
	movq $.exception_45, %rdx
	cmpq %rcx, %rdx
	je .aux_try_no_excep_finally_return_2_Ex1_exception_251
	jmp .aux_try_no_excep_finally_return_2finally_245
.aux_try_no_excep_finally_return_2_endExceptionCaught_255:
	movq $5, %rax
	jmp .aux_try_no_excep_finally_return_2finally_245
	jmp .aux_try_no_excep_finally_return_2_endFunction_242 	# return reached : end function
	jmp .aux_try_no_excep_finally_return_2finally_245
.aux_try_no_excep_finally_return_2tryContinue_243:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_39, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_2_endExceptionCaught_256
	jmp .aux_try_no_excep_finally_return_2_endFunction_242
.aux_try_no_excep_finally_return_2_endExceptionCaught_256:
	movq $0, %rax
	jmp .aux_try_no_excep_finally_return_2_endFunction_242 	# return reached : end function
.aux_try_no_excep_finally_return_2_endFunction_242:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl test_try_no_excep_finally_return_2
 test_try_no_excep_finally_return_2:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	movq $3, %rax
	pushq %rax
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq aux_try_no_excep_finally_return_2
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_finally_return_2_endExceptionCaught_258
	jmp .test_try_no_excep_finally_return_2_endFunction_257
.test_try_no_excep_finally_return_2_endExceptionCaught_258:
	popq %rcx
	cmpq %rcx, %rax
	je .test_try_no_excep_finally_return_2_successCmp_259
	xorq %rax, %rax
	jmp .test_try_no_excep_finally_return_2_continueCmp_260
.test_try_no_excep_finally_return_2_successCmp_259:
	movq $1, %rax
.test_try_no_excep_finally_return_2_continueCmp_260:
	cmpq $0, %rax
	je .test_try_no_excep_finally_return_2_failureIf_262
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_40, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_finally_return_2_endExceptionCaught_263
	jmp .test_try_no_excep_finally_return_2_endFunction_257
.test_try_no_excep_finally_return_2_endExceptionCaught_263:
	jmp .test_try_no_excep_finally_return_2_endIf_261
.test_try_no_excep_finally_return_2_failureIf_262:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_41, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_finally_return_2_endExceptionCaught_264
	jmp .test_try_no_excep_finally_return_2_endFunction_257
.test_try_no_excep_finally_return_2_endExceptionCaught_264:
.test_try_no_excep_finally_return_2_endIf_261:
.test_try_no_excep_finally_return_2_endFunction_257:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl aux_try_no_excep_finally_return_3
 aux_try_no_excep_finally_return_3:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	jmp .aux_try_no_excep_finally_return_3tryBegin_267
.aux_try_no_excep_finally_return_3finally_268:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_3_endExceptionCaught_269
	jmp .aux_try_no_excep_finally_return_3_endFunction_265
.aux_try_no_excep_finally_return_3_endExceptionCaught_269:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_47, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_3_endExceptionCaught_270
	jmp .aux_try_no_excep_finally_return_3_endFunction_265
.aux_try_no_excep_finally_return_3_endExceptionCaught_270:
	movq $1, .exception_not_caught_166
	movq $0, %rax
	movq $.exception_50, %rcx
	jmp .aux_try_no_excep_finally_return_3_endFunction_265 	# exception thrown 
	jmp .aux_try_no_excep_finally_return_3tryContinue_266 	# end of finally reached 
.aux_try_no_excep_finally_return_3_Ex_exception_271:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_44, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_3_endExceptionCaught_272
	jmp .aux_try_no_excep_finally_return_3finally_268
.aux_try_no_excep_finally_return_3_endExceptionCaught_272:
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_3_endExceptionCaught_273
	jmp .aux_try_no_excep_finally_return_3finally_268
.aux_try_no_excep_finally_return_3_endExceptionCaught_273:
	jmp .aux_try_no_excep_finally_return_3finally_268
.aux_try_no_excep_finally_return_3_Ex1_exception_274:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_46, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_3_endExceptionCaught_275
	jmp .aux_try_no_excep_finally_return_3finally_268
.aux_try_no_excep_finally_return_3_endExceptionCaught_275:
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_3_endExceptionCaught_276
	jmp .aux_try_no_excep_finally_return_3finally_268
.aux_try_no_excep_finally_return_3_endExceptionCaught_276:
	jmp .aux_try_no_excep_finally_return_3finally_268
.aux_try_no_excep_finally_return_3tryBegin_267:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_3_endExceptionCaught_277
	movq $.exception_43, %rdx
	cmpq %rcx, %rdx
	je .aux_try_no_excep_finally_return_3_Ex_exception_271
	movq $.exception_45, %rdx
	cmpq %rcx, %rdx
	je .aux_try_no_excep_finally_return_3_Ex1_exception_274
	jmp .aux_try_no_excep_finally_return_3finally_268
.aux_try_no_excep_finally_return_3_endExceptionCaught_277:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_42, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_3_endExceptionCaught_278
	movq $.exception_43, %rdx
	cmpq %rcx, %rdx
	je .aux_try_no_excep_finally_return_3_Ex_exception_271
	movq $.exception_45, %rdx
	cmpq %rcx, %rdx
	je .aux_try_no_excep_finally_return_3_Ex1_exception_274
	jmp .aux_try_no_excep_finally_return_3finally_268
.aux_try_no_excep_finally_return_3_endExceptionCaught_278:
	movq $5, %rax
	jmp .aux_try_no_excep_finally_return_3finally_268
	jmp .aux_try_no_excep_finally_return_3_endFunction_265 	# return reached : end function
	jmp .aux_try_no_excep_finally_return_3finally_268
.aux_try_no_excep_finally_return_3tryContinue_266:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_49, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_3_endExceptionCaught_279
	jmp .aux_try_no_excep_finally_return_3_endFunction_265
.aux_try_no_excep_finally_return_3_endExceptionCaught_279:
	movq $0, %rax
	jmp .aux_try_no_excep_finally_return_3_endFunction_265 	# return reached : end function
.aux_try_no_excep_finally_return_3_endFunction_265:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl test_try_no_excep_finally_return_3
 test_try_no_excep_finally_return_3:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	jmp .test_try_no_excep_finally_return_3tryBegin_282
.test_try_no_excep_finally_return_3_Stop_exception_283:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_51, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_finally_return_3_endExceptionCaught_284
	jmp .test_try_no_excep_finally_return_3_endFunction_280
.test_try_no_excep_finally_return_3_endExceptionCaught_284:
	movq $0, %rax
	jmp .test_try_no_excep_finally_return_3_endFunction_280 	# return reached : end function
	jmp .test_try_no_excep_finally_return_3tryContinue_281
.test_try_no_excep_finally_return_3tryBegin_282:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq aux_try_no_excep_finally_return_3
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_finally_return_3_endExceptionCaught_285
	movq $.exception_50, %rdx
	cmpq %rcx, %rdx
	je .test_try_no_excep_finally_return_3_Stop_exception_283
	jmp .test_try_no_excep_finally_return_3_endFunction_280
.test_try_no_excep_finally_return_3_endExceptionCaught_285:
.test_try_no_excep_finally_return_3tryContinue_281:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_52, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_finally_return_3_endExceptionCaught_286
	jmp .test_try_no_excep_finally_return_3_endFunction_280
.test_try_no_excep_finally_return_3_endExceptionCaught_286:
.test_try_no_excep_finally_return_3_endFunction_280:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl aux_try_excep_finally_return_no_handler
 aux_try_excep_finally_return_no_handler:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	jmp .aux_try_excep_finally_return_no_handlertryBegin_289
.aux_try_excep_finally_return_no_handlerfinally_290:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_57, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_finally_return_no_handler_endExceptionCaught_291
	jmp .aux_try_excep_finally_return_no_handler_endFunction_287
.aux_try_excep_finally_return_no_handler_endExceptionCaught_291:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_finally_return_no_handler_endExceptionCaught_292
	jmp .aux_try_excep_finally_return_no_handler_endFunction_287
.aux_try_excep_finally_return_no_handler_endExceptionCaught_292:
	movq $0, .exception_not_caught_166
	movq $9, %rax
	jmp .aux_try_excep_finally_return_no_handler_endFunction_287 	# return reached : end function
	jmp .aux_try_excep_finally_return_no_handlertryContinue_288 	# end of finally reached 
.aux_try_excep_finally_return_no_handler_E2_exception_293:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_finally_return_no_handler_endExceptionCaught_294
	jmp .aux_try_excep_finally_return_no_handlerfinally_290
.aux_try_excep_finally_return_no_handler_endExceptionCaught_294:
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_56, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_finally_return_no_handler_endExceptionCaught_295
	jmp .aux_try_excep_finally_return_no_handlerfinally_290
.aux_try_excep_finally_return_no_handler_endExceptionCaught_295:
	jmp .aux_try_excep_finally_return_no_handlerfinally_290
.aux_try_excep_finally_return_no_handlertryBegin_289:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_finally_return_no_handler_endExceptionCaught_296
	movq $.exception_77, %rdx
	cmpq %rcx, %rdx
	je .aux_try_excep_finally_return_no_handler_E2_exception_293
	jmp .aux_try_excep_finally_return_no_handlerfinally_290
.aux_try_excep_finally_return_no_handler_endExceptionCaught_296:
	movq $1, .exception_not_caught_166
	movq $5, %rax
	movq $.exception_75, %rcx
	jmp .aux_try_excep_finally_return_no_handlerfinally_290 	# exception thrown 
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_54, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_finally_return_no_handler_endExceptionCaught_297
	movq $.exception_77, %rdx
	cmpq %rcx, %rdx
	je .aux_try_excep_finally_return_no_handler_E2_exception_293
	jmp .aux_try_excep_finally_return_no_handlerfinally_290
.aux_try_excep_finally_return_no_handler_endExceptionCaught_297:
	movq $1, %rax
	jmp .aux_try_excep_finally_return_no_handlerfinally_290
	jmp .aux_try_excep_finally_return_no_handler_endFunction_287 	# return reached : end function
	jmp .aux_try_excep_finally_return_no_handlerfinally_290
.aux_try_excep_finally_return_no_handlertryContinue_288:
	movq $1, %rax
	neg %rax
	jmp .aux_try_excep_finally_return_no_handler_endFunction_287 	# return reached : end function
.aux_try_excep_finally_return_no_handler_endFunction_287:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl test_try_excep_finally_return_no_handler
 test_try_excep_finally_return_no_handler:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	movq $9, %rax
	pushq %rax
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq aux_try_excep_finally_return_no_handler
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .test_try_excep_finally_return_no_handler_endExceptionCaught_299
	jmp .test_try_excep_finally_return_no_handler_endFunction_298
.test_try_excep_finally_return_no_handler_endExceptionCaught_299:
	popq %rcx
	cmpq %rcx, %rax
	je .test_try_excep_finally_return_no_handler_successCmp_300
	xorq %rax, %rax
	jmp .test_try_excep_finally_return_no_handler_continueCmp_301
.test_try_excep_finally_return_no_handler_successCmp_300:
	movq $1, %rax
.test_try_excep_finally_return_no_handler_continueCmp_301:
	cmpq $0, %rax
	je .test_try_excep_finally_return_no_handler_failureIf_303
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_58, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_try_excep_finally_return_no_handler_endExceptionCaught_304
	jmp .test_try_excep_finally_return_no_handler_endFunction_298
.test_try_excep_finally_return_no_handler_endExceptionCaught_304:
	jmp .test_try_excep_finally_return_no_handler_endIf_302
.test_try_excep_finally_return_no_handler_failureIf_303:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_59, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_try_excep_finally_return_no_handler_endExceptionCaught_305
	jmp .test_try_excep_finally_return_no_handler_endFunction_298
.test_try_excep_finally_return_no_handler_endExceptionCaught_305:
.test_try_excep_finally_return_no_handler_endIf_302:
.test_try_excep_finally_return_no_handler_endFunction_298:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl aux_try_excep_finally_return_handler
 aux_try_excep_finally_return_handler:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	jmp .aux_try_excep_finally_return_handlertryBegin_308
.aux_try_excep_finally_return_handlerfinally_309:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_70, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_finally_return_handler_endExceptionCaught_310
	jmp .aux_try_excep_finally_return_handler_endFunction_306
.aux_try_excep_finally_return_handler_endExceptionCaught_310:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_finally_return_handler_endExceptionCaught_311
	jmp .aux_try_excep_finally_return_handler_endFunction_306
.aux_try_excep_finally_return_handler_endExceptionCaught_311:
	jmp .aux_try_excep_finally_return_handlertryContinue_307 	# end of finally reached 
.aux_try_excep_finally_return_handler_E1_exception_312:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_finally_return_handler_endExceptionCaught_313
	jmp .aux_try_excep_finally_return_handlerfinally_309
.aux_try_excep_finally_return_handler_endExceptionCaught_313:
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_63, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_finally_return_handler_endExceptionCaught_314
	jmp .aux_try_excep_finally_return_handlerfinally_309
.aux_try_excep_finally_return_handler_endExceptionCaught_314:
	jmp .aux_try_excep_finally_return_handlerfinally_309
.aux_try_excep_finally_return_handler_E2_exception_315:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_finally_return_handler_endExceptionCaught_316
	jmp .aux_try_excep_finally_return_handlerfinally_309
.aux_try_excep_finally_return_handler_endExceptionCaught_316:
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_65, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_finally_return_handler_endExceptionCaught_317
	jmp .aux_try_excep_finally_return_handlerfinally_309
.aux_try_excep_finally_return_handler_endExceptionCaught_317:
	jmp .aux_try_excep_finally_return_handlerfinally_309
.aux_try_excep_finally_return_handler_E5_exception_318:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_finally_return_handler_endExceptionCaught_319
	jmp .aux_try_excep_finally_return_handlerfinally_309
.aux_try_excep_finally_return_handler_endExceptionCaught_319:
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_67, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_finally_return_handler_endExceptionCaught_320
	jmp .aux_try_excep_finally_return_handlerfinally_309
.aux_try_excep_finally_return_handler_endExceptionCaught_320:
	jmp .aux_try_excep_finally_return_handlerfinally_309
.aux_try_excep_finally_return_handler_E3_exception_321:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_finally_return_handler_endExceptionCaught_322
	jmp .aux_try_excep_finally_return_handlerfinally_309
.aux_try_excep_finally_return_handler_endExceptionCaught_322:
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_69, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_finally_return_handler_endExceptionCaught_323
	jmp .aux_try_excep_finally_return_handlerfinally_309
.aux_try_excep_finally_return_handler_endExceptionCaught_323:
	jmp .aux_try_excep_finally_return_handlerfinally_309
.aux_try_excep_finally_return_handlertryBegin_308:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_finally_return_handler_endExceptionCaught_324
	movq $.exception_75, %rdx
	cmpq %rcx, %rdx
	je .aux_try_excep_finally_return_handler_E1_exception_312
	movq $.exception_77, %rdx
	cmpq %rcx, %rdx
	je .aux_try_excep_finally_return_handler_E2_exception_315
	movq $.exception_83, %rdx
	cmpq %rcx, %rdx
	je .aux_try_excep_finally_return_handler_E3_exception_321
	movq $.exception_79, %rdx
	cmpq %rcx, %rdx
	je .aux_try_excep_finally_return_handler_E5_exception_318
	jmp .aux_try_excep_finally_return_handlerfinally_309
.aux_try_excep_finally_return_handler_endExceptionCaught_324:
	movq $0, .exception_not_caught_166
	movq $5, %rax
	movq $.exception_79, %rcx
	jmp .aux_try_excep_finally_return_handler_E5_exception_318 	# exception thrown 
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_61, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_finally_return_handler_endExceptionCaught_325
	movq $.exception_75, %rdx
	cmpq %rcx, %rdx
	je .aux_try_excep_finally_return_handler_E1_exception_312
	movq $.exception_77, %rdx
	cmpq %rcx, %rdx
	je .aux_try_excep_finally_return_handler_E2_exception_315
	movq $.exception_83, %rdx
	cmpq %rcx, %rdx
	je .aux_try_excep_finally_return_handler_E3_exception_321
	movq $.exception_79, %rdx
	cmpq %rcx, %rdx
	je .aux_try_excep_finally_return_handler_E5_exception_318
	jmp .aux_try_excep_finally_return_handlerfinally_309
.aux_try_excep_finally_return_handler_endExceptionCaught_325:
	movq $5, %rax
	jmp .aux_try_excep_finally_return_handlerfinally_309
	jmp .aux_try_excep_finally_return_handler_endFunction_306 	# return reached : end function
	jmp .aux_try_excep_finally_return_handlerfinally_309
.aux_try_excep_finally_return_handlertryContinue_307:
	movq $1, %rax
	neg %rax
	jmp .aux_try_excep_finally_return_handler_endFunction_306 	# return reached : end function
.aux_try_excep_finally_return_handler_endFunction_306:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl test_try_excep_finally_return_handler
 test_try_excep_finally_return_handler:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	movq $1, %rax
	neg %rax
	pushq %rax
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq aux_try_excep_finally_return_handler
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .test_try_excep_finally_return_handler_endExceptionCaught_327
	jmp .test_try_excep_finally_return_handler_endFunction_326
.test_try_excep_finally_return_handler_endExceptionCaught_327:
	popq %rcx
	cmpq %rcx, %rax
	je .test_try_excep_finally_return_handler_successCmp_328
	xorq %rax, %rax
	jmp .test_try_excep_finally_return_handler_continueCmp_329
.test_try_excep_finally_return_handler_successCmp_328:
	movq $1, %rax
.test_try_excep_finally_return_handler_continueCmp_329:
	cmpq $0, %rax
	je .test_try_excep_finally_return_handler_failureIf_331
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_71, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_try_excep_finally_return_handler_endExceptionCaught_332
	jmp .test_try_excep_finally_return_handler_endFunction_326
.test_try_excep_finally_return_handler_endExceptionCaught_332:
	jmp .test_try_excep_finally_return_handler_endIf_330
.test_try_excep_finally_return_handler_failureIf_331:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_72, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_try_excep_finally_return_handler_endExceptionCaught_333
	jmp .test_try_excep_finally_return_handler_endFunction_326
.test_try_excep_finally_return_handler_endExceptionCaught_333:
.test_try_excep_finally_return_handler_endIf_330:
.test_try_excep_finally_return_handler_endFunction_326:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl aux_try_excep_in_catch
 aux_try_excep_in_catch:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	jmp .aux_try_excep_in_catchtryBegin_336
.aux_try_excep_in_catchfinally_337:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_85, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_in_catch_endExceptionCaught_338
	jmp .aux_try_excep_in_catch_endFunction_334
.aux_try_excep_in_catch_endExceptionCaught_338:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_in_catch_endExceptionCaught_339
	jmp .aux_try_excep_in_catch_endFunction_334
.aux_try_excep_in_catch_endExceptionCaught_339:
	jmp .aux_try_excep_in_catchtryContinue_335 	# end of finally reached 
.aux_try_excep_in_catch_E1_exception_340:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_in_catch_endExceptionCaught_341
	jmp .aux_try_excep_in_catchfinally_337
.aux_try_excep_in_catch_endExceptionCaught_341:
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_76, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_in_catch_endExceptionCaught_342
	jmp .aux_try_excep_in_catchfinally_337
.aux_try_excep_in_catch_endExceptionCaught_342:
	jmp .aux_try_excep_in_catchfinally_337
.aux_try_excep_in_catch_E2_exception_343:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_in_catch_endExceptionCaught_344
	jmp .aux_try_excep_in_catchfinally_337
.aux_try_excep_in_catch_endExceptionCaught_344:
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_78, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_in_catch_endExceptionCaught_345
	jmp .aux_try_excep_in_catchfinally_337
.aux_try_excep_in_catch_endExceptionCaught_345:
	jmp .aux_try_excep_in_catchfinally_337
.aux_try_excep_in_catch_E5_exception_346:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_in_catch_endExceptionCaught_347
	jmp .aux_try_excep_in_catchfinally_337
.aux_try_excep_in_catch_endExceptionCaught_347:
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_80, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_in_catch_endExceptionCaught_348
	jmp .aux_try_excep_in_catchfinally_337
.aux_try_excep_in_catch_endExceptionCaught_348:
	movq $1, .exception_not_caught_166
	movq $21569, %rax
	movq $.exception_87, %rcx
	jmp .aux_try_excep_in_catchfinally_337 	# exception thrown 
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_82, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_in_catch_endExceptionCaught_349
	jmp .aux_try_excep_in_catchfinally_337
.aux_try_excep_in_catch_endExceptionCaught_349:
	jmp .aux_try_excep_in_catchfinally_337
.aux_try_excep_in_catch_E3_exception_350:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_in_catch_endExceptionCaught_351
	jmp .aux_try_excep_in_catchfinally_337
.aux_try_excep_in_catch_endExceptionCaught_351:
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_84, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_in_catch_endExceptionCaught_352
	jmp .aux_try_excep_in_catchfinally_337
.aux_try_excep_in_catch_endExceptionCaught_352:
	jmp .aux_try_excep_in_catchfinally_337
.aux_try_excep_in_catchtryBegin_336:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_in_catch_endExceptionCaught_353
	movq $.exception_75, %rdx
	cmpq %rcx, %rdx
	je .aux_try_excep_in_catch_E1_exception_340
	movq $.exception_77, %rdx
	cmpq %rcx, %rdx
	je .aux_try_excep_in_catch_E2_exception_343
	movq $.exception_83, %rdx
	cmpq %rcx, %rdx
	je .aux_try_excep_in_catch_E3_exception_350
	movq $.exception_79, %rdx
	cmpq %rcx, %rdx
	je .aux_try_excep_in_catch_E5_exception_346
	jmp .aux_try_excep_in_catchfinally_337
.aux_try_excep_in_catch_endExceptionCaught_353:
	movq $0, .exception_not_caught_166
	movq $5, %rax
	movq $.exception_79, %rcx
	jmp .aux_try_excep_in_catch_E5_exception_346 	# exception thrown 
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_74, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_in_catch_endExceptionCaught_354
	movq $.exception_75, %rdx
	cmpq %rcx, %rdx
	je .aux_try_excep_in_catch_E1_exception_340
	movq $.exception_77, %rdx
	cmpq %rcx, %rdx
	je .aux_try_excep_in_catch_E2_exception_343
	movq $.exception_83, %rdx
	cmpq %rcx, %rdx
	je .aux_try_excep_in_catch_E3_exception_350
	movq $.exception_79, %rdx
	cmpq %rcx, %rdx
	je .aux_try_excep_in_catch_E5_exception_346
	jmp .aux_try_excep_in_catchfinally_337
.aux_try_excep_in_catch_endExceptionCaught_354:
	movq $5, %rax
	jmp .aux_try_excep_in_catchfinally_337
	jmp .aux_try_excep_in_catch_endFunction_334 	# return reached : end function
	jmp .aux_try_excep_in_catchfinally_337
.aux_try_excep_in_catchtryContinue_335:
	movq $1, %rax
	neg %rax
	jmp .aux_try_excep_in_catch_endFunction_334 	# return reached : end function
.aux_try_excep_in_catch_endFunction_334:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl test_try_excep_in_catch
 test_try_excep_in_catch:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	jmp .test_try_excep_in_catchtryBegin_357
.test_try_excep_in_catch_E20_exception_358:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_88, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .test_try_excep_in_catch_endExceptionCaught_359
	jmp .test_try_excep_in_catch_endFunction_355
.test_try_excep_in_catch_endExceptionCaught_359:
	jmp .test_try_excep_in_catchtryContinue_356
.test_try_excep_in_catchtryBegin_357:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq aux_try_excep_in_catch
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_try_excep_in_catch_endExceptionCaught_360
	movq $.exception_87, %rdx
	cmpq %rcx, %rdx
	je .test_try_excep_in_catch_E20_exception_358
	jmp .test_try_excep_in_catch_endFunction_355
.test_try_excep_in_catch_endExceptionCaught_360:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_86, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_try_excep_in_catch_endExceptionCaught_361
	movq $.exception_87, %rdx
	cmpq %rcx, %rdx
	je .test_try_excep_in_catch_E20_exception_358
	jmp .test_try_excep_in_catch_endFunction_355
.test_try_excep_in_catch_endExceptionCaught_361:
.test_try_excep_in_catchtryContinue_356:
.test_try_excep_in_catch_endFunction_355:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl aux_b2
 aux_b2:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	jmp .aux_b2tryBegin_364
.aux_b2_A_exception_365:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	movq $1, %rax
	jmp .aux_b2_endFunction_362 	# return reached : end function
	jmp .aux_b2tryContinue_363
.aux_b2_B_exception_366:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	movq $2, %rax
	jmp .aux_b2_endFunction_362 	# return reached : end function
	jmp .aux_b2tryContinue_363
.aux_b2tryBegin_364:
	movq $0, .exception_not_caught_166
	movq $.string_90, %rax
	movq $.exception_92, %rcx
	jmp .aux_b2_B_exception_366 	# exception thrown 
.aux_b2tryContinue_363:
.aux_b2_endFunction_362:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl test_b2
 test_b2:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	movq $2, %rax
	pushq %rax
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq aux_b2
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .test_b2_endExceptionCaught_368
	jmp .test_b2_endFunction_367
.test_b2_endExceptionCaught_368:
	popq %rcx
	cmpq %rcx, %rax
	je .test_b2_successCmp_369
	xorq %rax, %rax
	jmp .test_b2_continueCmp_370
.test_b2_successCmp_369:
	movq $1, %rax
.test_b2_continueCmp_370:
	cmpq $0, %rax
	je .test_b2_failureIf_372
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_93, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_b2_endExceptionCaught_373
	jmp .test_b2_endFunction_367
.test_b2_endExceptionCaught_373:
	jmp .test_b2_endIf_371
.test_b2_failureIf_372:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_94, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_b2_endExceptionCaught_374
	jmp .test_b2_endFunction_367
.test_b2_endExceptionCaught_374:
.test_b2_endIf_371:
.test_b2_endFunction_367:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl aux_b3
 aux_b3:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	jmp .aux_b3tryBegin_377
.aux_b3finally_378:
	movq $0, .exception_not_caught_166
	movq $0, %rax
	jmp .aux_b3_endFunction_375 	# return reached : end function
	jmp .aux_b3tryContinue_376 	# end of finally reached 
.aux_b3_A_exception_379:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	movq $1, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	addq %rcx, %rax
	jmp .aux_b3finally_378
	jmp .aux_b3_endFunction_375 	# return reached : end function
	jmp .aux_b3finally_378
.aux_b3tryBegin_377:
	movq $0, .exception_not_caught_166
	movq $2, %rax
	movq $.exception_96, %rcx
	jmp .aux_b3_A_exception_379 	# exception thrown 
	jmp .aux_b3finally_378
.aux_b3tryContinue_376:
.aux_b3_endFunction_375:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl test_b3
 test_b3:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	movq $3, %rax
	pushq %rax
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq aux_b3
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .test_b3_endExceptionCaught_381
	jmp .test_b3_endFunction_380
.test_b3_endExceptionCaught_381:
	popq %rcx
	cmpq %rcx, %rax
	je .test_b3_successCmp_382
	xorq %rax, %rax
	jmp .test_b3_continueCmp_383
.test_b3_successCmp_382:
	movq $1, %rax
.test_b3_continueCmp_383:
	cmpq $0, %rax
	je .test_b3_failureIf_385
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_97, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_b3_endExceptionCaught_386
	jmp .test_b3_endFunction_380
.test_b3_endExceptionCaught_386:
	jmp .test_b3_endIf_384
.test_b3_failureIf_385:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_98, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_b3_endExceptionCaught_387
	jmp .test_b3_endFunction_380
.test_b3_endExceptionCaught_387:
.test_b3_endIf_384:
.test_b3_endFunction_380:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl aux_b6
 aux_b6:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	subq $8, %rsp
	movq $0, %rax
	movq %rax, -8(%rbp)
	jmp .aux_b6tryBegin_390
.aux_b6finally_391:
	movq -8(%rbp), %rax
	pushq %rax	# the value of expr is stored in for later
	inc %rax
	movq %rax, -8(%rbp)
	popq %rax
	movq $1, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	cmpq %rcx, %rax
	je .aux_b6_successCmp_392
	xorq %rax, %rax
	jmp .aux_b6_continueCmp_393
.aux_b6_successCmp_392:
	movq $1, %rax
.aux_b6_continueCmp_393:
	cmpq $0, %rax
	je .aux_b6_failureIf_395
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_100, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_b6_endExceptionCaught_396
	jmp .aux_b6_endFunction_388
.aux_b6_endExceptionCaught_396:
	jmp .aux_b6_endIf_394
.aux_b6_failureIf_395:
.aux_b6_endIf_394:
	jmp .aux_b6tryContinue_389 	# end of finally reached 
.aux_b6tryBegin_390:
	movq $1, .exception_not_caught_166
	movq $2, %rax
	movq $.exception_103, %rcx
	jmp .aux_b6finally_391 	# exception thrown 
	jmp .aux_b6finally_391
.aux_b6tryContinue_389:
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_101, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_b6_endExceptionCaught_397
	jmp .aux_b6_endFunction_388
.aux_b6_endExceptionCaught_397:
	movq -8(%rbp), %rax
	jmp .aux_b6_endFunction_388 	# return reached : end function
	addq $8, %rsp
.aux_b6_endFunction_388:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl test_b6
 test_b6:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	jmp .test_b6tryBegin_400
.test_b6_Z_exception_401:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_104, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .test_b6_endExceptionCaught_402
	jmp .test_b6_endFunction_398
.test_b6_endExceptionCaught_402:
	jmp .test_b6tryContinue_399
.test_b6tryBegin_400:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq aux_b6
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_b6_endExceptionCaught_403
	movq $.exception_103, %rdx
	cmpq %rcx, %rdx
	je .test_b6_Z_exception_401
	jmp .test_b6_endFunction_398
.test_b6_endExceptionCaught_403:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_102, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_b6_endExceptionCaught_404
	movq $.exception_103, %rdx
	cmpq %rcx, %rdx
	je .test_b6_Z_exception_401
	jmp .test_b6_endFunction_398
.test_b6_endExceptionCaught_404:
.test_b6tryContinue_399:
.test_b6_endFunction_398:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl aux1_b7
 aux1_b7:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	pushq %rdi	# saving argument number 1 on the stack
	jmp .aux1_b7tryBegin_407
.aux1_b7finally_408:
	movq $0, %rax
	movq -8(%rbp), %rdx
	movq (%rdx, %rax, 8), %rcx
	pushq %rcx	# the value of expr is stored in for later
	inc %rcx
	movq %rcx, (%rdx, %rax, 8)
	movq %rcx, %rax
	popq %rax
	jmp .aux1_b7tryContinue_406 	# end of finally reached 
.aux1_b7tryBegin_407:
	movq $0, %rax
	movq -8(%rbp), %rdx
	movq (%rdx, %rax, 8), %rcx
	pushq %rcx	# the value of expr is stored in for later
	inc %rcx
	movq %rcx, (%rdx, %rax, 8)
	movq %rcx, %rax
	popq %rax
	movq -8(%rbp), %rax
	jmp .aux1_b7finally_408
	jmp .aux1_b7_endFunction_405 	# return reached : end function
	jmp .aux1_b7finally_408
.aux1_b7tryContinue_406:
.aux1_b7_endFunction_405:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl aux2_b7
 aux2_b7:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	subq $8, %rsp
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $8, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq malloc
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux2_b7_endExceptionCaught_410
	jmp .aux2_b7_endFunction_409
.aux2_b7_endExceptionCaught_410:
	movq %rax, -8(%rbp)
	movq $0, %rax
	pushq %rax
	movq $0, %rax
	popq %rcx
	movq -8(%rbp), %rdx
	movq %rcx, (%rdx, %rax, 8)
	movq %rcx, %rax
	movq $0, %rax
	pushq %rax
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -8(%rbp), %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq aux1_b7
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux2_b7_endExceptionCaught_411
	jmp .aux2_b7_endFunction_409
.aux2_b7_endExceptionCaught_411:
	popq %rcx
	jmp .aux2_b7_endFunction_409 	# return reached : end function
	addq $8, %rsp
.aux2_b7_endFunction_409:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl test_b7
 test_b7:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	movq $2, %rax
	pushq %rax
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq aux2_b7
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .test_b7_endExceptionCaught_413
	jmp .test_b7_endFunction_412
.test_b7_endExceptionCaught_413:
	popq %rcx
	cmpq %rcx, %rax
	je .test_b7_successCmp_414
	xorq %rax, %rax
	jmp .test_b7_continueCmp_415
.test_b7_successCmp_414:
	movq $1, %rax
.test_b7_continueCmp_415:
	cmpq $0, %rax
	je .test_b7_failureIf_417
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_105, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_b7_endExceptionCaught_418
	jmp .test_b7_endFunction_412
.test_b7_endExceptionCaught_418:
	jmp .test_b7_endIf_416
.test_b7_failureIf_417:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_106, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_b7_endExceptionCaught_419
	jmp .test_b7_endFunction_412
.test_b7_endExceptionCaught_419:
.test_b7_endIf_416:
.test_b7_endFunction_412:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl aux1_twisted1
 aux1_twisted1:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	movq $42, %rax
	jmp .aux1_twisted1_endFunction_420 	# return reached : end function
.aux1_twisted1_endFunction_420:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl aux2_twisted1
 aux2_twisted1:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	subq $8, %rsp
	jmp .aux2_twisted1tryBegin_423
.aux2_twisted1finally_424:
	movq -8(%rbp), %rax
	pushq %rax	# the value of expr is stored in for later
	inc %rax
	movq %rax, -8(%rbp)
	popq %rax
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -8(%rbp), %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_107, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux2_twisted1_endExceptionCaught_425
	jmp .aux2_twisted1_endFunction_421
.aux2_twisted1_endExceptionCaught_425:
	jmp .aux2_twisted1tryContinue_422 	# end of finally reached 
.aux2_twisted1tryBegin_423:
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq aux1_twisted1
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux2_twisted1_endExceptionCaught_426
	jmp .aux2_twisted1finally_424
.aux2_twisted1_endExceptionCaught_426:
	movq %rax, -8(%rbp)
	movq -8(%rbp), %rax
	pushq %rax	# the value of expr is stored in for later
	inc %rax
	movq %rax, -8(%rbp)
	popq %rax
	movq -8(%rbp), %rax
	jmp .aux2_twisted1finally_424
	jmp .aux2_twisted1_endFunction_421 	# return reached : end function
	jmp .aux2_twisted1finally_424
.aux2_twisted1tryContinue_422:
	addq $8, %rsp
.aux2_twisted1_endFunction_421:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl test_twisted1
 test_twisted1:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	movq $43, %rax
	pushq %rax
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq aux2_twisted1
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .test_twisted1_endExceptionCaught_428
	jmp .test_twisted1_endFunction_427
.test_twisted1_endExceptionCaught_428:
	popq %rcx
	cmpq %rcx, %rax
	je .test_twisted1_successCmp_429
	xorq %rax, %rax
	jmp .test_twisted1_continueCmp_430
.test_twisted1_successCmp_429:
	movq $1, %rax
.test_twisted1_continueCmp_430:
	cmpq $0, %rax
	je .test_twisted1_failureIf_432
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_108, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_twisted1_endExceptionCaught_433
	jmp .test_twisted1_endFunction_427
.test_twisted1_endExceptionCaught_433:
	jmp .test_twisted1_endIf_431
.test_twisted1_failureIf_432:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_109, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_twisted1_endExceptionCaught_434
	jmp .test_twisted1_endFunction_427
.test_twisted1_endExceptionCaught_434:
.test_twisted1_endIf_431:
.test_twisted1_endFunction_427:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl launch_test
 launch_test:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_165, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_436
	jmp .launch_test_endFunction_435
.launch_test_endExceptionCaught_436:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_111, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_437
	jmp .launch_test_endFunction_435
.launch_test_endExceptionCaught_437:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_112, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_438
	jmp .launch_test_endFunction_435
.launch_test_endExceptionCaught_438:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_113, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_439
	jmp .launch_test_endFunction_435
.launch_test_endExceptionCaught_439:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_114, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_440
	jmp .launch_test_endFunction_435
.launch_test_endExceptionCaught_440:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_161, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_441
	jmp .launch_test_endFunction_435
.launch_test_endExceptionCaught_441:
	jmp .launch_testtryBegin_443
.launch_test_E_exception_444:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_117, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_445
	jmp .launch_test_endFunction_435
.launch_test_endExceptionCaught_445:
	jmp .launch_testtryContinue_442
.launch_testtryBegin_443:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq test_throw
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_446
	movq $.exception_121, %rdx
	cmpq %rcx, %rdx
	je .launch_test_E_exception_444
	jmp .launch_test_endFunction_435
.launch_test_endExceptionCaught_446:
.launch_testtryContinue_442:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_165, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_447
	jmp .launch_test_endFunction_435
.launch_test_endExceptionCaught_447:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_119, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_448
	jmp .launch_test_endFunction_435
.launch_test_endExceptionCaught_448:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_161, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_449
	jmp .launch_test_endFunction_435
.launch_test_endExceptionCaught_449:
	jmp .launch_testtryBegin_451
.launch_test_E_exception_452:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_122, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_453
	jmp .launch_test_endFunction_435
.launch_test_endExceptionCaught_453:
	jmp .launch_testtryContinue_450
.launch_testtryBegin_451:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq test_call
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_454
	movq $.exception_121, %rdx
	cmpq %rcx, %rdx
	je .launch_test_E_exception_452
	jmp .launch_test_endFunction_435
.launch_test_endExceptionCaught_454:
.launch_testtryContinue_450:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_165, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_455
	jmp .launch_test_endFunction_435
.launch_test_endExceptionCaught_455:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_124, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_456
	jmp .launch_test_endFunction_435
.launch_test_endExceptionCaught_456:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_164, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_457
	jmp .launch_test_endFunction_435
.launch_test_endExceptionCaught_457:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq test_try_no_excep_no_finally_no_return
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_458
	jmp .launch_test_endFunction_435
.launch_test_endExceptionCaught_458:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_165, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_459
	jmp .launch_test_endFunction_435
.launch_test_endExceptionCaught_459:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_127, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_460
	jmp .launch_test_endFunction_435
.launch_test_endExceptionCaught_460:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_161, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_461
	jmp .launch_test_endFunction_435
.launch_test_endExceptionCaught_461:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq test_try_no_excep_no_finally_return
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_462
	jmp .launch_test_endFunction_435
.launch_test_endExceptionCaught_462:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_165, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_463
	jmp .launch_test_endFunction_435
.launch_test_endExceptionCaught_463:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_130, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_464
	jmp .launch_test_endFunction_435
.launch_test_endExceptionCaught_464:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_146, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_465
	jmp .launch_test_endFunction_435
.launch_test_endExceptionCaught_465:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq test_try_no_excep_finally_no_return
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_466
	jmp .launch_test_endFunction_435
.launch_test_endExceptionCaught_466:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_165, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_467
	jmp .launch_test_endFunction_435
.launch_test_endExceptionCaught_467:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_133, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_468
	jmp .launch_test_endFunction_435
.launch_test_endExceptionCaught_468:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_146, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_469
	jmp .launch_test_endFunction_435
.launch_test_endExceptionCaught_469:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq test_try_no_excep_finally_return
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_470
	jmp .launch_test_endFunction_435
.launch_test_endExceptionCaught_470:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_165, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_471
	jmp .launch_test_endFunction_435
.launch_test_endExceptionCaught_471:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_136, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_472
	jmp .launch_test_endFunction_435
.launch_test_endExceptionCaught_472:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_146, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_473
	jmp .launch_test_endFunction_435
.launch_test_endExceptionCaught_473:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq test_try_no_excep_finally_return_2
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_474
	jmp .launch_test_endFunction_435
.launch_test_endExceptionCaught_474:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_165, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_475
	jmp .launch_test_endFunction_435
.launch_test_endExceptionCaught_475:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_139, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_476
	jmp .launch_test_endFunction_435
.launch_test_endExceptionCaught_476:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_146, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_477
	jmp .launch_test_endFunction_435
.launch_test_endExceptionCaught_477:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq test_try_no_excep_finally_return_3
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_478
	jmp .launch_test_endFunction_435
.launch_test_endExceptionCaught_478:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_165, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_479
	jmp .launch_test_endFunction_435
.launch_test_endExceptionCaught_479:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_142, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_480
	jmp .launch_test_endFunction_435
.launch_test_endExceptionCaught_480:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_164, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_481
	jmp .launch_test_endFunction_435
.launch_test_endExceptionCaught_481:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq test_try_excep_finally_return_no_handler
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_482
	jmp .launch_test_endFunction_435
.launch_test_endExceptionCaught_482:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_165, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_483
	jmp .launch_test_endFunction_435
.launch_test_endExceptionCaught_483:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_145, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_484
	jmp .launch_test_endFunction_435
.launch_test_endExceptionCaught_484:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_146, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_485
	jmp .launch_test_endFunction_435
.launch_test_endExceptionCaught_485:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq test_try_excep_finally_return_handler
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_486
	jmp .launch_test_endFunction_435
.launch_test_endExceptionCaught_486:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_165, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_487
	jmp .launch_test_endFunction_435
.launch_test_endExceptionCaught_487:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_148, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_488
	jmp .launch_test_endFunction_435
.launch_test_endExceptionCaught_488:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_164, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_489
	jmp .launch_test_endFunction_435
.launch_test_endExceptionCaught_489:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq test_try_excep_in_catch
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_490
	jmp .launch_test_endFunction_435
.launch_test_endExceptionCaught_490:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_165, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_491
	jmp .launch_test_endFunction_435
.launch_test_endExceptionCaught_491:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_151, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_492
	jmp .launch_test_endFunction_435
.launch_test_endExceptionCaught_492:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_161, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_493
	jmp .launch_test_endFunction_435
.launch_test_endExceptionCaught_493:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq test_b2
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_494
	jmp .launch_test_endFunction_435
.launch_test_endExceptionCaught_494:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_165, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_495
	jmp .launch_test_endFunction_435
.launch_test_endExceptionCaught_495:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_154, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_496
	jmp .launch_test_endFunction_435
.launch_test_endExceptionCaught_496:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_161, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_497
	jmp .launch_test_endFunction_435
.launch_test_endExceptionCaught_497:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq test_b3
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_498
	jmp .launch_test_endFunction_435
.launch_test_endExceptionCaught_498:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_165, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_499
	jmp .launch_test_endFunction_435
.launch_test_endExceptionCaught_499:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_157, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_500
	jmp .launch_test_endFunction_435
.launch_test_endExceptionCaught_500:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_164, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_501
	jmp .launch_test_endFunction_435
.launch_test_endExceptionCaught_501:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq test_b6
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_502
	jmp .launch_test_endFunction_435
.launch_test_endExceptionCaught_502:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_165, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_503
	jmp .launch_test_endFunction_435
.launch_test_endExceptionCaught_503:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_160, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_504
	jmp .launch_test_endFunction_435
.launch_test_endExceptionCaught_504:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_161, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_505
	jmp .launch_test_endFunction_435
.launch_test_endExceptionCaught_505:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq test_b7
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_506
	jmp .launch_test_endFunction_435
.launch_test_endExceptionCaught_506:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_165, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_507
	jmp .launch_test_endFunction_435
.launch_test_endExceptionCaught_507:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_163, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_508
	jmp .launch_test_endFunction_435
.launch_test_endExceptionCaught_508:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_164, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_509
	jmp .launch_test_endFunction_435
.launch_test_endExceptionCaught_509:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq test_twisted1
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_510
	jmp .launch_test_endFunction_435
.launch_test_endExceptionCaught_510:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_165, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_511
	jmp .launch_test_endFunction_435
.launch_test_endExceptionCaught_511:
.launch_test_endFunction_435:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl main
 main:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq launch_test
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .main_endExceptionCaught_513
	jmp .main_endFunction_512
.main_endExceptionCaught_513:
.main_endFunction_512:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
