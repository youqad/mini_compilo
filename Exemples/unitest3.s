.data

.string_90:
	.asciz ""
	.align 8
.string_165:
	.asciz "---------------------------------------------------------\n"
	.align 8
.string_113:
	.asciz "---------------------------------------------------------\n\n\n"
	.align 8
.exception_96:
	.asciz "A"
	.align 8
.exception_92:
	.asciz "B"
	.align 8
.exception_121:
	.asciz "E"
	.align 8
.exception_75:
	.asciz "E1"
	.align 8
.exception_77:
	.asciz "E2"
	.align 8
.exception_87:
	.asciz "E20"
	.align 8
.exception_83:
	.asciz "E3"
	.align 8
.exception_79:
	.asciz "E5"
	.align 8
.exception_43:
	.asciz "Ex"
	.align 8
.exception_45:
	.asciz "Ex1"
	.align 8
.string_112:
	.asciz "Expected succeed : 31\n"
	.align 8
.exception_50:
	.asciz "Stop"
	.align 8
.string_119:
	.asciz "Test : result_call\n"
	.align 8
.string_114:
	.asciz "Test : result_throw\n"
	.align 8
.string_151:
	.asciz "Test : test_b2\n"
	.align 8
.string_154:
	.asciz "Test : test_b3\n"
	.align 8
.string_157:
	.asciz "Test : test_b6\n"
	.align 8
.string_160:
	.asciz "Test : test_b7\n"
	.align 8
.string_145:
	.asciz "Test : test_try_excep_finally_return_handler\n"
	.align 8
.string_142:
	.asciz "Test : test_try_excep_finally_return_no_handler\n"
	.align 8
.string_148:
	.asciz "Test : test_try_excep_in_catch\n"
	.align 8
.string_130:
	.asciz "Test : test_try_no_excep_finally_no_return\n"
	.align 8
.string_133:
	.asciz "Test : test_try_no_excep_finally_return\n"
	.align 8
.string_136:
	.asciz "Test : test_try_no_excep_finally_return_2\n"
	.align 8
.string_139:
	.asciz "Test : test_try_no_excep_finally_return_3\n"
	.align 8
.string_124:
	.asciz "Test : test_try_no_excep_no_finally_no_return\n"
	.align 8
.string_127:
	.asciz "Test : test_try_no_excep_no_finally_return\n"
	.align 8
.string_163:
	.asciz "Test : test_twisted1\n"
	.align 8
.string_111:
	.asciz "Tests set : 16 tests\n"
	.align 8
.exception_103:
	.asciz "Z"
	.align 8
.string_161:
	.asciz "expected : 1\n"
	.align 8
.string_164:
	.asciz "expected : 2\n"
	.align 8
.string_146:
	.asciz "expected : 3\n"
	.align 8
.string_61:
	.asciz "failed, aux_try_excep_finally_return_handler 1\n"
	.align 8
.string_63:
	.asciz "failed, aux_try_excep_finally_return_handler 2\n"
	.align 8
.string_65:
	.asciz "failed, aux_try_excep_finally_return_handler 3\n"
	.align 8
.string_69:
	.asciz "failed, aux_try_excep_finally_return_handler 4\n"
	.align 8
.string_59:
	.asciz "failed, aux_try_excep_finally_return_no_handler 3\n"
	.align 8
.string_74:
	.asciz "failed, aux_try_excep_in_catch 1\n"
	.align 8
.string_76:
	.asciz "failed, aux_try_excep_in_catch 2\n"
	.align 8
.string_78:
	.asciz "failed, aux_try_excep_in_catch 3\n"
	.align 8
.string_82:
	.asciz "failed, aux_try_excep_in_catch 4\n"
	.align 8
.string_84:
	.asciz "failed, aux_try_excep_in_catch 5\n"
	.align 8
.string_85:
	.asciz "failed, aux_try_excep_in_catch 6\n"
	.align 8
.string_86:
	.asciz "failed, aux_try_excep_in_catch 7\n"
	.align 8
.string_35:
	.asciz "failed, aux_try_no_excep_finally_return_2 1\n"
	.align 8
.string_37:
	.asciz "failed, aux_try_no_excep_finally_return_2 2\n"
	.align 8
.string_41:
	.asciz "failed, aux_try_no_excep_finally_return_2 4\n"
	.align 8
.string_44:
	.asciz "failed, aux_try_no_excep_finally_return_3 1\n"
	.align 8
.string_46:
	.asciz "failed, aux_try_no_excep_finally_return_3 2\n"
	.align 8
.string_49:
	.asciz "failed, aux_try_no_excep_finally_return_3 3\n"
	.align 8
.string_52:
	.asciz "failed, aux_try_no_excep_finally_return_3 4\n"
	.align 8
.string_94:
	.asciz "failed, test_b2\n"
	.align 8
.string_98:
	.asciz "failed, test_b3\n"
	.align 8
.string_101:
	.asciz "failed, test_b6 1\n"
	.align 8
.string_102:
	.asciz "failed, test_b6 2\n"
	.align 8
.string_106:
	.asciz "failed, test_b7\n"
	.align 8
.string_3:
	.asciz "failed, test_call\n"
	.align 8
.string_2:
	.asciz "failed, test_throw\n"
	.align 8
.string_72:
	.asciz "failed, test_try_excep_finally_return_handler 5\n"
	.align 8
.string_54:
	.asciz "failed, test_try_excep_finally_return_no_handler 1\n"
	.align 8
.string_56:
	.asciz "failed, test_try_excep_finally_return_no_handler 2\n"
	.align 8
.string_19:
	.asciz "failed, test_try_no_excep_finally_no_return 1\n"
	.align 8
.string_21:
	.asciz "failed, test_try_no_excep_finally_no_return 2\n"
	.align 8
.string_26:
	.asciz "failed, test_try_no_excep_finally_return 2\n"
	.align 8
.string_39:
	.asciz "failed, test_try_no_excep_finally_return 3\n"
	.align 8
.string_30:
	.asciz "failed, test_try_no_excep_finally_return 4\n"
	.align 8
.string_32:
	.asciz "failed, test_try_no_excep_finally_return 5\n"
	.align 8
.string_6:
	.asciz "failed, test_try_no_excep_no_finally_no_return 1\n"
	.align 8
.string_8:
	.asciz "failed, test_try_no_excep_no_finally_no_return 2\n"
	.align 8
.string_11:
	.asciz "failed, test_try_no_excep_no_finally_return 1\n"
	.align 8
.string_13:
	.asciz "failed, test_try_no_excep_no_finally_return 2\n"
	.align 8
.string_14:
	.asciz "failed, test_try_no_excep_no_finally_return 3\n"
	.align 8
.string_16:
	.asciz "failed, test_try_no_excep_no_finally_return 4\n"
	.align 8
.string_109:
	.asciz "failed, test_twisted1\n"
	.align 8
.string_67:
	.asciz "pass, aux_try_excep_finally_return_handler 1\n"
	.align 8
.string_70:
	.asciz "pass, aux_try_excep_finally_return_handler 2\n"
	.align 8
.string_58:
	.asciz "pass, aux_try_excep_finally_return_no_handler 2\n"
	.align 8
.string_80:
	.asciz "pass, aux_try_excep_in_catch 1\n"
	.align 8
.string_88:
	.asciz "pass, aux_try_excep_in_catch 2\n"
	.align 8
.string_33:
	.asciz "pass, aux_try_no_excep_finally_return_2 1\n"
	.align 8
.string_38:
	.asciz "pass, aux_try_no_excep_finally_return_2 2\n"
	.align 8
.string_40:
	.asciz "pass, aux_try_no_excep_finally_return_2 3\n"
	.align 8
.string_42:
	.asciz "pass, aux_try_no_excep_finally_return_3 1\n"
	.align 8
.string_47:
	.asciz "pass, aux_try_no_excep_finally_return_3 2\n"
	.align 8
.string_51:
	.asciz "pass, aux_try_no_excep_finally_return_3 3\n"
	.align 8
.string_122:
	.asciz "pass, result_call\n"
	.align 8
.string_117:
	.asciz "pass, result_throw\n"
	.align 8
.string_93:
	.asciz "pass, test_b2\n"
	.align 8
.string_97:
	.asciz "pass, test_b3\n"
	.align 8
.string_100:
	.asciz "pass, test_b6 1\n"
	.align 8
.string_104:
	.asciz "pass, test_b6 2\n"
	.align 8
.string_105:
	.asciz "pass, test_b7\n"
	.align 8
.string_71:
	.asciz "pass, test_try_excep_finally_return_handler 3\n"
	.align 8
.string_57:
	.asciz "pass, test_try_excep_finally_return_no_handler 1\n"
	.align 8
.string_17:
	.asciz "pass, test_try_no_excep_finally_no_return 1\n"
	.align 8
.string_22:
	.asciz "pass, test_try_no_excep_finally_no_return 2\n"
	.align 8
.string_23:
	.asciz "pass, test_try_no_excep_finally_no_return 3\n"
	.align 8
.string_24:
	.asciz "pass, test_try_no_excep_finally_return 1\n"
	.align 8
.string_29:
	.asciz "pass, test_try_no_excep_finally_return 2\n"
	.align 8
.string_31:
	.asciz "pass, test_try_no_excep_finally_return 3\n"
	.align 8
.string_4:
	.asciz "pass, test_try_no_excep_no_finally_no_return 1\n"
	.align 8
.string_9:
	.asciz "pass, test_try_no_excep_no_finally_no_return 2\n"
	.align 8
.string_15:
	.asciz "pass, test_try_no_excep_no_finally_return 1\n"
	.align 8
.string_107:
	.asciz "pass, test_twisted1 1, %d\n"
	.align 8
.string_108:
	.asciz "pass, test_twisted1 2\n"
	.align 8


.comm .exception_not_caught_166,8,8


.text

	movq $0, .exception_not_caught_166
.globl test_throw
 test_throw:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	movq $1, .exception_not_caught_166
	movq $25, %rax
	movq %rax, %r13
	movq $.exception_121, %rcx
	movq $.test_throwreturnPoint_168, %rbx
	jmp .test_throw_endFunction_167 	# exception thrown 
.test_throwreturnPoint_168: # return from a 'finally' without 'packet'
	movq %r13, %rax
	jmp .test_throw_endFunction_167 	# uncaught exception thrown : end function
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_2, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_throw_endExceptionCaught_169
	jmp .test_throw_endFunction_167	# exception still not caught by the caller
.test_throw_endExceptionCaught_169:
	movq %rax, %r13
	jmp .test_throw_endFunction_167 	# return reached : end function
.test_throw_endFunction_167:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl do_nothing
 do_nothing:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	subq $8, %rsp
	movq $5, %rax
	movq %rax, -8(%rbp)
	movq -8(%rbp), %rax
	movq %rax, %r13
	jmp .do_nothing_endFunction_170 	# return reached : end function
	addq $8, %rsp
.do_nothing_endFunction_170:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl test_call
 test_call:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq test_throw
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_call_endExceptionCaught_172
	jmp .test_call_endFunction_171	# exception still not caught by the caller
.test_call_endExceptionCaught_172:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_3, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_call_endExceptionCaught_173
	jmp .test_call_endFunction_171	# exception still not caught by the caller
.test_call_endExceptionCaught_173:
.test_call_endFunction_171:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl test_try_no_excep_no_finally_no_return
 test_try_no_excep_no_finally_no_return:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	jmp .test_try_no_excep_no_finally_no_returntryBegin_176
.test_try_no_excep_no_finally_no_return_Ex_exception_177:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_6, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_no_finally_no_return_endExceptionCaught_178
	jmp .test_try_no_excep_no_finally_no_return_endFunction_174	# exception still not caught by the caller
.test_try_no_excep_no_finally_no_return_endExceptionCaught_178:
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_no_finally_no_return_endExceptionCaught_179
	jmp .test_try_no_excep_no_finally_no_return_endFunction_174	# exception still not caught by the caller
.test_try_no_excep_no_finally_no_return_endExceptionCaught_179:
	addq $8, %rsp
	jmp .test_try_no_excep_no_finally_no_returntryContinue_175
.test_try_no_excep_no_finally_no_return_Ex1_exception_180:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_8, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_no_finally_no_return_endExceptionCaught_181
	jmp .test_try_no_excep_no_finally_no_return_endFunction_174	# exception still not caught by the caller
.test_try_no_excep_no_finally_no_return_endExceptionCaught_181:
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_no_finally_no_return_endExceptionCaught_182
	jmp .test_try_no_excep_no_finally_no_return_endFunction_174	# exception still not caught by the caller
.test_try_no_excep_no_finally_no_return_endExceptionCaught_182:
	addq $8, %rsp
	jmp .test_try_no_excep_no_finally_no_returntryContinue_175
.test_try_no_excep_no_finally_no_returntryBegin_176:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_no_finally_no_return_endExceptionCaught_183
	movq $.exception_43, %rdx
	cmpq %rcx, %rdx
	je .test_try_no_excep_no_finally_no_return_Ex_exception_177
	movq $.exception_45, %rdx
	cmpq %rcx, %rdx
	je .test_try_no_excep_no_finally_no_return_Ex1_exception_180
	jmp .test_try_no_excep_no_finally_no_return_endFunction_174	# exception still not caught by the caller
.test_try_no_excep_no_finally_no_return_endExceptionCaught_183:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_4, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_no_finally_no_return_endExceptionCaught_184
	movq $.exception_43, %rdx
	cmpq %rcx, %rdx
	je .test_try_no_excep_no_finally_no_return_Ex_exception_177
	movq $.exception_45, %rdx
	cmpq %rcx, %rdx
	je .test_try_no_excep_no_finally_no_return_Ex1_exception_180
	jmp .test_try_no_excep_no_finally_no_return_endFunction_174	# exception still not caught by the caller
.test_try_no_excep_no_finally_no_return_endExceptionCaught_184:
.test_try_no_excep_no_finally_no_returntryContinue_175:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_9, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_no_finally_no_return_endExceptionCaught_185
	jmp .test_try_no_excep_no_finally_no_return_endFunction_174	# exception still not caught by the caller
.test_try_no_excep_no_finally_no_return_endExceptionCaught_185:
.test_try_no_excep_no_finally_no_return_endFunction_174:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl aux_try_no_excep_no_finally_return
 aux_try_no_excep_no_finally_return:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	jmp .aux_try_no_excep_no_finally_returntryBegin_188
.aux_try_no_excep_no_finally_return_Ex_exception_189:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_11, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_no_finally_return_endExceptionCaught_190
	jmp .aux_try_no_excep_no_finally_return_endFunction_186	# exception still not caught by the caller
.aux_try_no_excep_no_finally_return_endExceptionCaught_190:
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_no_finally_return_endExceptionCaught_191
	jmp .aux_try_no_excep_no_finally_return_endFunction_186	# exception still not caught by the caller
.aux_try_no_excep_no_finally_return_endExceptionCaught_191:
	addq $8, %rsp
	jmp .aux_try_no_excep_no_finally_returntryContinue_187
.aux_try_no_excep_no_finally_return_Ex1_exception_192:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_13, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_no_finally_return_endExceptionCaught_193
	jmp .aux_try_no_excep_no_finally_return_endFunction_186	# exception still not caught by the caller
.aux_try_no_excep_no_finally_return_endExceptionCaught_193:
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_no_finally_return_endExceptionCaught_194
	jmp .aux_try_no_excep_no_finally_return_endFunction_186	# exception still not caught by the caller
.aux_try_no_excep_no_finally_return_endExceptionCaught_194:
	addq $8, %rsp
	jmp .aux_try_no_excep_no_finally_returntryContinue_187
.aux_try_no_excep_no_finally_returntryBegin_188:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_no_finally_return_endExceptionCaught_195
	movq $.exception_43, %rdx
	cmpq %rcx, %rdx
	je .aux_try_no_excep_no_finally_return_Ex_exception_189
	movq $.exception_45, %rdx
	cmpq %rcx, %rdx
	je .aux_try_no_excep_no_finally_return_Ex1_exception_192
	jmp .aux_try_no_excep_no_finally_return_endFunction_186	# exception still not caught by the caller
.aux_try_no_excep_no_finally_return_endExceptionCaught_195:
	movq $5, %rax
	movq %rax, %r13
	jmp .aux_try_no_excep_no_finally_return_endFunction_186 	# return reached : end function
.aux_try_no_excep_no_finally_returntryContinue_187:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_14, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_no_finally_return_endExceptionCaught_196
	jmp .aux_try_no_excep_no_finally_return_endFunction_186	# exception still not caught by the caller
.aux_try_no_excep_no_finally_return_endExceptionCaught_196:
.aux_try_no_excep_no_finally_return_endFunction_186:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl test_try_no_excep_no_finally_return
 test_try_no_excep_no_finally_return:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	movq $5, %rax
	pushq %rax
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq aux_try_no_excep_no_finally_return
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_no_finally_return_endExceptionCaught_198
	jmp .test_try_no_excep_no_finally_return_endFunction_197	# exception still not caught by the caller
.test_try_no_excep_no_finally_return_endExceptionCaught_198:
	popq %rcx
	cmpq %rcx, %rax
	je .test_try_no_excep_no_finally_return_successCmp_199
	xorq %rax, %rax
	jmp .test_try_no_excep_no_finally_return_continueCmp_200
.test_try_no_excep_no_finally_return_successCmp_199:
	movq $1, %rax
.test_try_no_excep_no_finally_return_continueCmp_200:
	cmpq $0, %rax
	je .test_try_no_excep_no_finally_return_failureIf_202
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_15, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_no_finally_return_endExceptionCaught_203
	jmp .test_try_no_excep_no_finally_return_endFunction_197	# exception still not caught by the caller
.test_try_no_excep_no_finally_return_endExceptionCaught_203:
	jmp .test_try_no_excep_no_finally_return_endIf_201
.test_try_no_excep_no_finally_return_failureIf_202:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_16, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_no_finally_return_endExceptionCaught_204
	jmp .test_try_no_excep_no_finally_return_endFunction_197	# exception still not caught by the caller
.test_try_no_excep_no_finally_return_endExceptionCaught_204:
.test_try_no_excep_no_finally_return_endIf_201:
.test_try_no_excep_no_finally_return_endFunction_197:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl test_try_no_excep_finally_no_return
 test_try_no_excep_finally_no_return:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	jmp .test_try_no_excep_finally_no_returntryBegin_207
.test_try_no_excep_finally_no_returnfinally_208:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_finally_no_return_endExceptionCaught_209
	jmp .test_try_no_excep_finally_no_return_endFunction_205	# exception still not caught by the caller
.test_try_no_excep_finally_no_return_endExceptionCaught_209:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_22, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_finally_no_return_endExceptionCaught_210
	jmp .test_try_no_excep_finally_no_return_endFunction_205	# exception still not caught by the caller
.test_try_no_excep_finally_no_return_endExceptionCaught_210:
	jmp *%rbx
.test_try_no_excep_finally_no_return_Ex_exception_211:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_19, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_finally_no_return_endExceptionCaught_212
	movq $.test_try_no_excep_finally_no_returnreturnPoint_213, %rbx
	jmp .test_try_no_excep_finally_no_returnfinally_208
.test_try_no_excep_finally_no_returnreturnPoint_213: # return from a 'finally' without 'packet'
	jmp .test_try_no_excep_finally_no_return_endFunction_205	# exception still not caught by the caller
.test_try_no_excep_finally_no_return_endExceptionCaught_212:
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_finally_no_return_endExceptionCaught_214
	movq $.test_try_no_excep_finally_no_returnreturnPoint_215, %rbx
	jmp .test_try_no_excep_finally_no_returnfinally_208
.test_try_no_excep_finally_no_returnreturnPoint_215: # return from a 'finally' without 'packet'
	jmp .test_try_no_excep_finally_no_return_endFunction_205	# exception still not caught by the caller
.test_try_no_excep_finally_no_return_endExceptionCaught_214:
	addq $8, %rsp
	movq $.test_try_no_excep_finally_no_returntryContinue_206, %rbx
	jmp .test_try_no_excep_finally_no_returnfinally_208
.test_try_no_excep_finally_no_return_Ex1_exception_216:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_21, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_finally_no_return_endExceptionCaught_217
	movq $.test_try_no_excep_finally_no_returnreturnPoint_218, %rbx
	jmp .test_try_no_excep_finally_no_returnfinally_208
.test_try_no_excep_finally_no_returnreturnPoint_218: # return from a 'finally' without 'packet'
	jmp .test_try_no_excep_finally_no_return_endFunction_205	# exception still not caught by the caller
.test_try_no_excep_finally_no_return_endExceptionCaught_217:
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_finally_no_return_endExceptionCaught_219
	movq $.test_try_no_excep_finally_no_returnreturnPoint_220, %rbx
	jmp .test_try_no_excep_finally_no_returnfinally_208
.test_try_no_excep_finally_no_returnreturnPoint_220: # return from a 'finally' without 'packet'
	jmp .test_try_no_excep_finally_no_return_endFunction_205	# exception still not caught by the caller
.test_try_no_excep_finally_no_return_endExceptionCaught_219:
	addq $8, %rsp
	movq $.test_try_no_excep_finally_no_returntryContinue_206, %rbx
	jmp .test_try_no_excep_finally_no_returnfinally_208
.test_try_no_excep_finally_no_returntryBegin_207:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_finally_no_return_endExceptionCaught_221
	movq $.exception_43, %rdx
	cmpq %rcx, %rdx
	je .test_try_no_excep_finally_no_return_Ex_exception_211
	movq $.exception_45, %rdx
	cmpq %rcx, %rdx
	je .test_try_no_excep_finally_no_return_Ex1_exception_216
	movq $.test_try_no_excep_finally_no_returnreturnPoint_222, %rbx
	jmp .test_try_no_excep_finally_no_returnfinally_208
.test_try_no_excep_finally_no_returnreturnPoint_222: # return from a 'finally' without 'packet'
	jmp .test_try_no_excep_finally_no_return_endFunction_205	# exception still not caught by the caller
.test_try_no_excep_finally_no_return_endExceptionCaught_221:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_17, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_finally_no_return_endExceptionCaught_223
	movq $.exception_43, %rdx
	cmpq %rcx, %rdx
	je .test_try_no_excep_finally_no_return_Ex_exception_211
	movq $.exception_45, %rdx
	cmpq %rcx, %rdx
	je .test_try_no_excep_finally_no_return_Ex1_exception_216
	movq $.test_try_no_excep_finally_no_returnreturnPoint_224, %rbx
	jmp .test_try_no_excep_finally_no_returnfinally_208
.test_try_no_excep_finally_no_returnreturnPoint_224: # return from a 'finally' without 'packet'
	jmp .test_try_no_excep_finally_no_return_endFunction_205	# exception still not caught by the caller
.test_try_no_excep_finally_no_return_endExceptionCaught_223:
	movq $.test_try_no_excep_finally_no_returntryContinue_206, %rbx
	jmp .test_try_no_excep_finally_no_returnfinally_208
.test_try_no_excep_finally_no_returntryContinue_206:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_23, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_finally_no_return_endExceptionCaught_225
	jmp .test_try_no_excep_finally_no_return_endFunction_205	# exception still not caught by the caller
.test_try_no_excep_finally_no_return_endExceptionCaught_225:
.test_try_no_excep_finally_no_return_endFunction_205:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl aux_try_no_excep_finally_return
 aux_try_no_excep_finally_return:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	jmp .aux_try_no_excep_finally_returntryBegin_228
.aux_try_no_excep_finally_returnfinally_229:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_endExceptionCaught_230
	jmp .aux_try_no_excep_finally_return_endFunction_226	# exception still not caught by the caller
.aux_try_no_excep_finally_return_endExceptionCaught_230:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_29, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_endExceptionCaught_231
	jmp .aux_try_no_excep_finally_return_endFunction_226	# exception still not caught by the caller
.aux_try_no_excep_finally_return_endExceptionCaught_231:
	jmp *%rbx
.aux_try_no_excep_finally_return_Ex_exception_232:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_26, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_endExceptionCaught_233
	movq $.aux_try_no_excep_finally_returnreturnPoint_234, %rbx
	jmp .aux_try_no_excep_finally_returnfinally_229
.aux_try_no_excep_finally_returnreturnPoint_234: # return from a 'finally' without 'packet'
	jmp .aux_try_no_excep_finally_return_endFunction_226	# exception still not caught by the caller
.aux_try_no_excep_finally_return_endExceptionCaught_233:
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_endExceptionCaught_235
	movq $.aux_try_no_excep_finally_returnreturnPoint_236, %rbx
	jmp .aux_try_no_excep_finally_returnfinally_229
.aux_try_no_excep_finally_returnreturnPoint_236: # return from a 'finally' without 'packet'
	jmp .aux_try_no_excep_finally_return_endFunction_226	# exception still not caught by the caller
.aux_try_no_excep_finally_return_endExceptionCaught_235:
	addq $8, %rsp
	movq $.aux_try_no_excep_finally_returntryContinue_227, %rbx
	jmp .aux_try_no_excep_finally_returnfinally_229
.aux_try_no_excep_finally_return_Ex1_exception_237:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_39, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_endExceptionCaught_238
	movq $.aux_try_no_excep_finally_returnreturnPoint_239, %rbx
	jmp .aux_try_no_excep_finally_returnfinally_229
.aux_try_no_excep_finally_returnreturnPoint_239: # return from a 'finally' without 'packet'
	jmp .aux_try_no_excep_finally_return_endFunction_226	# exception still not caught by the caller
.aux_try_no_excep_finally_return_endExceptionCaught_238:
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_endExceptionCaught_240
	movq $.aux_try_no_excep_finally_returnreturnPoint_241, %rbx
	jmp .aux_try_no_excep_finally_returnfinally_229
.aux_try_no_excep_finally_returnreturnPoint_241: # return from a 'finally' without 'packet'
	jmp .aux_try_no_excep_finally_return_endFunction_226	# exception still not caught by the caller
.aux_try_no_excep_finally_return_endExceptionCaught_240:
	addq $8, %rsp
	movq $.aux_try_no_excep_finally_returntryContinue_227, %rbx
	jmp .aux_try_no_excep_finally_returnfinally_229
.aux_try_no_excep_finally_returntryBegin_228:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_endExceptionCaught_242
	movq $.exception_43, %rdx
	cmpq %rcx, %rdx
	je .aux_try_no_excep_finally_return_Ex_exception_232
	movq $.exception_45, %rdx
	cmpq %rcx, %rdx
	je .aux_try_no_excep_finally_return_Ex1_exception_237
	movq $.aux_try_no_excep_finally_returnreturnPoint_243, %rbx
	jmp .aux_try_no_excep_finally_returnfinally_229
.aux_try_no_excep_finally_returnreturnPoint_243: # return from a 'finally' without 'packet'
	jmp .aux_try_no_excep_finally_return_endFunction_226	# exception still not caught by the caller
.aux_try_no_excep_finally_return_endExceptionCaught_242:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_24, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_endExceptionCaught_244
	movq $.exception_43, %rdx
	cmpq %rcx, %rdx
	je .aux_try_no_excep_finally_return_Ex_exception_232
	movq $.exception_45, %rdx
	cmpq %rcx, %rdx
	je .aux_try_no_excep_finally_return_Ex1_exception_237
	movq $.aux_try_no_excep_finally_returnreturnPoint_245, %rbx
	jmp .aux_try_no_excep_finally_returnfinally_229
.aux_try_no_excep_finally_returnreturnPoint_245: # return from a 'finally' without 'packet'
	jmp .aux_try_no_excep_finally_return_endFunction_226	# exception still not caught by the caller
.aux_try_no_excep_finally_return_endExceptionCaught_244:
	movq $5, %rax
	movq %rax, %r13
	movq $.aux_try_no_excep_finally_returnreturnPoint_246, %rbx
	jmp .aux_try_no_excep_finally_returnfinally_229
.aux_try_no_excep_finally_returnreturnPoint_246: # return from a 'finally' without 'packet'
	movq %r13, %rax
	jmp .aux_try_no_excep_finally_return_endFunction_226 	# return reached : end function
	movq $.aux_try_no_excep_finally_returntryContinue_227, %rbx
	jmp .aux_try_no_excep_finally_returnfinally_229
.aux_try_no_excep_finally_returntryContinue_227:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_30, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_endExceptionCaught_247
	jmp .aux_try_no_excep_finally_return_endFunction_226	# exception still not caught by the caller
.aux_try_no_excep_finally_return_endExceptionCaught_247:
	movq $0, %rax
	movq %rax, %r13
	jmp .aux_try_no_excep_finally_return_endFunction_226 	# return reached : end function
.aux_try_no_excep_finally_return_endFunction_226:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl test_try_no_excep_finally_return
 test_try_no_excep_finally_return:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	movq $5, %rax
	pushq %rax
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq aux_try_no_excep_finally_return
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_finally_return_endExceptionCaught_249
	jmp .test_try_no_excep_finally_return_endFunction_248	# exception still not caught by the caller
.test_try_no_excep_finally_return_endExceptionCaught_249:
	popq %rcx
	cmpq %rcx, %rax
	je .test_try_no_excep_finally_return_successCmp_250
	xorq %rax, %rax
	jmp .test_try_no_excep_finally_return_continueCmp_251
.test_try_no_excep_finally_return_successCmp_250:
	movq $1, %rax
.test_try_no_excep_finally_return_continueCmp_251:
	cmpq $0, %rax
	je .test_try_no_excep_finally_return_failureIf_253
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_31, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_finally_return_endExceptionCaught_254
	jmp .test_try_no_excep_finally_return_endFunction_248	# exception still not caught by the caller
.test_try_no_excep_finally_return_endExceptionCaught_254:
	jmp .test_try_no_excep_finally_return_endIf_252
.test_try_no_excep_finally_return_failureIf_253:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_32, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_finally_return_endExceptionCaught_255
	jmp .test_try_no_excep_finally_return_endFunction_248	# exception still not caught by the caller
.test_try_no_excep_finally_return_endExceptionCaught_255:
.test_try_no_excep_finally_return_endIf_252:
.test_try_no_excep_finally_return_endFunction_248:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl aux_try_no_excep_finally_return_2
 aux_try_no_excep_finally_return_2:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	jmp .aux_try_no_excep_finally_return_2tryBegin_258
.aux_try_no_excep_finally_return_2finally_259:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_2_endExceptionCaught_260
	jmp .aux_try_no_excep_finally_return_2_endFunction_256	# exception still not caught by the caller
.aux_try_no_excep_finally_return_2_endExceptionCaught_260:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_38, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_2_endExceptionCaught_261
	jmp .aux_try_no_excep_finally_return_2_endFunction_256	# exception still not caught by the caller
.aux_try_no_excep_finally_return_2_endExceptionCaught_261:
	movq $0, .exception_not_caught_166
	movq $3, %rax
	movq %rax, %r13
	jmp .aux_try_no_excep_finally_return_2_endFunction_256 	# return reached : end function
	jmp *%rbx
.aux_try_no_excep_finally_return_2_Ex_exception_262:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_35, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_2_endExceptionCaught_263
	movq $.aux_try_no_excep_finally_return_2returnPoint_264, %rbx
	jmp .aux_try_no_excep_finally_return_2finally_259
.aux_try_no_excep_finally_return_2returnPoint_264: # return from a 'finally' without 'packet'
	jmp .aux_try_no_excep_finally_return_2_endFunction_256	# exception still not caught by the caller
.aux_try_no_excep_finally_return_2_endExceptionCaught_263:
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_2_endExceptionCaught_265
	movq $.aux_try_no_excep_finally_return_2returnPoint_266, %rbx
	jmp .aux_try_no_excep_finally_return_2finally_259
.aux_try_no_excep_finally_return_2returnPoint_266: # return from a 'finally' without 'packet'
	jmp .aux_try_no_excep_finally_return_2_endFunction_256	# exception still not caught by the caller
.aux_try_no_excep_finally_return_2_endExceptionCaught_265:
	addq $8, %rsp
	movq $.aux_try_no_excep_finally_return_2tryContinue_257, %rbx
	jmp .aux_try_no_excep_finally_return_2finally_259
.aux_try_no_excep_finally_return_2_Ex1_exception_267:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_37, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_2_endExceptionCaught_268
	movq $.aux_try_no_excep_finally_return_2returnPoint_269, %rbx
	jmp .aux_try_no_excep_finally_return_2finally_259
.aux_try_no_excep_finally_return_2returnPoint_269: # return from a 'finally' without 'packet'
	jmp .aux_try_no_excep_finally_return_2_endFunction_256	# exception still not caught by the caller
.aux_try_no_excep_finally_return_2_endExceptionCaught_268:
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_2_endExceptionCaught_270
	movq $.aux_try_no_excep_finally_return_2returnPoint_271, %rbx
	jmp .aux_try_no_excep_finally_return_2finally_259
.aux_try_no_excep_finally_return_2returnPoint_271: # return from a 'finally' without 'packet'
	jmp .aux_try_no_excep_finally_return_2_endFunction_256	# exception still not caught by the caller
.aux_try_no_excep_finally_return_2_endExceptionCaught_270:
	addq $8, %rsp
	movq $.aux_try_no_excep_finally_return_2tryContinue_257, %rbx
	jmp .aux_try_no_excep_finally_return_2finally_259
.aux_try_no_excep_finally_return_2tryBegin_258:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_2_endExceptionCaught_272
	movq $.exception_43, %rdx
	cmpq %rcx, %rdx
	je .aux_try_no_excep_finally_return_2_Ex_exception_262
	movq $.exception_45, %rdx
	cmpq %rcx, %rdx
	je .aux_try_no_excep_finally_return_2_Ex1_exception_267
	movq $.aux_try_no_excep_finally_return_2returnPoint_273, %rbx
	jmp .aux_try_no_excep_finally_return_2finally_259
.aux_try_no_excep_finally_return_2returnPoint_273: # return from a 'finally' without 'packet'
	jmp .aux_try_no_excep_finally_return_2_endFunction_256	# exception still not caught by the caller
.aux_try_no_excep_finally_return_2_endExceptionCaught_272:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_33, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_2_endExceptionCaught_274
	movq $.exception_43, %rdx
	cmpq %rcx, %rdx
	je .aux_try_no_excep_finally_return_2_Ex_exception_262
	movq $.exception_45, %rdx
	cmpq %rcx, %rdx
	je .aux_try_no_excep_finally_return_2_Ex1_exception_267
	movq $.aux_try_no_excep_finally_return_2returnPoint_275, %rbx
	jmp .aux_try_no_excep_finally_return_2finally_259
.aux_try_no_excep_finally_return_2returnPoint_275: # return from a 'finally' without 'packet'
	jmp .aux_try_no_excep_finally_return_2_endFunction_256	# exception still not caught by the caller
.aux_try_no_excep_finally_return_2_endExceptionCaught_274:
	movq $5, %rax
	movq %rax, %r13
	movq $.aux_try_no_excep_finally_return_2returnPoint_276, %rbx
	jmp .aux_try_no_excep_finally_return_2finally_259
.aux_try_no_excep_finally_return_2returnPoint_276: # return from a 'finally' without 'packet'
	movq %r13, %rax
	jmp .aux_try_no_excep_finally_return_2_endFunction_256 	# return reached : end function
	movq $.aux_try_no_excep_finally_return_2tryContinue_257, %rbx
	jmp .aux_try_no_excep_finally_return_2finally_259
.aux_try_no_excep_finally_return_2tryContinue_257:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_39, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_2_endExceptionCaught_277
	jmp .aux_try_no_excep_finally_return_2_endFunction_256	# exception still not caught by the caller
.aux_try_no_excep_finally_return_2_endExceptionCaught_277:
	movq $0, %rax
	movq %rax, %r13
	jmp .aux_try_no_excep_finally_return_2_endFunction_256 	# return reached : end function
.aux_try_no_excep_finally_return_2_endFunction_256:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl test_try_no_excep_finally_return_2
 test_try_no_excep_finally_return_2:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	movq $3, %rax
	pushq %rax
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq aux_try_no_excep_finally_return_2
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_finally_return_2_endExceptionCaught_279
	jmp .test_try_no_excep_finally_return_2_endFunction_278	# exception still not caught by the caller
.test_try_no_excep_finally_return_2_endExceptionCaught_279:
	popq %rcx
	cmpq %rcx, %rax
	je .test_try_no_excep_finally_return_2_successCmp_280
	xorq %rax, %rax
	jmp .test_try_no_excep_finally_return_2_continueCmp_281
.test_try_no_excep_finally_return_2_successCmp_280:
	movq $1, %rax
.test_try_no_excep_finally_return_2_continueCmp_281:
	cmpq $0, %rax
	je .test_try_no_excep_finally_return_2_failureIf_283
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_40, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_finally_return_2_endExceptionCaught_284
	jmp .test_try_no_excep_finally_return_2_endFunction_278	# exception still not caught by the caller
.test_try_no_excep_finally_return_2_endExceptionCaught_284:
	jmp .test_try_no_excep_finally_return_2_endIf_282
.test_try_no_excep_finally_return_2_failureIf_283:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_41, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_finally_return_2_endExceptionCaught_285
	jmp .test_try_no_excep_finally_return_2_endFunction_278	# exception still not caught by the caller
.test_try_no_excep_finally_return_2_endExceptionCaught_285:
.test_try_no_excep_finally_return_2_endIf_282:
.test_try_no_excep_finally_return_2_endFunction_278:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl aux_try_no_excep_finally_return_3
 aux_try_no_excep_finally_return_3:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	jmp .aux_try_no_excep_finally_return_3tryBegin_288
.aux_try_no_excep_finally_return_3finally_289:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_3_endExceptionCaught_290
	jmp .aux_try_no_excep_finally_return_3_endFunction_286	# exception still not caught by the caller
.aux_try_no_excep_finally_return_3_endExceptionCaught_290:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_47, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_3_endExceptionCaught_291
	jmp .aux_try_no_excep_finally_return_3_endFunction_286	# exception still not caught by the caller
.aux_try_no_excep_finally_return_3_endExceptionCaught_291:
	movq $1, .exception_not_caught_166
	movq $0, %rax
	movq %rax, %r13
	movq $.exception_50, %rcx
	movq $.aux_try_no_excep_finally_return_3returnPoint_292, %rbx
	jmp .aux_try_no_excep_finally_return_3_endFunction_286 	# exception thrown 
.aux_try_no_excep_finally_return_3returnPoint_292: # return from a 'finally' without 'packet'
	movq %r13, %rax
	jmp .aux_try_no_excep_finally_return_3_endFunction_286 	# uncaught exception thrown : end function
	jmp *%rbx
.aux_try_no_excep_finally_return_3_Ex_exception_293:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_44, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_3_endExceptionCaught_294
	movq $.aux_try_no_excep_finally_return_3returnPoint_295, %rbx
	jmp .aux_try_no_excep_finally_return_3finally_289
.aux_try_no_excep_finally_return_3returnPoint_295: # return from a 'finally' without 'packet'
	jmp .aux_try_no_excep_finally_return_3_endFunction_286	# exception still not caught by the caller
.aux_try_no_excep_finally_return_3_endExceptionCaught_294:
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_3_endExceptionCaught_296
	movq $.aux_try_no_excep_finally_return_3returnPoint_297, %rbx
	jmp .aux_try_no_excep_finally_return_3finally_289
.aux_try_no_excep_finally_return_3returnPoint_297: # return from a 'finally' without 'packet'
	jmp .aux_try_no_excep_finally_return_3_endFunction_286	# exception still not caught by the caller
.aux_try_no_excep_finally_return_3_endExceptionCaught_296:
	addq $8, %rsp
	movq $.aux_try_no_excep_finally_return_3tryContinue_287, %rbx
	jmp .aux_try_no_excep_finally_return_3finally_289
.aux_try_no_excep_finally_return_3_Ex1_exception_298:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_46, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_3_endExceptionCaught_299
	movq $.aux_try_no_excep_finally_return_3returnPoint_300, %rbx
	jmp .aux_try_no_excep_finally_return_3finally_289
.aux_try_no_excep_finally_return_3returnPoint_300: # return from a 'finally' without 'packet'
	jmp .aux_try_no_excep_finally_return_3_endFunction_286	# exception still not caught by the caller
.aux_try_no_excep_finally_return_3_endExceptionCaught_299:
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_3_endExceptionCaught_301
	movq $.aux_try_no_excep_finally_return_3returnPoint_302, %rbx
	jmp .aux_try_no_excep_finally_return_3finally_289
.aux_try_no_excep_finally_return_3returnPoint_302: # return from a 'finally' without 'packet'
	jmp .aux_try_no_excep_finally_return_3_endFunction_286	# exception still not caught by the caller
.aux_try_no_excep_finally_return_3_endExceptionCaught_301:
	addq $8, %rsp
	movq $.aux_try_no_excep_finally_return_3tryContinue_287, %rbx
	jmp .aux_try_no_excep_finally_return_3finally_289
.aux_try_no_excep_finally_return_3tryBegin_288:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_3_endExceptionCaught_303
	movq $.exception_43, %rdx
	cmpq %rcx, %rdx
	je .aux_try_no_excep_finally_return_3_Ex_exception_293
	movq $.exception_45, %rdx
	cmpq %rcx, %rdx
	je .aux_try_no_excep_finally_return_3_Ex1_exception_298
	movq $.aux_try_no_excep_finally_return_3returnPoint_304, %rbx
	jmp .aux_try_no_excep_finally_return_3finally_289
.aux_try_no_excep_finally_return_3returnPoint_304: # return from a 'finally' without 'packet'
	jmp .aux_try_no_excep_finally_return_3_endFunction_286	# exception still not caught by the caller
.aux_try_no_excep_finally_return_3_endExceptionCaught_303:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_42, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_3_endExceptionCaught_305
	movq $.exception_43, %rdx
	cmpq %rcx, %rdx
	je .aux_try_no_excep_finally_return_3_Ex_exception_293
	movq $.exception_45, %rdx
	cmpq %rcx, %rdx
	je .aux_try_no_excep_finally_return_3_Ex1_exception_298
	movq $.aux_try_no_excep_finally_return_3returnPoint_306, %rbx
	jmp .aux_try_no_excep_finally_return_3finally_289
.aux_try_no_excep_finally_return_3returnPoint_306: # return from a 'finally' without 'packet'
	jmp .aux_try_no_excep_finally_return_3_endFunction_286	# exception still not caught by the caller
.aux_try_no_excep_finally_return_3_endExceptionCaught_305:
	movq $5, %rax
	movq %rax, %r13
	movq $.aux_try_no_excep_finally_return_3returnPoint_307, %rbx
	jmp .aux_try_no_excep_finally_return_3finally_289
.aux_try_no_excep_finally_return_3returnPoint_307: # return from a 'finally' without 'packet'
	movq %r13, %rax
	jmp .aux_try_no_excep_finally_return_3_endFunction_286 	# return reached : end function
	movq $.aux_try_no_excep_finally_return_3tryContinue_287, %rbx
	jmp .aux_try_no_excep_finally_return_3finally_289
.aux_try_no_excep_finally_return_3tryContinue_287:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_49, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_no_excep_finally_return_3_endExceptionCaught_308
	jmp .aux_try_no_excep_finally_return_3_endFunction_286	# exception still not caught by the caller
.aux_try_no_excep_finally_return_3_endExceptionCaught_308:
	movq $0, %rax
	movq %rax, %r13
	jmp .aux_try_no_excep_finally_return_3_endFunction_286 	# return reached : end function
.aux_try_no_excep_finally_return_3_endFunction_286:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl test_try_no_excep_finally_return_3
 test_try_no_excep_finally_return_3:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	jmp .test_try_no_excep_finally_return_3tryBegin_311
.test_try_no_excep_finally_return_3_Stop_exception_312:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_51, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_finally_return_3_endExceptionCaught_313
	jmp .test_try_no_excep_finally_return_3_endFunction_309	# exception still not caught by the caller
.test_try_no_excep_finally_return_3_endExceptionCaught_313:
	movq $0, %rax
	movq %rax, %r13
	jmp .test_try_no_excep_finally_return_3_endFunction_309 	# return reached : end function
	addq $8, %rsp
	jmp .test_try_no_excep_finally_return_3tryContinue_310
.test_try_no_excep_finally_return_3tryBegin_311:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq aux_try_no_excep_finally_return_3
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_finally_return_3_endExceptionCaught_314
	movq $.exception_50, %rdx
	cmpq %rcx, %rdx
	je .test_try_no_excep_finally_return_3_Stop_exception_312
	jmp .test_try_no_excep_finally_return_3_endFunction_309	# exception still not caught by the caller
.test_try_no_excep_finally_return_3_endExceptionCaught_314:
.test_try_no_excep_finally_return_3tryContinue_310:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_52, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_try_no_excep_finally_return_3_endExceptionCaught_315
	jmp .test_try_no_excep_finally_return_3_endFunction_309	# exception still not caught by the caller
.test_try_no_excep_finally_return_3_endExceptionCaught_315:
.test_try_no_excep_finally_return_3_endFunction_309:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl aux_try_excep_finally_return_no_handler
 aux_try_excep_finally_return_no_handler:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	jmp .aux_try_excep_finally_return_no_handlertryBegin_318
.aux_try_excep_finally_return_no_handlerfinally_319:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_57, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_finally_return_no_handler_endExceptionCaught_320
	jmp .aux_try_excep_finally_return_no_handler_endFunction_316	# exception still not caught by the caller
.aux_try_excep_finally_return_no_handler_endExceptionCaught_320:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_finally_return_no_handler_endExceptionCaught_321
	jmp .aux_try_excep_finally_return_no_handler_endFunction_316	# exception still not caught by the caller
.aux_try_excep_finally_return_no_handler_endExceptionCaught_321:
	movq $0, .exception_not_caught_166
	movq $9, %rax
	movq %rax, %r13
	jmp .aux_try_excep_finally_return_no_handler_endFunction_316 	# return reached : end function
	jmp *%rbx
.aux_try_excep_finally_return_no_handler_E2_exception_322:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_finally_return_no_handler_endExceptionCaught_323
	movq $.aux_try_excep_finally_return_no_handlerreturnPoint_324, %rbx
	jmp .aux_try_excep_finally_return_no_handlerfinally_319
.aux_try_excep_finally_return_no_handlerreturnPoint_324: # return from a 'finally' without 'packet'
	jmp .aux_try_excep_finally_return_no_handler_endFunction_316	# exception still not caught by the caller
.aux_try_excep_finally_return_no_handler_endExceptionCaught_323:
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_56, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_finally_return_no_handler_endExceptionCaught_325
	movq $.aux_try_excep_finally_return_no_handlerreturnPoint_326, %rbx
	jmp .aux_try_excep_finally_return_no_handlerfinally_319
.aux_try_excep_finally_return_no_handlerreturnPoint_326: # return from a 'finally' without 'packet'
	jmp .aux_try_excep_finally_return_no_handler_endFunction_316	# exception still not caught by the caller
.aux_try_excep_finally_return_no_handler_endExceptionCaught_325:
	addq $8, %rsp
	movq $.aux_try_excep_finally_return_no_handlertryContinue_317, %rbx
	jmp .aux_try_excep_finally_return_no_handlerfinally_319
.aux_try_excep_finally_return_no_handlertryBegin_318:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_finally_return_no_handler_endExceptionCaught_327
	movq $.exception_77, %rdx
	cmpq %rcx, %rdx
	je .aux_try_excep_finally_return_no_handler_E2_exception_322
	movq $.aux_try_excep_finally_return_no_handlerreturnPoint_328, %rbx
	jmp .aux_try_excep_finally_return_no_handlerfinally_319
.aux_try_excep_finally_return_no_handlerreturnPoint_328: # return from a 'finally' without 'packet'
	jmp .aux_try_excep_finally_return_no_handler_endFunction_316	# exception still not caught by the caller
.aux_try_excep_finally_return_no_handler_endExceptionCaught_327:
	movq $1, .exception_not_caught_166
	movq $5, %rax
	movq %rax, %r13
	movq $.exception_75, %rcx
	movq $.aux_try_excep_finally_return_no_handlerreturnPoint_329, %rbx
	jmp .aux_try_excep_finally_return_no_handlerfinally_319 	# exception thrown 
.aux_try_excep_finally_return_no_handlerreturnPoint_329: # return from a 'finally' without 'packet'
	movq %r13, %rax
	jmp .aux_try_excep_finally_return_no_handler_endFunction_316 	# uncaught exception thrown : end function
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_54, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_finally_return_no_handler_endExceptionCaught_330
	movq $.exception_77, %rdx
	cmpq %rcx, %rdx
	je .aux_try_excep_finally_return_no_handler_E2_exception_322
	movq $.aux_try_excep_finally_return_no_handlerreturnPoint_331, %rbx
	jmp .aux_try_excep_finally_return_no_handlerfinally_319
.aux_try_excep_finally_return_no_handlerreturnPoint_331: # return from a 'finally' without 'packet'
	jmp .aux_try_excep_finally_return_no_handler_endFunction_316	# exception still not caught by the caller
.aux_try_excep_finally_return_no_handler_endExceptionCaught_330:
	movq $1, %rax
	movq %rax, %r13
	movq $.aux_try_excep_finally_return_no_handlerreturnPoint_332, %rbx
	jmp .aux_try_excep_finally_return_no_handlerfinally_319
.aux_try_excep_finally_return_no_handlerreturnPoint_332: # return from a 'finally' without 'packet'
	movq %r13, %rax
	jmp .aux_try_excep_finally_return_no_handler_endFunction_316 	# return reached : end function
	movq $.aux_try_excep_finally_return_no_handlertryContinue_317, %rbx
	jmp .aux_try_excep_finally_return_no_handlerfinally_319
.aux_try_excep_finally_return_no_handlertryContinue_317:
	movq $1, %rax
	neg %rax
	movq %rax, %r13
	jmp .aux_try_excep_finally_return_no_handler_endFunction_316 	# return reached : end function
.aux_try_excep_finally_return_no_handler_endFunction_316:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl test_try_excep_finally_return_no_handler
 test_try_excep_finally_return_no_handler:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	movq $9, %rax
	pushq %rax
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq aux_try_excep_finally_return_no_handler
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .test_try_excep_finally_return_no_handler_endExceptionCaught_334
	jmp .test_try_excep_finally_return_no_handler_endFunction_333	# exception still not caught by the caller
.test_try_excep_finally_return_no_handler_endExceptionCaught_334:
	popq %rcx
	cmpq %rcx, %rax
	je .test_try_excep_finally_return_no_handler_successCmp_335
	xorq %rax, %rax
	jmp .test_try_excep_finally_return_no_handler_continueCmp_336
.test_try_excep_finally_return_no_handler_successCmp_335:
	movq $1, %rax
.test_try_excep_finally_return_no_handler_continueCmp_336:
	cmpq $0, %rax
	je .test_try_excep_finally_return_no_handler_failureIf_338
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_58, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_try_excep_finally_return_no_handler_endExceptionCaught_339
	jmp .test_try_excep_finally_return_no_handler_endFunction_333	# exception still not caught by the caller
.test_try_excep_finally_return_no_handler_endExceptionCaught_339:
	jmp .test_try_excep_finally_return_no_handler_endIf_337
.test_try_excep_finally_return_no_handler_failureIf_338:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_59, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_try_excep_finally_return_no_handler_endExceptionCaught_340
	jmp .test_try_excep_finally_return_no_handler_endFunction_333	# exception still not caught by the caller
.test_try_excep_finally_return_no_handler_endExceptionCaught_340:
.test_try_excep_finally_return_no_handler_endIf_337:
.test_try_excep_finally_return_no_handler_endFunction_333:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl aux_try_excep_finally_return_handler
 aux_try_excep_finally_return_handler:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	jmp .aux_try_excep_finally_return_handlertryBegin_343
.aux_try_excep_finally_return_handlerfinally_344:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_70, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_finally_return_handler_endExceptionCaught_345
	jmp .aux_try_excep_finally_return_handler_endFunction_341	# exception still not caught by the caller
.aux_try_excep_finally_return_handler_endExceptionCaught_345:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_finally_return_handler_endExceptionCaught_346
	jmp .aux_try_excep_finally_return_handler_endFunction_341	# exception still not caught by the caller
.aux_try_excep_finally_return_handler_endExceptionCaught_346:
	jmp *%rbx
.aux_try_excep_finally_return_handler_E1_exception_347:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_finally_return_handler_endExceptionCaught_348
	movq $.aux_try_excep_finally_return_handlerreturnPoint_349, %rbx
	jmp .aux_try_excep_finally_return_handlerfinally_344
.aux_try_excep_finally_return_handlerreturnPoint_349: # return from a 'finally' without 'packet'
	jmp .aux_try_excep_finally_return_handler_endFunction_341	# exception still not caught by the caller
.aux_try_excep_finally_return_handler_endExceptionCaught_348:
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_63, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_finally_return_handler_endExceptionCaught_350
	movq $.aux_try_excep_finally_return_handlerreturnPoint_351, %rbx
	jmp .aux_try_excep_finally_return_handlerfinally_344
.aux_try_excep_finally_return_handlerreturnPoint_351: # return from a 'finally' without 'packet'
	jmp .aux_try_excep_finally_return_handler_endFunction_341	# exception still not caught by the caller
.aux_try_excep_finally_return_handler_endExceptionCaught_350:
	addq $8, %rsp
	movq $.aux_try_excep_finally_return_handlertryContinue_342, %rbx
	jmp .aux_try_excep_finally_return_handlerfinally_344
.aux_try_excep_finally_return_handler_E2_exception_352:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_finally_return_handler_endExceptionCaught_353
	movq $.aux_try_excep_finally_return_handlerreturnPoint_354, %rbx
	jmp .aux_try_excep_finally_return_handlerfinally_344
.aux_try_excep_finally_return_handlerreturnPoint_354: # return from a 'finally' without 'packet'
	jmp .aux_try_excep_finally_return_handler_endFunction_341	# exception still not caught by the caller
.aux_try_excep_finally_return_handler_endExceptionCaught_353:
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_65, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_finally_return_handler_endExceptionCaught_355
	movq $.aux_try_excep_finally_return_handlerreturnPoint_356, %rbx
	jmp .aux_try_excep_finally_return_handlerfinally_344
.aux_try_excep_finally_return_handlerreturnPoint_356: # return from a 'finally' without 'packet'
	jmp .aux_try_excep_finally_return_handler_endFunction_341	# exception still not caught by the caller
.aux_try_excep_finally_return_handler_endExceptionCaught_355:
	addq $8, %rsp
	movq $.aux_try_excep_finally_return_handlertryContinue_342, %rbx
	jmp .aux_try_excep_finally_return_handlerfinally_344
.aux_try_excep_finally_return_handler_E5_exception_357:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_finally_return_handler_endExceptionCaught_358
	movq $.aux_try_excep_finally_return_handlerreturnPoint_359, %rbx
	jmp .aux_try_excep_finally_return_handlerfinally_344
.aux_try_excep_finally_return_handlerreturnPoint_359: # return from a 'finally' without 'packet'
	jmp .aux_try_excep_finally_return_handler_endFunction_341	# exception still not caught by the caller
.aux_try_excep_finally_return_handler_endExceptionCaught_358:
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_67, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_finally_return_handler_endExceptionCaught_360
	movq $.aux_try_excep_finally_return_handlerreturnPoint_361, %rbx
	jmp .aux_try_excep_finally_return_handlerfinally_344
.aux_try_excep_finally_return_handlerreturnPoint_361: # return from a 'finally' without 'packet'
	jmp .aux_try_excep_finally_return_handler_endFunction_341	# exception still not caught by the caller
.aux_try_excep_finally_return_handler_endExceptionCaught_360:
	addq $8, %rsp
	movq $.aux_try_excep_finally_return_handlertryContinue_342, %rbx
	jmp .aux_try_excep_finally_return_handlerfinally_344
.aux_try_excep_finally_return_handler_E3_exception_362:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_finally_return_handler_endExceptionCaught_363
	movq $.aux_try_excep_finally_return_handlerreturnPoint_364, %rbx
	jmp .aux_try_excep_finally_return_handlerfinally_344
.aux_try_excep_finally_return_handlerreturnPoint_364: # return from a 'finally' without 'packet'
	jmp .aux_try_excep_finally_return_handler_endFunction_341	# exception still not caught by the caller
.aux_try_excep_finally_return_handler_endExceptionCaught_363:
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_69, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_finally_return_handler_endExceptionCaught_365
	movq $.aux_try_excep_finally_return_handlerreturnPoint_366, %rbx
	jmp .aux_try_excep_finally_return_handlerfinally_344
.aux_try_excep_finally_return_handlerreturnPoint_366: # return from a 'finally' without 'packet'
	jmp .aux_try_excep_finally_return_handler_endFunction_341	# exception still not caught by the caller
.aux_try_excep_finally_return_handler_endExceptionCaught_365:
	addq $8, %rsp
	movq $.aux_try_excep_finally_return_handlertryContinue_342, %rbx
	jmp .aux_try_excep_finally_return_handlerfinally_344
.aux_try_excep_finally_return_handlertryBegin_343:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_finally_return_handler_endExceptionCaught_367
	movq $.exception_75, %rdx
	cmpq %rcx, %rdx
	je .aux_try_excep_finally_return_handler_E1_exception_347
	movq $.exception_77, %rdx
	cmpq %rcx, %rdx
	je .aux_try_excep_finally_return_handler_E2_exception_352
	movq $.exception_83, %rdx
	cmpq %rcx, %rdx
	je .aux_try_excep_finally_return_handler_E3_exception_362
	movq $.exception_79, %rdx
	cmpq %rcx, %rdx
	je .aux_try_excep_finally_return_handler_E5_exception_357
	movq $.aux_try_excep_finally_return_handlerreturnPoint_368, %rbx
	jmp .aux_try_excep_finally_return_handlerfinally_344
.aux_try_excep_finally_return_handlerreturnPoint_368: # return from a 'finally' without 'packet'
	jmp .aux_try_excep_finally_return_handler_endFunction_341	# exception still not caught by the caller
.aux_try_excep_finally_return_handler_endExceptionCaught_367:
	movq $0, .exception_not_caught_166
	movq $5, %rax
	movq %rax, %r13
	movq $.exception_79, %rcx
	movq $.aux_try_excep_finally_return_handlerreturnPoint_369, %rbx
	jmp .aux_try_excep_finally_return_handler_E5_exception_357 	# exception thrown 
.aux_try_excep_finally_return_handlerreturnPoint_369: # return from a 'finally' without 'packet'
	movq %r13, %rax
	jmp .aux_try_excep_finally_return_handler_endFunction_341 	# uncaught exception thrown : end function
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_61, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_finally_return_handler_endExceptionCaught_370
	movq $.exception_75, %rdx
	cmpq %rcx, %rdx
	je .aux_try_excep_finally_return_handler_E1_exception_347
	movq $.exception_77, %rdx
	cmpq %rcx, %rdx
	je .aux_try_excep_finally_return_handler_E2_exception_352
	movq $.exception_83, %rdx
	cmpq %rcx, %rdx
	je .aux_try_excep_finally_return_handler_E3_exception_362
	movq $.exception_79, %rdx
	cmpq %rcx, %rdx
	je .aux_try_excep_finally_return_handler_E5_exception_357
	movq $.aux_try_excep_finally_return_handlerreturnPoint_371, %rbx
	jmp .aux_try_excep_finally_return_handlerfinally_344
.aux_try_excep_finally_return_handlerreturnPoint_371: # return from a 'finally' without 'packet'
	jmp .aux_try_excep_finally_return_handler_endFunction_341	# exception still not caught by the caller
.aux_try_excep_finally_return_handler_endExceptionCaught_370:
	movq $5, %rax
	movq %rax, %r13
	movq $.aux_try_excep_finally_return_handlerreturnPoint_372, %rbx
	jmp .aux_try_excep_finally_return_handlerfinally_344
.aux_try_excep_finally_return_handlerreturnPoint_372: # return from a 'finally' without 'packet'
	movq %r13, %rax
	jmp .aux_try_excep_finally_return_handler_endFunction_341 	# return reached : end function
	movq $.aux_try_excep_finally_return_handlertryContinue_342, %rbx
	jmp .aux_try_excep_finally_return_handlerfinally_344
.aux_try_excep_finally_return_handlertryContinue_342:
	movq $1, %rax
	neg %rax
	movq %rax, %r13
	jmp .aux_try_excep_finally_return_handler_endFunction_341 	# return reached : end function
.aux_try_excep_finally_return_handler_endFunction_341:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl test_try_excep_finally_return_handler
 test_try_excep_finally_return_handler:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	movq $1, %rax
	neg %rax
	pushq %rax
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq aux_try_excep_finally_return_handler
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .test_try_excep_finally_return_handler_endExceptionCaught_374
	jmp .test_try_excep_finally_return_handler_endFunction_373	# exception still not caught by the caller
.test_try_excep_finally_return_handler_endExceptionCaught_374:
	popq %rcx
	cmpq %rcx, %rax
	je .test_try_excep_finally_return_handler_successCmp_375
	xorq %rax, %rax
	jmp .test_try_excep_finally_return_handler_continueCmp_376
.test_try_excep_finally_return_handler_successCmp_375:
	movq $1, %rax
.test_try_excep_finally_return_handler_continueCmp_376:
	cmpq $0, %rax
	je .test_try_excep_finally_return_handler_failureIf_378
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_71, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_try_excep_finally_return_handler_endExceptionCaught_379
	jmp .test_try_excep_finally_return_handler_endFunction_373	# exception still not caught by the caller
.test_try_excep_finally_return_handler_endExceptionCaught_379:
	jmp .test_try_excep_finally_return_handler_endIf_377
.test_try_excep_finally_return_handler_failureIf_378:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_72, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_try_excep_finally_return_handler_endExceptionCaught_380
	jmp .test_try_excep_finally_return_handler_endFunction_373	# exception still not caught by the caller
.test_try_excep_finally_return_handler_endExceptionCaught_380:
.test_try_excep_finally_return_handler_endIf_377:
.test_try_excep_finally_return_handler_endFunction_373:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl aux_try_excep_in_catch
 aux_try_excep_in_catch:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	jmp .aux_try_excep_in_catchtryBegin_383
.aux_try_excep_in_catchfinally_384:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_85, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_in_catch_endExceptionCaught_385
	jmp .aux_try_excep_in_catch_endFunction_381	# exception still not caught by the caller
.aux_try_excep_in_catch_endExceptionCaught_385:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_in_catch_endExceptionCaught_386
	jmp .aux_try_excep_in_catch_endFunction_381	# exception still not caught by the caller
.aux_try_excep_in_catch_endExceptionCaught_386:
	jmp *%rbx
.aux_try_excep_in_catch_E1_exception_387:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_in_catch_endExceptionCaught_388
	movq $.aux_try_excep_in_catchreturnPoint_389, %rbx
	jmp .aux_try_excep_in_catchfinally_384
.aux_try_excep_in_catchreturnPoint_389: # return from a 'finally' without 'packet'
	jmp .aux_try_excep_in_catch_endFunction_381	# exception still not caught by the caller
.aux_try_excep_in_catch_endExceptionCaught_388:
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_76, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_in_catch_endExceptionCaught_390
	movq $.aux_try_excep_in_catchreturnPoint_391, %rbx
	jmp .aux_try_excep_in_catchfinally_384
.aux_try_excep_in_catchreturnPoint_391: # return from a 'finally' without 'packet'
	jmp .aux_try_excep_in_catch_endFunction_381	# exception still not caught by the caller
.aux_try_excep_in_catch_endExceptionCaught_390:
	addq $8, %rsp
	movq $.aux_try_excep_in_catchtryContinue_382, %rbx
	jmp .aux_try_excep_in_catchfinally_384
.aux_try_excep_in_catch_E2_exception_392:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_in_catch_endExceptionCaught_393
	movq $.aux_try_excep_in_catchreturnPoint_394, %rbx
	jmp .aux_try_excep_in_catchfinally_384
.aux_try_excep_in_catchreturnPoint_394: # return from a 'finally' without 'packet'
	jmp .aux_try_excep_in_catch_endFunction_381	# exception still not caught by the caller
.aux_try_excep_in_catch_endExceptionCaught_393:
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_78, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_in_catch_endExceptionCaught_395
	movq $.aux_try_excep_in_catchreturnPoint_396, %rbx
	jmp .aux_try_excep_in_catchfinally_384
.aux_try_excep_in_catchreturnPoint_396: # return from a 'finally' without 'packet'
	jmp .aux_try_excep_in_catch_endFunction_381	# exception still not caught by the caller
.aux_try_excep_in_catch_endExceptionCaught_395:
	addq $8, %rsp
	movq $.aux_try_excep_in_catchtryContinue_382, %rbx
	jmp .aux_try_excep_in_catchfinally_384
.aux_try_excep_in_catch_E5_exception_397:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_in_catch_endExceptionCaught_398
	movq $.aux_try_excep_in_catchreturnPoint_399, %rbx
	jmp .aux_try_excep_in_catchfinally_384
.aux_try_excep_in_catchreturnPoint_399: # return from a 'finally' without 'packet'
	jmp .aux_try_excep_in_catch_endFunction_381	# exception still not caught by the caller
.aux_try_excep_in_catch_endExceptionCaught_398:
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_80, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_in_catch_endExceptionCaught_400
	movq $.aux_try_excep_in_catchreturnPoint_401, %rbx
	jmp .aux_try_excep_in_catchfinally_384
.aux_try_excep_in_catchreturnPoint_401: # return from a 'finally' without 'packet'
	jmp .aux_try_excep_in_catch_endFunction_381	# exception still not caught by the caller
.aux_try_excep_in_catch_endExceptionCaught_400:
	movq $1, .exception_not_caught_166
	movq $21569, %rax
	movq %rax, %r13
	movq $.exception_87, %rcx
	movq $.aux_try_excep_in_catchreturnPoint_402, %rbx
	jmp .aux_try_excep_in_catchfinally_384 	# exception thrown 
.aux_try_excep_in_catchreturnPoint_402: # return from a 'finally' without 'packet'
	movq %r13, %rax
	jmp .aux_try_excep_in_catch_endFunction_381 	# uncaught exception thrown : end function
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_82, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_in_catch_endExceptionCaught_403
	movq $.aux_try_excep_in_catchreturnPoint_404, %rbx
	jmp .aux_try_excep_in_catchfinally_384
.aux_try_excep_in_catchreturnPoint_404: # return from a 'finally' without 'packet'
	jmp .aux_try_excep_in_catch_endFunction_381	# exception still not caught by the caller
.aux_try_excep_in_catch_endExceptionCaught_403:
	addq $8, %rsp
	movq $.aux_try_excep_in_catchtryContinue_382, %rbx
	jmp .aux_try_excep_in_catchfinally_384
.aux_try_excep_in_catch_E3_exception_405:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_in_catch_endExceptionCaught_406
	movq $.aux_try_excep_in_catchreturnPoint_407, %rbx
	jmp .aux_try_excep_in_catchfinally_384
.aux_try_excep_in_catchreturnPoint_407: # return from a 'finally' without 'packet'
	jmp .aux_try_excep_in_catch_endFunction_381	# exception still not caught by the caller
.aux_try_excep_in_catch_endExceptionCaught_406:
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_84, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_in_catch_endExceptionCaught_408
	movq $.aux_try_excep_in_catchreturnPoint_409, %rbx
	jmp .aux_try_excep_in_catchfinally_384
.aux_try_excep_in_catchreturnPoint_409: # return from a 'finally' without 'packet'
	jmp .aux_try_excep_in_catch_endFunction_381	# exception still not caught by the caller
.aux_try_excep_in_catch_endExceptionCaught_408:
	addq $8, %rsp
	movq $.aux_try_excep_in_catchtryContinue_382, %rbx
	jmp .aux_try_excep_in_catchfinally_384
.aux_try_excep_in_catchtryBegin_383:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq do_nothing
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_in_catch_endExceptionCaught_410
	movq $.exception_75, %rdx
	cmpq %rcx, %rdx
	je .aux_try_excep_in_catch_E1_exception_387
	movq $.exception_77, %rdx
	cmpq %rcx, %rdx
	je .aux_try_excep_in_catch_E2_exception_392
	movq $.exception_83, %rdx
	cmpq %rcx, %rdx
	je .aux_try_excep_in_catch_E3_exception_405
	movq $.exception_79, %rdx
	cmpq %rcx, %rdx
	je .aux_try_excep_in_catch_E5_exception_397
	movq $.aux_try_excep_in_catchreturnPoint_411, %rbx
	jmp .aux_try_excep_in_catchfinally_384
.aux_try_excep_in_catchreturnPoint_411: # return from a 'finally' without 'packet'
	jmp .aux_try_excep_in_catch_endFunction_381	# exception still not caught by the caller
.aux_try_excep_in_catch_endExceptionCaught_410:
	movq $0, .exception_not_caught_166
	movq $5, %rax
	movq %rax, %r13
	movq $.exception_79, %rcx
	movq $.aux_try_excep_in_catchreturnPoint_412, %rbx
	jmp .aux_try_excep_in_catch_E5_exception_397 	# exception thrown 
.aux_try_excep_in_catchreturnPoint_412: # return from a 'finally' without 'packet'
	movq %r13, %rax
	jmp .aux_try_excep_in_catch_endFunction_381 	# uncaught exception thrown : end function
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_74, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux_try_excep_in_catch_endExceptionCaught_413
	movq $.exception_75, %rdx
	cmpq %rcx, %rdx
	je .aux_try_excep_in_catch_E1_exception_387
	movq $.exception_77, %rdx
	cmpq %rcx, %rdx
	je .aux_try_excep_in_catch_E2_exception_392
	movq $.exception_83, %rdx
	cmpq %rcx, %rdx
	je .aux_try_excep_in_catch_E3_exception_405
	movq $.exception_79, %rdx
	cmpq %rcx, %rdx
	je .aux_try_excep_in_catch_E5_exception_397
	movq $.aux_try_excep_in_catchreturnPoint_414, %rbx
	jmp .aux_try_excep_in_catchfinally_384
.aux_try_excep_in_catchreturnPoint_414: # return from a 'finally' without 'packet'
	jmp .aux_try_excep_in_catch_endFunction_381	# exception still not caught by the caller
.aux_try_excep_in_catch_endExceptionCaught_413:
	movq $5, %rax
	movq %rax, %r13
	movq $.aux_try_excep_in_catchreturnPoint_415, %rbx
	jmp .aux_try_excep_in_catchfinally_384
.aux_try_excep_in_catchreturnPoint_415: # return from a 'finally' without 'packet'
	movq %r13, %rax
	jmp .aux_try_excep_in_catch_endFunction_381 	# return reached : end function
	movq $.aux_try_excep_in_catchtryContinue_382, %rbx
	jmp .aux_try_excep_in_catchfinally_384
.aux_try_excep_in_catchtryContinue_382:
	movq $1, %rax
	neg %rax
	movq %rax, %r13
	jmp .aux_try_excep_in_catch_endFunction_381 	# return reached : end function
.aux_try_excep_in_catch_endFunction_381:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl test_try_excep_in_catch
 test_try_excep_in_catch:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	jmp .test_try_excep_in_catchtryBegin_418
.test_try_excep_in_catch_E20_exception_419:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_88, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .test_try_excep_in_catch_endExceptionCaught_420
	jmp .test_try_excep_in_catch_endFunction_416	# exception still not caught by the caller
.test_try_excep_in_catch_endExceptionCaught_420:
	addq $8, %rsp
	jmp .test_try_excep_in_catchtryContinue_417
.test_try_excep_in_catchtryBegin_418:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq aux_try_excep_in_catch
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_try_excep_in_catch_endExceptionCaught_421
	movq $.exception_87, %rdx
	cmpq %rcx, %rdx
	je .test_try_excep_in_catch_E20_exception_419
	jmp .test_try_excep_in_catch_endFunction_416	# exception still not caught by the caller
.test_try_excep_in_catch_endExceptionCaught_421:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_86, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_try_excep_in_catch_endExceptionCaught_422
	movq $.exception_87, %rdx
	cmpq %rcx, %rdx
	je .test_try_excep_in_catch_E20_exception_419
	jmp .test_try_excep_in_catch_endFunction_416	# exception still not caught by the caller
.test_try_excep_in_catch_endExceptionCaught_422:
.test_try_excep_in_catchtryContinue_417:
.test_try_excep_in_catch_endFunction_416:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl aux_b2
 aux_b2:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	jmp .aux_b2tryBegin_425
.aux_b2_A_exception_426:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	movq $1, %rax
	movq %rax, %r13
	jmp .aux_b2_endFunction_423 	# return reached : end function
	addq $8, %rsp
	jmp .aux_b2tryContinue_424
.aux_b2_B_exception_427:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	movq $2, %rax
	movq %rax, %r13
	jmp .aux_b2_endFunction_423 	# return reached : end function
	addq $8, %rsp
	jmp .aux_b2tryContinue_424
.aux_b2tryBegin_425:
	movq $0, .exception_not_caught_166
	movq $.string_90, %rax
	movq %rax, %r13
	movq $.exception_92, %rcx
	movq $.aux_b2returnPoint_428, %rbx
	jmp .aux_b2_B_exception_427 	# exception thrown 
.aux_b2returnPoint_428: # return from a 'finally' without 'packet'
	movq %r13, %rax
	jmp .aux_b2_endFunction_423 	# uncaught exception thrown : end function
.aux_b2tryContinue_424:
.aux_b2_endFunction_423:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl test_b2
 test_b2:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	movq $2, %rax
	pushq %rax
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq aux_b2
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .test_b2_endExceptionCaught_430
	jmp .test_b2_endFunction_429	# exception still not caught by the caller
.test_b2_endExceptionCaught_430:
	popq %rcx
	cmpq %rcx, %rax
	je .test_b2_successCmp_431
	xorq %rax, %rax
	jmp .test_b2_continueCmp_432
.test_b2_successCmp_431:
	movq $1, %rax
.test_b2_continueCmp_432:
	cmpq $0, %rax
	je .test_b2_failureIf_434
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_93, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_b2_endExceptionCaught_435
	jmp .test_b2_endFunction_429	# exception still not caught by the caller
.test_b2_endExceptionCaught_435:
	jmp .test_b2_endIf_433
.test_b2_failureIf_434:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_94, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_b2_endExceptionCaught_436
	jmp .test_b2_endFunction_429	# exception still not caught by the caller
.test_b2_endExceptionCaught_436:
.test_b2_endIf_433:
.test_b2_endFunction_429:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl aux_b3
 aux_b3:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	jmp .aux_b3tryBegin_439
.aux_b3finally_440:
	movq $0, .exception_not_caught_166
	movq $0, %rax
	movq %rax, %r13
	jmp .aux_b3_endFunction_437 	# return reached : end function
	jmp *%rbx
.aux_b3_A_exception_441:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	movq $1, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	addq %rcx, %rax
	movq %rax, %r13
	movq $.aux_b3returnPoint_442, %rbx
	jmp .aux_b3finally_440
.aux_b3returnPoint_442: # return from a 'finally' without 'packet'
	movq %r13, %rax
	jmp .aux_b3_endFunction_437 	# return reached : end function
	addq $8, %rsp
	movq $.aux_b3tryContinue_438, %rbx
	jmp .aux_b3finally_440
.aux_b3tryBegin_439:
	movq $0, .exception_not_caught_166
	movq $2, %rax
	movq %rax, %r13
	movq $.exception_96, %rcx
	movq $.aux_b3returnPoint_443, %rbx
	jmp .aux_b3_A_exception_441 	# exception thrown 
.aux_b3returnPoint_443: # return from a 'finally' without 'packet'
	movq %r13, %rax
	jmp .aux_b3_endFunction_437 	# uncaught exception thrown : end function
	movq $.aux_b3tryContinue_438, %rbx
	jmp .aux_b3finally_440
.aux_b3tryContinue_438:
.aux_b3_endFunction_437:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl test_b3
 test_b3:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	movq $3, %rax
	pushq %rax
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq aux_b3
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .test_b3_endExceptionCaught_445
	jmp .test_b3_endFunction_444	# exception still not caught by the caller
.test_b3_endExceptionCaught_445:
	popq %rcx
	cmpq %rcx, %rax
	je .test_b3_successCmp_446
	xorq %rax, %rax
	jmp .test_b3_continueCmp_447
.test_b3_successCmp_446:
	movq $1, %rax
.test_b3_continueCmp_447:
	cmpq $0, %rax
	je .test_b3_failureIf_449
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_97, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_b3_endExceptionCaught_450
	jmp .test_b3_endFunction_444	# exception still not caught by the caller
.test_b3_endExceptionCaught_450:
	jmp .test_b3_endIf_448
.test_b3_failureIf_449:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_98, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_b3_endExceptionCaught_451
	jmp .test_b3_endFunction_444	# exception still not caught by the caller
.test_b3_endExceptionCaught_451:
.test_b3_endIf_448:
.test_b3_endFunction_444:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl aux_b6
 aux_b6:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	subq $8, %rsp
	movq $0, %rax
	movq %rax, -8(%rbp)
	jmp .aux_b6tryBegin_454
.aux_b6finally_455:
	movq -8(%rbp), %rax
	pushq %rax	# the value of expr is stored in for later
	inc %rax
	movq %rax, -8(%rbp)
	popq %rax
	movq $1, %rax
	pushq %rax
	movq -8(%rbp), %rax
	popq %rcx
	cmpq %rcx, %rax
	je .aux_b6_successCmp_456
	xorq %rax, %rax
	jmp .aux_b6_continueCmp_457
.aux_b6_successCmp_456:
	movq $1, %rax
.aux_b6_continueCmp_457:
	cmpq $0, %rax
	je .aux_b6_failureIf_459
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_100, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_b6_endExceptionCaught_460
	jmp .aux_b6_endFunction_452	# exception still not caught by the caller
.aux_b6_endExceptionCaught_460:
	jmp .aux_b6_endIf_458
.aux_b6_failureIf_459:
.aux_b6_endIf_458:
	jmp *%rbx
.aux_b6tryBegin_454:
	movq $1, .exception_not_caught_166
	movq $2, %rax
	movq %rax, %r13
	movq $.exception_103, %rcx
	movq $.aux_b6returnPoint_461, %rbx
	jmp .aux_b6finally_455 	# exception thrown 
.aux_b6returnPoint_461: # return from a 'finally' without 'packet'
	movq %r13, %rax
	jmp .aux_b6_endFunction_452 	# uncaught exception thrown : end function
	movq $.aux_b6tryContinue_453, %rbx
	jmp .aux_b6finally_455
.aux_b6tryContinue_453:
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_101, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux_b6_endExceptionCaught_462
	jmp .aux_b6_endFunction_452	# exception still not caught by the caller
.aux_b6_endExceptionCaught_462:
	movq -8(%rbp), %rax
	movq %rax, %r13
	jmp .aux_b6_endFunction_452 	# return reached : end function
	addq $8, %rsp
.aux_b6_endFunction_452:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl test_b6
 test_b6:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	jmp .test_b6tryBegin_465
.test_b6_Z_exception_466:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_104, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .test_b6_endExceptionCaught_467
	jmp .test_b6_endFunction_463	# exception still not caught by the caller
.test_b6_endExceptionCaught_467:
	addq $8, %rsp
	jmp .test_b6tryContinue_464
.test_b6tryBegin_465:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq aux_b6
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_b6_endExceptionCaught_468
	movq $.exception_103, %rdx
	cmpq %rcx, %rdx
	je .test_b6_Z_exception_466
	jmp .test_b6_endFunction_463	# exception still not caught by the caller
.test_b6_endExceptionCaught_468:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_102, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_b6_endExceptionCaught_469
	movq $.exception_103, %rdx
	cmpq %rcx, %rdx
	je .test_b6_Z_exception_466
	jmp .test_b6_endFunction_463	# exception still not caught by the caller
.test_b6_endExceptionCaught_469:
.test_b6tryContinue_464:
.test_b6_endFunction_463:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl aux1_b7
 aux1_b7:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	pushq %rdi	# saving argument number 1 on the stack
	jmp .aux1_b7tryBegin_472
.aux1_b7finally_473:
	movq $0, %rax
	movq -8(%rbp), %rdx
	movq (%rdx, %rax, 8), %rcx
	pushq %rcx	# the value of expr is stored in for later
	inc %rcx
	movq %rcx, (%rdx, %rax, 8)
	movq %rcx, %rax
	popq %rax
	jmp *%rbx
.aux1_b7tryBegin_472:
	movq $0, %rax
	movq -8(%rbp), %rdx
	movq (%rdx, %rax, 8), %rcx
	pushq %rcx	# the value of expr is stored in for later
	inc %rcx
	movq %rcx, (%rdx, %rax, 8)
	movq %rcx, %rax
	popq %rax
	movq -8(%rbp), %rax
	movq %rax, %r13
	movq $.aux1_b7returnPoint_474, %rbx
	jmp .aux1_b7finally_473
.aux1_b7returnPoint_474: # return from a 'finally' without 'packet'
	movq %r13, %rax
	jmp .aux1_b7_endFunction_470 	# return reached : end function
	movq $.aux1_b7tryContinue_471, %rbx
	jmp .aux1_b7finally_473
.aux1_b7tryContinue_471:
.aux1_b7_endFunction_470:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl aux2_b7
 aux2_b7:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	subq $8, %rsp
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $8, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq malloc
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux2_b7_endExceptionCaught_476
	jmp .aux2_b7_endFunction_475	# exception still not caught by the caller
.aux2_b7_endExceptionCaught_476:
	movq %rax, -8(%rbp)
	movq $0, %rax
	pushq %rax
	movq $0, %rax
	popq %rcx
	movq -8(%rbp), %rdx
	movq %rcx, (%rdx, %rax, 8)
	movq %rcx, %rax
	movq $0, %rax
	pushq %rax
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -8(%rbp), %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq aux1_b7
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .aux2_b7_endExceptionCaught_477
	jmp .aux2_b7_endFunction_475	# exception still not caught by the caller
.aux2_b7_endExceptionCaught_477:
	popq %rcx
	movq %rax, %r13
	jmp .aux2_b7_endFunction_475 	# return reached : end function
	addq $8, %rsp
.aux2_b7_endFunction_475:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl test_b7
 test_b7:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	movq $2, %rax
	pushq %rax
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq aux2_b7
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .test_b7_endExceptionCaught_479
	jmp .test_b7_endFunction_478	# exception still not caught by the caller
.test_b7_endExceptionCaught_479:
	popq %rcx
	cmpq %rcx, %rax
	je .test_b7_successCmp_480
	xorq %rax, %rax
	jmp .test_b7_continueCmp_481
.test_b7_successCmp_480:
	movq $1, %rax
.test_b7_continueCmp_481:
	cmpq $0, %rax
	je .test_b7_failureIf_483
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_105, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_b7_endExceptionCaught_484
	jmp .test_b7_endFunction_478	# exception still not caught by the caller
.test_b7_endExceptionCaught_484:
	jmp .test_b7_endIf_482
.test_b7_failureIf_483:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_106, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_b7_endExceptionCaught_485
	jmp .test_b7_endFunction_478	# exception still not caught by the caller
.test_b7_endExceptionCaught_485:
.test_b7_endIf_482:
.test_b7_endFunction_478:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl aux1_twisted1
 aux1_twisted1:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	movq $42, %rax
	movq %rax, %r13
	jmp .aux1_twisted1_endFunction_486 	# return reached : end function
.aux1_twisted1_endFunction_486:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl aux2_twisted1
 aux2_twisted1:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	subq $8, %rsp
	jmp .aux2_twisted1tryBegin_489
.aux2_twisted1finally_490:
	movq -8(%rbp), %rax
	pushq %rax	# the value of expr is stored in for later
	inc %rax
	movq %rax, -8(%rbp)
	popq %rax
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq -8(%rbp), %rax
	pushq %rax	# putting argument number 2 on the stack
	movq $.string_107, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	popq %rsi	# putting argument number 2 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux2_twisted1_endExceptionCaught_491
	jmp .aux2_twisted1_endFunction_487	# exception still not caught by the caller
.aux2_twisted1_endExceptionCaught_491:
	jmp *%rbx
.aux2_twisted1tryBegin_489:
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq aux1_twisted1
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .aux2_twisted1_endExceptionCaught_492
	movq $.aux2_twisted1returnPoint_493, %rbx
	jmp .aux2_twisted1finally_490
.aux2_twisted1returnPoint_493: # return from a 'finally' without 'packet'
	jmp .aux2_twisted1_endFunction_487	# exception still not caught by the caller
.aux2_twisted1_endExceptionCaught_492:
	movq %rax, -8(%rbp)
	movq -8(%rbp), %rax
	pushq %rax	# the value of expr is stored in for later
	inc %rax
	movq %rax, -8(%rbp)
	popq %rax
	movq -8(%rbp), %rax
	movq %rax, %r13
	movq $.aux2_twisted1returnPoint_494, %rbx
	jmp .aux2_twisted1finally_490
.aux2_twisted1returnPoint_494: # return from a 'finally' without 'packet'
	movq %r13, %rax
	jmp .aux2_twisted1_endFunction_487 	# return reached : end function
	movq $.aux2_twisted1tryContinue_488, %rbx
	jmp .aux2_twisted1finally_490
.aux2_twisted1tryContinue_488:
	addq $8, %rsp
.aux2_twisted1_endFunction_487:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl test_twisted1
 test_twisted1:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	movq $43, %rax
	pushq %rax
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq aux2_twisted1
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .test_twisted1_endExceptionCaught_496
	jmp .test_twisted1_endFunction_495	# exception still not caught by the caller
.test_twisted1_endExceptionCaught_496:
	popq %rcx
	cmpq %rcx, %rax
	je .test_twisted1_successCmp_497
	xorq %rax, %rax
	jmp .test_twisted1_continueCmp_498
.test_twisted1_successCmp_497:
	movq $1, %rax
.test_twisted1_continueCmp_498:
	cmpq $0, %rax
	je .test_twisted1_failureIf_500
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_108, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_twisted1_endExceptionCaught_501
	jmp .test_twisted1_endFunction_495	# exception still not caught by the caller
.test_twisted1_endExceptionCaught_501:
	jmp .test_twisted1_endIf_499
.test_twisted1_failureIf_500:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_109, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .test_twisted1_endExceptionCaught_502
	jmp .test_twisted1_endFunction_495	# exception still not caught by the caller
.test_twisted1_endExceptionCaught_502:
.test_twisted1_endIf_499:
.test_twisted1_endFunction_495:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl launch_test
 launch_test:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_165, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_504
	jmp .launch_test_endFunction_503	# exception still not caught by the caller
.launch_test_endExceptionCaught_504:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_111, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_505
	jmp .launch_test_endFunction_503	# exception still not caught by the caller
.launch_test_endExceptionCaught_505:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_112, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_506
	jmp .launch_test_endFunction_503	# exception still not caught by the caller
.launch_test_endExceptionCaught_506:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_113, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_507
	jmp .launch_test_endFunction_503	# exception still not caught by the caller
.launch_test_endExceptionCaught_507:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_114, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_508
	jmp .launch_test_endFunction_503	# exception still not caught by the caller
.launch_test_endExceptionCaught_508:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_161, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_509
	jmp .launch_test_endFunction_503	# exception still not caught by the caller
.launch_test_endExceptionCaught_509:
	jmp .launch_testtryBegin_511
.launch_test_E_exception_512:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_117, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_513
	jmp .launch_test_endFunction_503	# exception still not caught by the caller
.launch_test_endExceptionCaught_513:
	addq $8, %rsp
	jmp .launch_testtryContinue_510
.launch_testtryBegin_511:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq test_throw
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_514
	movq $.exception_121, %rdx
	cmpq %rcx, %rdx
	je .launch_test_E_exception_512
	jmp .launch_test_endFunction_503	# exception still not caught by the caller
.launch_test_endExceptionCaught_514:
.launch_testtryContinue_510:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_165, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_515
	jmp .launch_test_endFunction_503	# exception still not caught by the caller
.launch_test_endExceptionCaught_515:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_119, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_516
	jmp .launch_test_endFunction_503	# exception still not caught by the caller
.launch_test_endExceptionCaught_516:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_161, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_517
	jmp .launch_test_endFunction_503	# exception still not caught by the caller
.launch_test_endExceptionCaught_517:
	jmp .launch_testtryBegin_519
.launch_test_E_exception_520:
	movq $0, .exception_not_caught_166
	subq $8, %rsp
	movq %rax, -8(%rbp)
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_122, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_521
	jmp .launch_test_endFunction_503	# exception still not caught by the caller
.launch_test_endExceptionCaught_521:
	addq $8, %rsp
	jmp .launch_testtryContinue_518
.launch_testtryBegin_519:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq test_call
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_522
	movq $.exception_121, %rdx
	cmpq %rcx, %rdx
	je .launch_test_E_exception_520
	jmp .launch_test_endFunction_503	# exception still not caught by the caller
.launch_test_endExceptionCaught_522:
.launch_testtryContinue_518:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_165, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_523
	jmp .launch_test_endFunction_503	# exception still not caught by the caller
.launch_test_endExceptionCaught_523:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_124, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_524
	jmp .launch_test_endFunction_503	# exception still not caught by the caller
.launch_test_endExceptionCaught_524:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_164, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_525
	jmp .launch_test_endFunction_503	# exception still not caught by the caller
.launch_test_endExceptionCaught_525:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq test_try_no_excep_no_finally_no_return
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_526
	jmp .launch_test_endFunction_503	# exception still not caught by the caller
.launch_test_endExceptionCaught_526:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_165, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_527
	jmp .launch_test_endFunction_503	# exception still not caught by the caller
.launch_test_endExceptionCaught_527:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_127, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_528
	jmp .launch_test_endFunction_503	# exception still not caught by the caller
.launch_test_endExceptionCaught_528:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_161, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_529
	jmp .launch_test_endFunction_503	# exception still not caught by the caller
.launch_test_endExceptionCaught_529:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq test_try_no_excep_no_finally_return
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_530
	jmp .launch_test_endFunction_503	# exception still not caught by the caller
.launch_test_endExceptionCaught_530:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_165, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_531
	jmp .launch_test_endFunction_503	# exception still not caught by the caller
.launch_test_endExceptionCaught_531:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_130, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_532
	jmp .launch_test_endFunction_503	# exception still not caught by the caller
.launch_test_endExceptionCaught_532:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_146, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_533
	jmp .launch_test_endFunction_503	# exception still not caught by the caller
.launch_test_endExceptionCaught_533:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq test_try_no_excep_finally_no_return
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_534
	jmp .launch_test_endFunction_503	# exception still not caught by the caller
.launch_test_endExceptionCaught_534:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_165, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_535
	jmp .launch_test_endFunction_503	# exception still not caught by the caller
.launch_test_endExceptionCaught_535:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_133, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_536
	jmp .launch_test_endFunction_503	# exception still not caught by the caller
.launch_test_endExceptionCaught_536:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_146, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_537
	jmp .launch_test_endFunction_503	# exception still not caught by the caller
.launch_test_endExceptionCaught_537:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq test_try_no_excep_finally_return
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_538
	jmp .launch_test_endFunction_503	# exception still not caught by the caller
.launch_test_endExceptionCaught_538:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_165, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_539
	jmp .launch_test_endFunction_503	# exception still not caught by the caller
.launch_test_endExceptionCaught_539:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_136, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_540
	jmp .launch_test_endFunction_503	# exception still not caught by the caller
.launch_test_endExceptionCaught_540:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_146, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_541
	jmp .launch_test_endFunction_503	# exception still not caught by the caller
.launch_test_endExceptionCaught_541:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq test_try_no_excep_finally_return_2
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_542
	jmp .launch_test_endFunction_503	# exception still not caught by the caller
.launch_test_endExceptionCaught_542:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_165, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_543
	jmp .launch_test_endFunction_503	# exception still not caught by the caller
.launch_test_endExceptionCaught_543:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_139, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_544
	jmp .launch_test_endFunction_503	# exception still not caught by the caller
.launch_test_endExceptionCaught_544:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_146, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_545
	jmp .launch_test_endFunction_503	# exception still not caught by the caller
.launch_test_endExceptionCaught_545:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq test_try_no_excep_finally_return_3
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_546
	jmp .launch_test_endFunction_503	# exception still not caught by the caller
.launch_test_endExceptionCaught_546:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_165, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_547
	jmp .launch_test_endFunction_503	# exception still not caught by the caller
.launch_test_endExceptionCaught_547:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_142, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_548
	jmp .launch_test_endFunction_503	# exception still not caught by the caller
.launch_test_endExceptionCaught_548:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_164, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_549
	jmp .launch_test_endFunction_503	# exception still not caught by the caller
.launch_test_endExceptionCaught_549:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq test_try_excep_finally_return_no_handler
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_550
	jmp .launch_test_endFunction_503	# exception still not caught by the caller
.launch_test_endExceptionCaught_550:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_165, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_551
	jmp .launch_test_endFunction_503	# exception still not caught by the caller
.launch_test_endExceptionCaught_551:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_145, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_552
	jmp .launch_test_endFunction_503	# exception still not caught by the caller
.launch_test_endExceptionCaught_552:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_146, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_553
	jmp .launch_test_endFunction_503	# exception still not caught by the caller
.launch_test_endExceptionCaught_553:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq test_try_excep_finally_return_handler
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_554
	jmp .launch_test_endFunction_503	# exception still not caught by the caller
.launch_test_endExceptionCaught_554:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_165, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_555
	jmp .launch_test_endFunction_503	# exception still not caught by the caller
.launch_test_endExceptionCaught_555:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_148, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_556
	jmp .launch_test_endFunction_503	# exception still not caught by the caller
.launch_test_endExceptionCaught_556:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_164, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_557
	jmp .launch_test_endFunction_503	# exception still not caught by the caller
.launch_test_endExceptionCaught_557:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq test_try_excep_in_catch
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_558
	jmp .launch_test_endFunction_503	# exception still not caught by the caller
.launch_test_endExceptionCaught_558:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_165, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_559
	jmp .launch_test_endFunction_503	# exception still not caught by the caller
.launch_test_endExceptionCaught_559:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_151, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_560
	jmp .launch_test_endFunction_503	# exception still not caught by the caller
.launch_test_endExceptionCaught_560:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_161, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_561
	jmp .launch_test_endFunction_503	# exception still not caught by the caller
.launch_test_endExceptionCaught_561:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq test_b2
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_562
	jmp .launch_test_endFunction_503	# exception still not caught by the caller
.launch_test_endExceptionCaught_562:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_165, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_563
	jmp .launch_test_endFunction_503	# exception still not caught by the caller
.launch_test_endExceptionCaught_563:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_154, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_564
	jmp .launch_test_endFunction_503	# exception still not caught by the caller
.launch_test_endExceptionCaught_564:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_161, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_565
	jmp .launch_test_endFunction_503	# exception still not caught by the caller
.launch_test_endExceptionCaught_565:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq test_b3
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_566
	jmp .launch_test_endFunction_503	# exception still not caught by the caller
.launch_test_endExceptionCaught_566:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_165, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_567
	jmp .launch_test_endFunction_503	# exception still not caught by the caller
.launch_test_endExceptionCaught_567:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_157, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_568
	jmp .launch_test_endFunction_503	# exception still not caught by the caller
.launch_test_endExceptionCaught_568:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_164, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_569
	jmp .launch_test_endFunction_503	# exception still not caught by the caller
.launch_test_endExceptionCaught_569:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq test_b6
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_570
	jmp .launch_test_endFunction_503	# exception still not caught by the caller
.launch_test_endExceptionCaught_570:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_165, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_571
	jmp .launch_test_endFunction_503	# exception still not caught by the caller
.launch_test_endExceptionCaught_571:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_160, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_572
	jmp .launch_test_endFunction_503	# exception still not caught by the caller
.launch_test_endExceptionCaught_572:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_161, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_573
	jmp .launch_test_endFunction_503	# exception still not caught by the caller
.launch_test_endExceptionCaught_573:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq test_b7
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_574
	jmp .launch_test_endFunction_503	# exception still not caught by the caller
.launch_test_endExceptionCaught_574:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_165, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_575
	jmp .launch_test_endFunction_503	# exception still not caught by the caller
.launch_test_endExceptionCaught_575:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_163, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_576
	jmp .launch_test_endFunction_503	# exception still not caught by the caller
.launch_test_endExceptionCaught_576:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_164, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_577
	jmp .launch_test_endFunction_503	# exception still not caught by the caller
.launch_test_endExceptionCaught_577:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq test_twisted1
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_578
	jmp .launch_test_endFunction_503	# exception still not caught by the caller
.launch_test_endExceptionCaught_578:
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	movq $.string_165, %rax
	pushq %rax	# putting argument number 1 on the stack
	popq %rdi	# putting argument number 1 in register
	xorq %rax, %rax
	callq printf
	cltq
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .launch_test_endExceptionCaught_579
	jmp .launch_test_endFunction_503	# exception still not caught by the caller
.launch_test_endExceptionCaught_579:
.launch_test_endFunction_503:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
.globl main
 main:
	pushq %rbx	# saving callee-saved registers
	pushq %r12
	pushq %r13
	pushq %r14
	pushq %r15
	pushq %rbp	# base pointer
	movq %rsp, %rbp
	subq $8, %rsp	# to align the stack on a 16B boundary
	pushq %r10	# save caller-saved registers
	pushq %r11
	xorq %rax, %rax
	callq launch_test
	popq %r10	# retrieve caller-saved registers
	popq %r11
	addq $8, %rsp	# to restore the stack alignment
	cmpq $0, .exception_not_caught_166
	je .main_endExceptionCaught_581
	jmp .main_endFunction_580	# exception still not caught by the caller
.main_endExceptionCaught_581:
.main_endFunction_580:
	movq %rbp, %rsp
	popq %rbp
	popq %r15	# restoring callee-saved registers
	popq %r14
	popq %r13
	popq %r12
	popq %rbx
	retq
